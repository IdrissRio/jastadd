# Copyright (c) 2013-2015, The JastAdd Team
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright notice,
#       this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the Lund University nor the names of its
#       contributors may be used to endorse or promote products derived from
#       this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

collDebugCheck [[
$if(DebugMode)
if (node == null) {
  throw new RuntimeException(
      "Trying to evaluate collection attribute in subtree not attached to main tree");
}
$endif
]]

CollDecl.computeMethod:onePhase [[
  /** @apilevel internal */
  private #getType #(name)_compute() {
    $ASTNode node = this;
    while (node != null && !(node instanceof $RootType)) {
      node = node.getParent();
    }
    $include(collDebugCheck)
    $RootType root = ($RootType) node;
    root.survey_#collectionId();
    if (#(signature)_value == null) {
      #(signature)_value = $BottomValue;
    }
    return #(signature)_value;
  }
]]

CollDecl.computeMethod:twoPhase [[
  /** @apilevel internal */
  private #getType #(name)_compute() {
    $ASTNode node = this;
    while (node != null && !(node instanceof $RootType)) {
      node = node.getParent();
    }
    $include(collDebugCheck)
    $RootType root = ($RootType) node;
    root.survey_#collectionId();
    #getType _computedValue = $BottomValue;
    if (root.contributorMap_#collectionId.containsKey(this)) {
      for ($ASTNode contributor : root.contributorMap_#collectionId.get(this)) {
        contributor.contributeTo_#(signature)(_computedValue);
      }
    }
    return _computedValue;
  }
]]

CollEq.collectContributors:onePhase = [[
    // #declaredat
$if(HasCondition)
    if ($Condition) {
      $include(CollEq.contribution:onePhase)
    }
$else
    $include(CollEq.contribution:onePhase)
$endif
]]

CollEq.contribution:onePhase [[
$if(#getRefSet)
for (#getTargetName target : (Iterable<#getTargetName>) (#getReference)) {
  if (target != null) {
    if (target.#(signature)_value == null) {
      target.#(signature)_value = $BottomValue;
    }
    target.#(signature)_value.$CombOp($Value);
  }
}
$else
{
  #getTargetName target = #getReference;
  if (target != null) {
    if (target.#(signature)_value == null) {
      target.#(signature)_value = $BottomValue;
    }
    target.#(signature)_value.$CombOp($Value);
  }
}
$endif
]]

CollEq.collectContributors:twoPhase = [[
    // #declaredat
$if(HasCondition)
    if ($Condition) {
      $include(CollEq.contribution:twoPhase)
    }
$else
    $include(CollEq.contribution:twoPhase)
$endif
]]

CollEq.contribution:twoPhase [[
$if(#getRefSet)
for (#getTargetName target : (Iterable<#getTargetName>) (#getReference)) {
  if (target != null) {
    java.util.LinkedList<$ASTNode> contributors = map.get(target);
    if (contributors == null) {
      contributors = new java.util.LinkedList<$ASTNode>();
      map.put(($ASTNode) target, contributors);
    }
    contributors.add(this);
  }
}
$else
{
  #getTargetName target = (#getTargetName) (#getReference);
  if (target != null) {
    java.util.LinkedList<$ASTNode> contributors = map.get(target);
    if (contributors == null) {
      contributors = new java.util.LinkedList<$ASTNode>();
      map.put(($ASTNode) target, contributors);
    }
    contributors.add(this);
  }
}
$endif
]]

CollDecl.collectContributors:header [[
$if(#onePhase)
  protected void collect_contributors_#collectionId() {
$else
  protected void collect_contributors_#collectionId(java.util.Map<$ASTNode, java.util.LinkedList<$ASTNode>> map) {
$endif
]]

CollDecl.collectContributors:end [[
    for (int i = 0; i < getNumChild(); i++) {
      getChild(i).collect_contributors_#collectionId($if(!#onePhase)map$endif);
    }
  }
]]

CollDecl.contributeTo:default = [[
  protected void contributeTo_#(signature)(#getType collection) {
  }
]]

CollDecl.contributeTo:header [[
  protected void contributeTo_#(signature)(#getType collection) {
    super.contributeTo_#(signature)(collection);
]]

Contribution.statement [[
$if(#hasCondition)
    if (#getCondition) {
      collection.$CombOp(#getValue);
    }
$else
    collection.$CombOp(#getValue);
$endif
]]

# The method to start the survey phase (collecting contributors).
CollDecl.surveyMethod [[
$if(#onePhase)
private boolean collect_contributors_#collectionId = false;
$else
protected java.util.Map<$ASTNode, java.util.LinkedList<$ASTNode>> contributorMap_#collectionId = null;
$endif

$if(#isCircular)
  public boolean collecting_contributors_#collectionId = false;

$endif
  protected void survey_#collectionId() {
$if(#onePhase)
    if (!collect_contributors_#collectionId) {
      collect_contributors_#collectionId = true;
$else
    if (contributorMap_#collectionId == null) {
      contributorMap_#collectionId = new java.util.IdentityHashMap<$ASTNode, java.util.LinkedList<$ASTNode>>();
$endif
$if(#isCircular)
      collecting_contributors_#collectionId = true;
$endif
$if(#onePhase)
      collect_contributors_#collectionId();
$else
      collect_contributors_#collectionId(contributorMap_#collectionId);
$endif
$if(#isCircular)
      collecting_contributors_#collectionId = false;
$endif
    }
  }
]]

Collection.flush = [[
$if(#onePhase)
collect_contributors_#collectionId = false;
$else
contributorMap_#collectionId = null;
$endif
$if(#circularCollection)
collecting_contributors_#collectionId = false;
$endif
]]
