/* Copyright (c) 2011-2013, Emma SÃ¶derberg <emma.soderberg@cs.lth.se>
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Lund University nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
 aspect IncrementalNotification {
 
  public void ASTDecl.jjtGenIncrementalAffectedValue(PrintWriter stream) {
    if (!grammar().incremental) return; 
    // start method: inc_valueAffected
    if (grammar().incrementalLevelParam && grammar().incrementalPropLimit) {
      stream.println(ind + "public boolean " + name() + ".inc_valueAffected(String attrID, Object _parameters) {");
      ArrayList list = new ArrayList();
      for(int k = 0; k < getNumSynEq(); k++) {
        AttrDecl attr = getSynEq(k).decl();
        if (attr != null && (attr.getLazy() || attr.isCircular())) 
          list.add(attr);
      }
      for(int k = 0; k < getNumInhDecl(); k++) {
        AttrDecl attr = getInhDecl(k);
        if (attr != null && (attr.getLazy() || attr.isCircular())) 
          list.add(attr);
      }
      // Add attribute code: flush attributes
      boolean first = true;
      for(Iterator itr = list.iterator(); itr.hasNext();) {
        AttrDecl attr = (AttrDecl)itr.next();
        // NTAs: Are always considered affected
        if (attr.isNTA() || attr.getNTA()) {
          stream.println(ind(2) + "// NTA");              
          stream.print(ind(2) + (first ? "" : "else "));
          stream.print("if (" + "attrID.equals(\"" + attr.attributeSignature() + "\")");
          if (attr.getNumParameter() > 0) {
            stream.print(" && " + attr.attributeSignature() + "_values != null" + 
              " && " + attr.attributeSignature() + "_values.containsKey(_parameters)");
          } else {
            stream.print(" && " + attr.attributeSignature() + "_computed");
          }
          stream.println(") {");
          stream.println(ind(3) + "return true;");  
          stream.println(ind(2) + "}");      // end match statements            
        } 
        // non-NTAs
        else {
          // start match attribute statement
          stream.print(ind(2) + (first ? "" : "else "));
          stream.print("if (" + "attrID.equals(\"" + attr.attributeSignature() + "\")");
          if (attr.getNumParameter() > 0) {
            stream.print(" && " + attr.attributeSignature() + "_values != null" + 
              " && " + attr.attributeSignature() + "_values.containsKey(_parameters)");
          } else {
            stream.print(" && " + attr.attributeSignature() + "_computed");
          }
          stream.println(") {");
          // TODO: Add support for more than one parameter
          // with parameters
          if (attr.getNumParameter() > 0) {
            if (attr.isPrimitive()) {
              // store old value
              String type = attr.type();
              type = type.substring(0,1).toUpperCase() + type.substring(1);
              stream.println(ind(3) + attr.type() + " oldValue = " + type + ".valueOf((" + type + ")" + attr.attributeSignature() + "_values.get(_parameters));");
              // flush value
              stream.println(ind(3) + attr.attributeSignature() + "_values.remove(_parameters);"); 
              // clear dependencies in handler
              stream.println(ind(3) + "ASTNode$DepGraphNode handler = (ASTNode$DepGraphNode)" + attr.attributeSignature() + "_handler.get(_parameters);");
              stream.println(ind(3) + "handler.clearDependencies();");
              // compute new value
              if (attr.getNumParameter() == 1) {
                String param = "(" + attr.getParameter(0).getTypeInSignature() + ")_parameters";
                stream.println(ind(3) + attr.type() + " newValue = " + attr.getName() + "(" + param + ");");
              } else {
                stream.println(ind(3) + "throw new Error(\"No support for more than one parameter in affected value check\");");
              }
            } else {
              // store old value
              stream.println(ind(3) + attr.type() + " oldValue = (" + attr.type() + ")" + attr.attributeSignature() + "_values.get(_parameters);");
              // flush value
              stream.println(ind(3) + attr.attributeSignature() + "_values.remove(_parameters);"); 
              // clear dependencies in handler
              stream.println(ind(3) + "ASTNode$DepGraphNode handler = (ASTNode$DepGraphNode)" + attr.attributeSignature() + "_handler.get(_parameters);");
              stream.println(ind(3) + "handler.clearDependencies();");
              // compute new value
              if (attr.getNumParameter() == 1) {
                String param = "(" + attr.getParameter(0).getTypeInSignature() + ")_parameters";
                stream.println(ind(3) + attr.type() + " newValue = " + attr.getName() + "(" + param + ");");
              } else {
                stream.println(ind(3) + "throw new Error(\"No support for more than one parameter in affected value check\");");
              }
            }
          } 
          // without parameters
          else {
            // store old value + flush value
            stream.println(ind(3) + attr.type() + " oldValue = " + attr.attributeSignature() + "_value;");
            stream.print(attr.resetVisit());
            stream.print(attr.resetCache());
            // clear dependencies in handler  
            stream.println(ind(3) + attr.attributeSignature() + "_handler.clearDependencies();");
            // compute new value
            stream.println(ind(3) + attr.type() + " newValue = " + attr.getName() + "();");
          }
          // compare old and new value
          if (attr.isPrimitive()) {
            stream.println(ind(3) + "if (oldValue == newValue)");
          } else {
            stream.println(ind(3) + "Object obj = (Object)oldValue;");
            stream.println(ind(3) + "if ((obj instanceof ASTNode && (oldValue == newValue)) || " + 
              "(oldValue == null && newValue == null) || (oldValue != null && oldValue.equals(newValue)))");
          }
          stream.println(ind(4) + "return false;");
          stream.println(ind(3) + "return true;");
          stream.println(ind(2) + "}");      // end match statements
          first = false;
        }
      }
      if (name().equals("ASTNode"))
        stream.println(ind(2) + "return true;");      
      else 
        stream.println(ind(2) + "return super.inc_valueAffected(attrID, _parameters);");      
      stream.println(ind + "}");
    }
    // end method: inc_valueAffected
  }

  public void ASTDecl.jjtGenIncrementalReactToChange(PrintWriter stream) {
    if (!grammar().incremental) return; 
    // method: reactToDependencyChange
    if (grammar().incrementalLevelParam)
      stream.println(ind + "public void " + name() + ".reactToDependencyChange(String attrID, Object _parameters) {");      
    if (grammar().incrementalLevelAttr) 
      stream.println(ind + "public void " + name() + ".reactToDependencyChange(String attrID) {");      
    if (grammar().incrementalLevelNode) 
      if (name().equals("ASTNode"))
        stream.println(ind + "public void " + name() + ".reactToDependencyChange() {");      
    if (grammar().incrementalLevelRegion) {
      if (isRegionRoot() || name().equals("ASTNode")) 
        stream.println(ind + "public void " + name() + ".reactToDependencyChange() {");      
    }
    if (grammar().incrementalChangeFlush) {
      if (grammar().incrementalLevelRegion) {
        if (isRegionRoot())
          jjtGenIncrementalChangeFlush(stream);
      } else if (grammar().incrementalLevelNode) {
        if (name().equals("ASTNode")) 
          jjtGenIncrementalChangeFlush(stream);
      } else {
        jjtGenIncrementalChangeFlush(stream);
      }
    }
    // super class if not ASTNode
    if (!name().equals("ASTNode")) {
      if (grammar().incrementalLevelParam)
        stream.println(ind(2) + "super.reactToDependencyChange(attrID, _parameters);");      
      if (grammar().incrementalLevelAttr) 
        stream.println(ind(2) + "super.reactToDependencyChange(attrID);");   
    }

    if (grammar().incrementalLevelRegion) {
      if (isRegionRoot() || name().equals("ASTNode")) 
        stream.println(ind + "}");      
    } 
    else if (grammar().incrementalLevelNode) {
      if (name().equals("ASTNode")) {
        stream.println(ind + "}");
      }
    }
    else {
      stream.println(ind + "}");
    }
    // end method: reactToDependencyChange
    
    // method: inc_flush
    if (grammar().incrementalChangeFlush) {
      // collect attributes: syn, inh
      ArrayList list = new ArrayList();
      for(int k = 0; k < getNumSynEq(); k++) {
        AttrDecl attr = getSynEq(k).decl();
        if (attr != null && (attr.getLazy() || attr.isCircular())) 
          list.add(attr);
      }
      for(int k = 0; k < getNumInhDecl(); k++) {
        AttrDecl attr = getInhDecl(k);
        if (attr != null && (attr.getLazy() || attr.isCircular())) 
          list.add(attr);
      }

      // start method: inc_flush
      if (grammar().incrementalLevelNode || grammar().incrementalLevelRegion) {
        stream.println(ind + "public void " + name() + ".inc_flush() {");
        // flush attributes
        for(Iterator itr = list.iterator(); itr.hasNext();) {
          AttrDecl attr = (AttrDecl)itr.next();
          // NTAs
          if ((attr.isNTA() || attr.getNTA()) && !attr.isPrimitive() 
              && !(attr.type().equals("String") || attr.type().equals("java.lang.String"))) {

            if (grammar().incrementalLevelRegion) {
              // TODO: Add a flush of non-region root NTA children
            }
          } 
          // Non NTAs
          else {
            if (attr.getNumParameter() > 0) {
              stream.println(ind(2) + "if (" + attr.attributeSignature() + "_values != null && !" + 
                attr.attributeSignature() + "_values.isEmpty()) {");
              stream.print(attr.resetVisit());
              stream.print(attr.resetCache());
              //if (grammar().incrementalTrack) {
              //  stream.println(ind(3) + "ASTNode$DepGraphNode.trackedFlushes++;");
              //}
              stream.println(ind(2) + "}");
            } else {
              //stream.println(ind(2) + "if (" + attr.attributeSignature() + "_computed) {");
              stream.print(attr.resetVisit());
              stream.print(attr.resetCache());
              //if (grammar().incrementalTrack) {
              //  stream.println(ind(3) + "ASTNode$DepGraphNode.trackedFlushes++;");
              //}
              //stream.println(ind(2) + "}");
            }
          }
        }
        if (name().equals("ASTNode")) {
        } else {
          stream.println(ind(2) + "super.inc_flush();");
        }
        stream.println(ind + "}");        
      }
      // end method: inc_flush

      // methods: inc_flush_child
      if (grammar().incrementalLevelNode || grammar().incrementalLevelRegion) {
        if (name().equals("ASTNode")) {
        stream.println(ind + "public boolean ASTNode.inc_flush_child(ASTNode node) {");
        stream.println(ind(2) + "for (int i = 0; node.mayHaveRewrite() && i < children.length; i++) {");        
//        stream.println(ind(3) +   "if (children[i] == node && rewritten_children != null && " +
//                                      "i < rewritten_children.length && rewritten_children[i]) {");
        stream.println(ind(3) +    "if (children[i] == node) {");
        stream.println(ind(4) +     "return inc_restoreInitialForIndex(i, node.handler());");
        stream.println(ind(3) +   "}");
        stream.println(ind(2) + "}");
        stream.println(ind(2) + "return true;");
        stream.println(ind + "}"); 
        }
      }
      // end methods: inc_flush_child

      // methods: inc_flush_NTA
      if (grammar().incrementalLevelNode || grammar().incrementalLevelRegion) {
        stream.println(ind + "public boolean " + name() + ".inc_flush_NTA(ASTNode node) {");
        if (name().equals("List") || name().equals("Opt")) {

          if (name().equals("List")) {
            stream.println(ind(2) + "if (inc_internalNTAList) {");
            stream.println(ind(3) +   "state().enterConstruction();");
            stream.println(ind(3) +   "int childIndex = getIndexOfChild(node);");
            stream.println(ind(3) +   "removeChild(childIndex);");
            stream.println(ind(3) +   "node.inc_flush_subtree(node.handler());");
            stream.println(ind(3) +   "node.handler().clearDependencies();");
            stream.println(ind(3) +   "state().exitConstruction();");
            stream.println(ind(3) +   "if (inc_internalNTAList_map.containsValue(node)) {");
            stream.println(ind(4) +     "for (java.util.Iterator itr = inc_internalNTAList_map.keySet().iterator(); itr.hasNext();) {");
            stream.println(ind(5) +       "Object key = itr.next();");
            stream.println(ind(5) +       "if (inc_internalNTAList_map.get(key) == node) {");
            stream.println(ind(6) +         "inc_internalNTAList_map.remove(key);");
            stream.println(ind(6) +         "break;");
            stream.println(ind(5) +       "}");
            stream.println(ind(4) +     "}");
            stream.println(ind(3) +   "}");
            stream.println(ind(3) +   "return true;");
            stream.println(ind(2) + "}");
          }
          stream.println(ind(2) + "if (parent != null) {");
          stream.println(ind(3) +   "int index = parent.getIndexOfChild(this);");
          stream.println(ind(3) +   "if (index >= 0 && parent.childIsNTA(index)) {");
          stream.println(ind(4) +     "state().enterConstruction();");
          if (name().equals("List")) {
            stream.println(ind(4) +     "int childIndex = getIndexOfChild(node);");
            stream.println(ind(4) +     "removeChild(childIndex);");
          } else {
            stream.println(ind(4) +     "node.setParent(null);");
          }
          stream.println(ind(4) +     "node.inc_flush_subtree(node.handler());");
          stream.println(ind(4) +     "node.handler().clearDependencies();");
          stream.println(ind(4) +     "state().exitConstruction();");
          //if (grammar().incrementalTrack) {
          //  stream.println(ind(4) +     "ASTNode$DepGraphNode.trackedFlushes++;");
          //}
          stream.println(ind(4) +     "return true;");
          stream.println(ind(3) +   "}");
          stream.println(ind(3) +   "return false;");
          stream.println(ind(2) + "}");
        } else {
          for(Iterator itr = list.iterator(); itr.hasNext();) {
            AttrDecl attr = (AttrDecl)itr.next();
            // NTAs
            if ((attr.isNTA() || attr.getNTA()) && !attr.isPrimitive() 
                  && !(attr.type().equals("String") || attr.type().equals("java.lang.String"))) {
              if (attr.getNumParameter() > 0) {
/* Parameterized NTAs are kept in a List and will consequently ask its parent list if it should be flushed, see code above
                stream.println(ind(2) + "if (" + attr.attributeSignature() + "_list != null) {");
                stream.println(ind(3) +   "for (int index = 0; i < " + attr.attributeSignature() + "_list.numChildren; i++;) {");
                stream.println(ind(4) +     "ASTNode value = " + attr.attributeSignature() + "_list.children[index];");              
                stream.println(ind(4) +     "if (value == node) {");
                stream.println(ind(5) +       "state().enterConstruction();");
                stream.println(ind(5) +       attr.attributeSignature() + "_list.removeChild(index);");
                stream.println(ind(5) +       "state().exitConstruction();");
                stream.println(ind(5) +       attr.attributeSignature() + "_list.inc_flush_subtree(node.handler());");
                stream.println(ind(4) +     "node.handler().clearDependencies();");
                stream.print(attr.resetVisit());
                stream.print(attr.resetCache());
                if (grammar().incrementalTrack) {
                  stream.println(ind(5) + "ASTNode$DepGraphNode.trackedFlush++;");
                }
                stream.println(ind(5) +       "return true;");
                stream.println(ind(4) +     "}");
                stream.println(ind(3) +   "}");
                stream.println(ind(2) + "}");
*/
              } else {
                Components comp = attr.findCorrespondingNTA();
//                if (comp == null || !(comp instanceof OptionalComponentNTA || comp instanceof ListComponentsNTA)) {
                if (comp == null || comp instanceof OptionalComponentNTA || comp instanceof ListComponentsNTA) {
                  stream.println(ind(2) + "if (" + attr.attributeSignature() + "_value == node) {");
                  stream.println(ind(3) +   "state().enterConstruction();");
                  stream.println(ind(3) +   attr.attributeSignature() + "_value.setParent(null);");
                  stream.println(ind(3) +   "state().exitConstruction();");
                  stream.println(ind(3) +   attr.attributeSignature() + "_value.inc_flush_subtree(node.handler());");
                  stream.println(ind(4) +     "node.handler().clearDependencies();");
                  stream.print(attr.resetVisit());
                  stream.print(attr.resetCache());
                  //if (grammar().incrementalTrack) {
                  //  stream.println(ind(3) + "ASTNode$DepGraphNode.trackedFlushes++;");
                  //}
                  stream.println(ind(2) + "}");
                }
              }
            }
          }
        }
        stream.println(ind(2) + "return false;");
        stream.println(ind + "}"); 
      }
      // end methods: inc_flush_NTA

      // method: inc_flushRegionRoot
      if ((grammar().incrementalLevelRegion && (isRegionRoot() || name().equals("ASTNode"))) || 
            (grammar().incrementalLevelNode && name().equals("ASTNode"))) {
        stream.println(ind + "public boolean " + name() + ".inc_flushRegionRoot() {");
        if (grammar().incrementalLevelRegion) {
          // Check for rewrites
          stream.println(ind(2) + "// check for inner rewrite in region root");
          stream.println(ind(2) + "boolean rewriteFlushed = true;");
          stream.println(ind(2) + "if (parent != null) {");
          stream.println(ind(3) +   "rewriteFlushed = parent.inc_flush_child(this);");
          stream.println(ind(3) +   "// region root had an outer rewrite which was flushed (parent == null) -> done");
          stream.println(ind(3) +   "if (rewriteFlushed && parent == null) {");
          stream.println(ind(4) +     "return true;");
          stream.println(ind(3) +   "}");
          stream.println(ind(2) + "}");
          stream.println(ind(2) + "boolean innerRewrite = false;");
          stream.println(ind(2) + "if (rewriteFlushed) {");
          stream.println(ind(3) +   "// the region may have inner rewrites");
          stream.println(ind(3) +   "innerRewrite = inc_checkRegionForInnerRewrite();");
          stream.println(ind(2) + "} else {");
          stream.println(ind(3) +   "// region root had an inner rewrite which wasn't flushed");
          stream.println(ind(3) +   "innerRewrite = true;");
          stream.println(ind(2) + "}");
          stream.println(ind(2) + "// Inner rewrites in the region (including the root) means abort and notify the enclosing rewritten node");
          stream.println(ind(2) + "if (innerRewrite) {");
          stream.println(ind(3) +   "ASTNode enclosingNode = inc_locateEnclosingRewrittenNode();");
          stream.println(ind(3) +   "enclosingNode.handler().flushRegion();");
          stream.println(ind(3) +   "return false;");
          stream.println(ind(2) + "}");
          stream.println(ind(2) + "// Check NTAs, this may remove the region");
          stream.println(ind(2) + "boolean regionRemoved = false;");
          stream.println(ind(2) + "if (parent != null) {");
          stream.println(ind(3) +   "regionRemoved = parent.inc_flush_NTA(this);     // check NTA");
          stream.println(ind(2) + "}");
          stream.println(ind(2) + "// region is still here, flush remaining values and outer rewrites");
          stream.println(ind(2) + "if (!regionRemoved) {");
          stream.println(ind(3) +   "inc_flushRegion_rewrites();");
          stream.println(ind(3) +   "inc_flushRegion();");
          stream.println(ind(2) + "}");
          stream.println(ind(2) + "return true;"); 
          stream.println(ind + "}"); 
        }
        if (grammar().incrementalLevelNode) {
          stream.println(ind(2) + "inc_flush();");
          stream.println(ind(2) + "boolean rewriteFlushed = true;");
          stream.println(ind(2) + "if (parent != null) {");
          stream.println(ind(3) +   "rewriteFlushed = parent.inc_flush_child(this);");
          stream.println(ind(3) +   "// region root had an outer rewrite which was flushed (parent == null) -> done");
          stream.println(ind(3) +   "if (rewriteFlushed && parent == null) {");
          stream.println(ind(4) +     "return true;");
          stream.println(ind(3) +   "}");
          stream.println(ind(2) + "}");
          stream.println(ind(2) + "if (!rewriteFlushed) {");
          stream.println(ind(3) +   "ASTNode enclosingNode = inc_locateEnclosingRewrittenNode();");
          stream.println(ind(3) +   "enclosingNode.handler().flushRegion();");
          stream.println(ind(3) +   "return false;");
          stream.println(ind(2) + "}");
          stream.println(ind(2) + "if (parent != null) {");
          stream.println(ind(3) +   "parent.inc_flush_NTA(this);     // check NTA");
          stream.println(ind(2) + "}");
          stream.println(ind(2) + "return true;"); 
          stream.println(ind + "}"); 
        }
      }
      // end method: inc_flushRegionRoot

      // method: inc_checkRegionForInnerRewrite
      if (grammar().incrementalLevelRegion || grammar().incrementalLevelNode || grammar().incrementalLevelAttr) {
        if (name().equals("ASTNode")) {
          stream.println(ind + "public boolean ASTNode.inc_checkRegionForInnerRewrite() {");
          stream.println(ind(2) + "for (int i = 0; children != null && rewritten_children != null && " + 
                                            "i < children.length && i < rewritten_children.length; i++) {");
          stream.println(ind(3) +   "ASTNode child = children[i];");
          if (grammar().incrementalLevelRegion || grammar().incrementalLevelNode) {
          stream.println(ind(3) +   "if (child != null && !child.isRegionRoot()) {");
          } 
          if (grammar().incrementalLevelAttr) {
          stream.println(ind(3) +   "if (child != null) {");
          }
          stream.println(ind(4) +     "if (rewritten_children[i]) {");
          stream.println(ind(5) +       "if (init_children != null && i < init_children.length && init_children[i] == null) {");
          stream.println(ind(6) +         "return true;");
          stream.println(ind(5) +       "}");
          stream.println(ind(4) +     "}");
          if (grammar().incrementalLevelRegion || grammar().incrementalLevelNode) {
          stream.println(ind(4) +     "else {");
          stream.println(ind(5) +       "if (child.inc_checkRegionForInnerRewrite()) {");
          stream.println(ind(6) +         "return true;");
          stream.println(ind(5) +       "}");
          stream.println(ind(4) +     "}");
          }
          stream.println(ind(3) +   "}");
          stream.println(ind(2) + "}");
          stream.println(ind(2) + "return false;");
          stream.println(ind + "}");
        }
      }
      // end method: inc_checkRegionForInnerRewrite

      // method: inc_flushRegion
      if (grammar().incrementalLevelRegion) {
        stream.println(ind + "public void " + name() + ".inc_flushRegion() {");
        if (name().equals("ASTNode")) {
          stream.println(ind(2) + "inc_flush();");
          stream.println(ind(2) + "for (int i = 0; children != null && i < children.length; i++) {");
          stream.println(ind(3) +   "ASTNode child = children[i];");
          stream.println(ind(3) +   "if (child != null && !child.isRegionRoot()) {");
          stream.println(ind(4) +     "child.inc_flushRegion();");
          stream.println(ind(3) +   "}");
          stream.println(ind(2) + "}");
        } else {
          stream.println(ind(2) + "super.inc_flushRegion();");
        }
        // Flush NTAs if not region root
        for(Iterator itr = list.iterator(); itr.hasNext();) {
          AttrDecl attr = (AttrDecl)itr.next();
          // NTAs
          if ((attr.isNTA() || attr.getNTA()) && !attr.isPrimitive() 
                && !(attr.type().equals("String") || attr.type().equals("java.lang.String"))) {
            if (attr.getNumParameter() > 0) {
              stream.println(ind(2) + "if (" + attr.attributeSignature() + "_list != null) {");
              stream.println(ind(3) +   "for (int index = 0; index < " + attr.attributeSignature() + 
                                              "_list.numChildren; index++) {");
              stream.println(ind(4) +     "ASTNode value = " + attr.attributeSignature() + 
                                              "_list.children[index];");              
              stream.println(ind(4) +     "if (!value.isRegionRoot()) {");
              stream.println(ind(5) +       "state().enterConstruction();");
              stream.println(ind(5) +       attr.attributeSignature() + "_list.removeChild(index);");
              // removeChild will decrease the index of all remaining children and numChildren
              // hence, to visit the remainder of the list index need to be decreased by one for each removeChild
              stream.println(ind(5) +       "index--;"); 
              stream.println(ind(5) +       "state().exitConstruction();");
              stream.println(ind(5) +       "value.inc_flush_subtree(handler());");
              // remove the value in the NTA values map
              stream.println(ind(5) +       "for (java.util.Iterator itr = " + attr.attributeSignature() + "_values.keySet().iterator(); itr.hasNext();) {");
              stream.println(ind(6) +         "Object key = itr.next();");
              stream.println(ind(6) +         "if (" + attr.attributeSignature() + "_values.get(key) == value) {");
              stream.println(ind(7) +           attr.attributeSignature() + "_values.remove(key);");
              stream.println(ind(7) +           "break;");
              stream.println(ind(6) +         "}");
              stream.println(ind(5) +       "}");
//              stream.print(attr.resetVisit());
//              stream.print(attr.resetCache());
              //if (grammar().incrementalTrack) {
              //  stream.println(ind(3) + "ASTNode$DepGraphNode.trackedFlushes++;");
              //}
              //stream.println(ind(5) +       "return true;");
              stream.println(ind(4) +     "}");
              stream.println(ind(3) +   "}");
              stream.println(ind(2) + "}");
            } else {
              Components comp = attr.findCorrespondingNTA();
//              if (comp == null || !(comp instanceof OptionalComponentNTA || comp instanceof ListComponentsNTA)) {
              if (comp == null || comp instanceof OptionalComponentNTA || comp instanceof ListComponentsNTA) {
                stream.println(ind(2) + "if (" + attr.attributeSignature() + "_value != null && !" + 
                                                  attr.attributeSignature() + "_value.isRegionRoot()) {");
                stream.println(ind(3) +   "state().enterConstruction();");
                stream.println(ind(3) +   attr.attributeSignature() + "_value.setParent(null);");
                stream.println(ind(3) +   "state().exitConstruction();");
                stream.println(ind(3) +   attr.attributeSignature() + "_value.inc_flush_subtree(handler());");
                stream.print(attr.resetVisit());
                stream.print(attr.resetCache());
                //if (grammar().incrementalTrack) {
                //  stream.println(ind(3) + "ASTNode$DepGraphNode.trackedFlushes++;");
                //}
                stream.println(ind(2) + "}");
              }
            }
          }
        }
        stream.println(ind + "}"); 
      }
      // end method: inc_flushRegion

      // method: inc_flushRegion_rewrites
      if (grammar().incrementalLevelRegion || grammar().incrementalLevelAttr) {
        if (name().equals("ASTNode")) {
          stream.println(ind + "public boolean ASTNode.inc_flushRegion_rewrites() {");
          stream.println(ind(2) + "for (int i = 0; children != null && i < children.length; i++) {"); 
          stream.println(ind(3) +   "ASTNode child = children[i];");
          if (grammar().incrementalLevelRegion) {
            stream.println(ind(3) +   "if (child == null || child.isRegionRoot()) continue;");
            stream.println(ind(3) +   "// rewritten child");

            stream.println(ind(3) +   "if (rewritten_children != null && i < rewritten_children.length && " +
                                         "rewritten_children[i]) {");
            stream.println(ind(4) +     "if (!inc_restoreInitialForIndex(i, handler())) {");
            stream.println(ind(5) +       "return false;");
            stream.println(ind(4) +     "}");
            stream.println(ind(3) +   "}");
            stream.println(ind(3) +   "// not rewritten child");
            stream.println(ind(3) +   "else {");
            stream.println(ind(4) +     "if (!child.inc_flushRegion_rewrites()) {");
            stream.println(ind(5) +       "return false;");
            stream.println(ind(4) +     "}");
            stream.println(ind(3) +   "}");
          }
          if (grammar().incrementalLevelAttr) {
            stream.println(ind(3) +   "if (child == null) continue;");
            stream.println(ind(3) +   "// rewritten child");
            stream.println(ind(3) +   "if (rewritten_children != null && i < rewritten_children.length && " +
                                         "rewritten_children[i]) {");
            stream.println(ind(4) +     "if (!inc_restoreInitialForIndex(i, getChild_handler)) {");
            stream.println(ind(5) +       "return false;");
            stream.println(ind(4) +     "}");
            stream.println(ind(3) +   "}");
          }
          stream.println(ind(2) + "}"); 
          stream.println(ind(2) + "return true;");
          stream.println(ind + "}"); 
        }
      }      
      // end method: inc_flushRegion_rewrites

      // method: inc_flush_subtree
      if (grammar().incrementalLevelRegion || grammar().incrementalLevelNode || 
          grammar().incrementalLevelAttr || grammar().incrementalLevelParam) {
        stream.println(ind + "protected void " + name() + ".inc_flush_subtree(ASTNode$DepGraphNode h) {");
        stream.println(ind(2) + "inc_state = inc_GARBAGE;");
        // NTAs
        for(Iterator itr = list.iterator(); itr.hasNext();) {
          AttrDecl attr = (AttrDecl)itr.next(); 
          if ((attr.isNTA() || attr.getNTA()) && !attr.isPrimitive() 
              && !(attr.type().equals("String") || attr.type().equals("java.lang.String"))) {

            if (attr.getNumParameter() > 0) {
              stream.println(ind(2) + "if (" + attr.attributeSignature() + "_list != null) {");
              stream.println(ind(3) +   attr.attributeSignature() + "_list.inc_flush_subtree(h);");
              stream.println(ind(2) + "}");
            } else {
              Components comp = attr.findCorrespondingNTA();
              if (comp == null || !(comp instanceof OptionalComponentNTA || comp instanceof ListComponentsNTA)) {
                stream.println(ind(2) + "if (" + attr.attributeSignature() + "_value != null) {");
                stream.println(ind(3) +   attr.attributeSignature() + "_value.inc_flush_subtree(h);");
                stream.println(ind(2) + "}");
              }
            }
          }
        }
        // attributes and tokens
        if (grammar().incrementalLevelAttr) {
          for(Iterator itr = list.iterator(); itr.hasNext();) {
            AttrDecl attr = (AttrDecl)itr.next();
            stream.println(ind(2) + "h.transferSetsFrom(" + attr.attributeSignature() + "_handler);");
          }
          for (int c = 0; c < getNumComponents(); c++) {
             Components comp = getComponents(c);
             if (comp instanceof TokenComponent) {
              stream.println(ind(2) + "h.transferSetsFrom(get" + ((TokenComponent)comp).getTokenId().getID() + "_handler);");
             }
           }
        }
        if (grammar().incrementalLevelParam) {
          for(Iterator itr = list.iterator(); itr.hasNext();) {
            AttrDecl attr = (AttrDecl)itr.next();
            if (attr.getNumParameter() > 0) {
              stream.println(ind(2) + "if (" + attr.attributeSignature() + "_handler != null) {");
              stream.println(ind(3) +   "for (java.util.Iterator itr = " + attr.attributeSignature() + 
                                              "_handler.values().iterator(); itr.hasNext();) {");
              stream.println(ind(4) +     "h.transferSetsFrom((ASTNode$DepGraphNode)itr.next());");
              stream.println(ind(3) +   "}");
              stream.println(ind(2) + "}");
            } else {
              stream.println(ind(2) + "h.transferSetsFrom(" + attr.attributeSignature() + "_handler);");
            }
          }
          for (int c = 0; c < getNumComponents(); c++) {
             Components comp = getComponents(c);
             if (comp instanceof TokenComponent) {
              stream.println(ind(2) + "h.transferSetsFrom(get" + ((TokenComponent)comp).getTokenId().getID() + "_handler);");
             }
           }
        }

        if (name().equals("ASTNode")) {    
          stream.println(ind(2) + "// flush subtree of values, take sets from encountered handler and remove it from DDG");
          if (grammar().incrementalLevelRegion) {
            stream.println(ind(2) + "if (isRegionRoot()) {");
            stream.println(ind(3) +   "h.transferSetsFrom(handler());");
            stream.println(ind(2) + "}");
            stream.println(ind(2) + "inc_flush();");
          }
          if (grammar().incrementalLevelNode) {
            stream.println(ind(2) + "h.transferSetsFrom(handler());");
            stream.println(ind(2) + "inc_flush();");
          }
          if (grammar().incrementalLevelAttr) {
            stream.println(ind(3) +   "h.transferSetsFrom(getParent_handler);");
            stream.println(ind(3) +   "h.transferSetsFrom(getChild_handler);");
            stream.println(ind(3) +   "h.transferSetsFrom(numChildren_handler);");
          }
          if (grammar().incrementalLevelParam) {
            stream.println(ind(3) +   "h.transferSetsFrom(getParent_handler);");
            stream.println(ind(3) +   "h.transferSetsFrom(numChildren_handler);");
            stream.println(ind(3) +   "for (int i = 0; getChild_handler != null && i < getChild_handler.length; i++) {");
            stream.println(ind(4) +     "h.transferSetsFrom(getChild_handler[i]);");
            stream.println(ind(3) +   "}");
          }
          stream.println(ind(2) + "for (int i = 0; children != null && i < children.length; i++) {");
          stream.println(ind(3) +   "ASTNode child = children[i];");
          stream.println(ind(3) +   "if (child != null) {");
          stream.println(ind(4) +     "child.inc_flush_subtree(h);");
          stream.println(ind(3) +   "}");
          stream.println(ind(2) + "}");
        } else {
          stream.println(ind(2) + "super.inc_flush_subtree(h);");
        }
        stream.println(ind + "}"); 
      }
      // end method: inc_flush_subtree
    }
  }


  public void ASTDecl.jjtGenIncrementalReactToASTChange(PrintWriter stream) {
    if (!grammar().incremental) return; 
    /*
    if (grammar().incrementalDebug) {

      // method: inc_clearDepsInTree
      stream.println(ind + "public void " + name() + ".inc_clearDepsInTree() {");
      if (name().equals("ASTNode")) {
        if (grammar().incrementalLevelParam) {
        stream.println(ind(2) + "getParent_handler.clearDependants();");
        stream.println(ind(2) + "numChildren_handler.clearDependants();");
        stream.println(ind(2) + "for (int i = 0; i < numChildren; i++) {");
        stream.println(ind(3) +   "if (!childIsNTA(i) && getChild_handler[i].hasDependants()) {");
        stream.println(ind(4) +     "getChildNoTransform(i).inc_clearDepsInTree();");
        stream.println(ind(4) +     "getChild_handler[i].clearDependants();");
        stream.println(ind(3) +   "}");
        stream.println(ind(2) + "}");
        }
        if (grammar().incrementalLevelAttr) {
        stream.println(ind(2) + "getParent_handler.clearDependants();");
        stream.println(ind(2) + "numChildren_handler.clearDependants();");
        stream.println(ind(2) + "if (getChild_handler.hasDependants()) {");
        stream.println(ind(3) +   "getChild_handler.clearDependants();");
        stream.println(ind(3) +   "for (int i = 0; i < getNumChildNoTransform(); i++) {");
        stream.println(ind(4) +     "getChildNoTransform(i).inc_clearDepsInTree();");
        stream.println(ind(3) +   "}");
        stream.println(ind(2) + "}");
        }
        if (grammar().incrementalLevelNode) {
        stream.println(ind(2) + "handler.clearDependants();");
        stream.println(ind(2) + "for (int i = 0; i < getNumChildNoTransform(); i++) {");
        stream.println(ind(3) +   "getChildNoTransform(i).inc_clearDepsInTree();");
        stream.println(ind(2) + "}");
        }
      } else {
        stream.println(ind(2) + "super.inc_clearDepsInTree();");
        if (grammar().incrementalLevelParam || grammar().incrementalLevelAttr) {
        // tokens
        for (int c = 0; c < getNumComponents(); c++) {
           Components comp = getComponents(c);
           if (!(comp instanceof TokenComponent)) continue;
          stream.println(ind(2) + "if (get" + ((TokenComponent)comp).getTokenId().getID() + "_handler != null) {");
          stream.println(ind(3) +   "get" + ((TokenComponent)comp).getTokenId().getID() + "_handler.clearDependants();");
           stream.println(ind(2) + "}");
        }
        }
        // collect attributes: syn then inh
        ArrayList list = new ArrayList();
        for(int k = 0; k < getNumSynEq(); k++) {
          AttrDecl attr = getSynEq(k).decl();
          if (attr != null && (attr.getLazy() || attr.isCircular())) 
            list.add(attr);
        }
        for(int k = 0; k < getNumInhDecl(); k++) {
          AttrDecl attr = getInhDecl(k);
          if (attr != null && (attr.getLazy() || attr.isCircular())) 
            list.add(attr);
        }
        // attributes
        for(Iterator itr = list.iterator(); itr.hasNext();) {
          AttrDecl attr = (AttrDecl)itr.next();
          if (grammar().incrementalLevelParam) {
            if (attr.getNumParameter() > 0) {
            stream.println(ind(2) + "for (java.util.Iterator itr = " + attr.attributeSignature() + 
                                    "_handler.values().iterator(); itr.hasNext();) {");
            stream.println(ind(3) +   "ASTNode$DepGraphNode handler = (ASTNode$DepGraphNode)itr.next();");
            stream.println(ind(3) +   "handler.clearDependants();");
            stream.println(ind(2) + "}");
            } else {
            stream.println(ind(2) + "if (" + attr.attributeSignature() + "_handler != null) {");
            stream.println(ind(3) +   attr.attributeSignature() + "_handler.clearDependants();");
            stream.println(ind(2) + "}");
            }
          }
          if (grammar().incrementalLevelAttr) {
            stream.println(ind(2) + "if (" + attr.attributeSignature() + "_handler != null) {");
            stream.println(ind(3) +   attr.attributeSignature() + "_handler.clearDependants();");
             stream.println(ind(2) + "}");
          }
        }    
      stream.println(ind + "}");  // end method: inc_clearDepsInTree
    }
    */

    // method: inc_notifyForRemove
    if (name().equals("ASTNode")) {  
      stream.println(ind + "public void ASTNode.inc_notifyForRemove() {");
      if (grammar().incrementalLevelParam || grammar().incrementalLevelAttr) {
        stream.println(ind(2) + "getParent_handler.notifyDependencies();");
      }
      if (grammar().incrementalLevelNode) {
        stream.println(ind(2) + "handler.flushRegion();");
      }
      if (grammar().incrementalLevelRegion) {
        stream.println(ind(2) + "handler().flushRegion();");
      }
      stream.println(ind + "}"); 
    } 
    // end method: inc_notifyForRemove
  }
 
 }
