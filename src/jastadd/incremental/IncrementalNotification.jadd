/* Copyright (c) 2011-2013, Emma SÃ¶derberg <emma.soderberg@cs.lth.se>
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Lund University nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
 aspect IncrementalNotification {
 
  public void ASTDecl.genIncrementalNotification(PrintWriter stream) {
    if (!grammar().incremental) return; 
    
    TemplateContext tt = templateContext();
    
    tt.bind("AttrAffectedChecks", emitAttrAffectedChecksString());
    tt.expand("ASTDecl.incValueAffectedMethod", stream);
    
    tt.bind("IsAstNode", name().equals("ASTNode"));
    tt.bind("AttrFlushChecks", emitAttrFlushChecksString());
    tt.expand("ASTDecl.incReactToDepChangeMethod", stream);
    
    // method: inc_flush
    if (grammar().incrementalChangeFlush) {

      // start method: inc_flush
      if (grammar().incrementalLevelNode || grammar().incrementalLevelRegion) {
        stream.println(ind + "public void " + name() + ".inc_flush() {");
        // flush attributes
        for(Iterator itr = listOfCachedAttributes().iterator(); itr.hasNext();) {
          AttrDecl attr = (AttrDecl)itr.next();
          // NTAs
          if ((attr.isNTA() || attr.getNTA()) && !attr.isPrimitive() 
              && !(attr.type().equals("String") || attr.type().equals("java.lang.String"))) {

            if (grammar().incrementalLevelRegion) {
              // TODO: Add a flush of non-region root NTA children
            }
          } 
          // Non NTAs
          else {
            if (attr.getNumParameter() > 0) {
              stream.println(ind(2) + "if (" + attr.attributeSignature() + "_values != null && !" + 
                attr.attributeSignature() + "_values.isEmpty()) {");
              stream.print(attr.resetVisit());
              stream.print(attr.resetCache());
              stream.println(ind(2) + "}");
            } else {
              stream.print(attr.resetVisit());
              stream.print(attr.resetCache());
            }
          }
        }
        if (name().equals("ASTNode")) {
        } else {
          stream.println(ind(2) + "super.inc_flush();");
        }
        stream.println(ind + "}");        
      }
      // end method: inc_flush

      // methods: inc_flush_child
      if (grammar().incrementalLevelNode || grammar().incrementalLevelRegion) {
        if (name().equals("ASTNode")) {
        stream.println(ind + "public boolean ASTNode.inc_flush_child(ASTNode node) {");
        stream.println(ind(2) + "for (int i = 0; node.mayHaveRewrite() && i < children.length; i++) {");        
//        stream.println(ind(3) +   "if (children[i] == node && rewritten_children != null && " +
//                                      "i < rewritten_children.length && rewritten_children[i]) {");
        stream.println(ind(3) +    "if (children[i] == node) {");
        stream.println(ind(4) +     "return inc_restoreInitialForIndex(i, node.handler());");
        stream.println(ind(3) +   "}");
        stream.println(ind(2) + "}");
        stream.println(ind(2) + "return true;");
        stream.println(ind + "}"); 
        }
      }
      // end methods: inc_flush_child

      // methods: inc_flush_NTA
      if (grammar().incrementalLevelNode || grammar().incrementalLevelRegion) {
        stream.println(ind + "public boolean " + name() + ".inc_flush_NTA(ASTNode node) {");
        if (name().equals("List") || name().equals("Opt")) {

          if (name().equals("List")) {
            stream.println(ind(2) + "if (inc_internalNTAList) {");
            stream.println(ind(3) +   "state().enterConstruction();");
            stream.println(ind(3) +   "int childIndex = getIndexOfChild(node);");
            stream.println(ind(3) +   "removeChild(childIndex);");
            stream.println(ind(3) +   "node.inc_flush_subtree(node.handler());");
            stream.println(ind(3) +   "node.handler().clearDependencies();");
            stream.println(ind(3) +   "state().exitConstruction();");
            stream.println(ind(3) +   "if (inc_internalNTAList_map.containsValue(node)) {");
            stream.println(ind(4) +     "for (java.util.Iterator itr = inc_internalNTAList_map.keySet().iterator(); itr.hasNext();) {");
            stream.println(ind(5) +       "Object key = itr.next();");
            stream.println(ind(5) +       "if (inc_internalNTAList_map.get(key) == node) {");
            stream.println(ind(6) +         "inc_internalNTAList_map.remove(key);");
            stream.println(ind(6) +         "break;");
            stream.println(ind(5) +       "}");
            stream.println(ind(4) +     "}");
            stream.println(ind(3) +   "}");
            stream.println(ind(3) +   "return true;");
            stream.println(ind(2) + "}");
          }
          stream.println(ind(2) + "if (parent != null) {");
          stream.println(ind(3) +   "int index = parent.getIndexOfChild(this);");
          stream.println(ind(3) +   "if (index >= 0 && parent.childIsNTA(index)) {");
          stream.println(ind(4) +     "state().enterConstruction();");
          if (name().equals("List")) {
            stream.println(ind(4) +     "int childIndex = getIndexOfChild(node);");
            stream.println(ind(4) +     "removeChild(childIndex);");
          } else {
            stream.println(ind(4) +     "node.setParent(null);");
          }
          stream.println(ind(4) +     "node.inc_flush_subtree(node.handler());");
          stream.println(ind(4) +     "node.handler().clearDependencies();");
          stream.println(ind(4) +     "state().exitConstruction();");
          //if (grammar().incrementalTrack) {
          //  stream.println(ind(4) +     "ASTNode$DepGraphNode.trackedFlushes++;");
          //}
          stream.println(ind(4) +     "return true;");
          stream.println(ind(3) +   "}");
          stream.println(ind(3) +   "return false;");
          stream.println(ind(2) + "}");
        } else {
          for(Iterator itr = listOfCachedAttributes().iterator(); itr.hasNext();) {
            AttrDecl attr = (AttrDecl)itr.next();
            // NTAs
            if ((attr.isNTA() || attr.getNTA()) && !attr.isPrimitive() 
                  && !(attr.type().equals("String") || attr.type().equals("java.lang.String"))) {
              if (attr.getNumParameter() > 0) {
/* Parameterized NTAs are kept in a List and will consequently ask its parent list if it should be flushed, see code above
                stream.println(ind(2) + "if (" + attr.attributeSignature() + "_list != null) {");
                stream.println(ind(3) +   "for (int index = 0; i < " + attr.attributeSignature() + "_list.numChildren; i++;) {");
                stream.println(ind(4) +     "ASTNode value = " + attr.attributeSignature() + "_list.children[index];");              
                stream.println(ind(4) +     "if (value == node) {");
                stream.println(ind(5) +       "state().enterConstruction();");
                stream.println(ind(5) +       attr.attributeSignature() + "_list.removeChild(index);");
                stream.println(ind(5) +       "state().exitConstruction();");
                stream.println(ind(5) +       attr.attributeSignature() + "_list.inc_flush_subtree(node.handler());");
                stream.println(ind(4) +     "node.handler().clearDependencies();");
                stream.print(attr.resetVisit());
                stream.print(attr.resetCache());
                if (grammar().incrementalTrack) {
                  stream.println(ind(5) + "ASTNode$DepGraphNode.trackedFlush++;");
                }
                stream.println(ind(5) +       "return true;");
                stream.println(ind(4) +     "}");
                stream.println(ind(3) +   "}");
                stream.println(ind(2) + "}");
*/
              } else {
                Components comp = attr.findCorrespondingNTA();
//                if (comp == null || !(comp instanceof OptionalComponentNTA || comp instanceof ListComponentsNTA)) {
                if (comp == null || comp instanceof OptionalComponentNTA || comp instanceof ListComponentsNTA) {
                  stream.println(ind(2) + "if (" + attr.attributeSignature() + "_value == node) {");
                  stream.println(ind(3) +   "state().enterConstruction();");
                  stream.println(ind(3) +   attr.attributeSignature() + "_value.setParent(null);");
                  stream.println(ind(3) +   "state().exitConstruction();");
                  stream.println(ind(3) +   attr.attributeSignature() + "_value.inc_flush_subtree(node.handler());");
                  stream.println(ind(4) +     "node.handler().clearDependencies();");
                  stream.print(attr.resetVisit());
                  stream.print(attr.resetCache());
                  //if (grammar().incrementalTrack) {
                  //  stream.println(ind(3) + "ASTNode$DepGraphNode.trackedFlushes++;");
                  //}
                  stream.println(ind(2) + "}");
                }
              }
            }
          }
        }
        stream.println(ind(2) + "return false;");
        stream.println(ind + "}"); 
      }
      // end methods: inc_flush_NTA

      // method: inc_flushRegionRoot
      if ((grammar().incrementalLevelRegion && (isRegionRoot() || name().equals("ASTNode"))) || 
            (grammar().incrementalLevelNode && name().equals("ASTNode"))) {
        stream.println(ind + "public boolean " + name() + ".inc_flushRegionRoot() {");
        if (grammar().incrementalLevelRegion) {
          // Check for rewrites
          stream.println(ind(2) + "// check for inner rewrite in region root");
          stream.println(ind(2) + "boolean rewriteFlushed = true;");
          stream.println(ind(2) + "if (parent != null) {");
          stream.println(ind(3) +   "rewriteFlushed = parent.inc_flush_child(this);");
          stream.println(ind(3) +   "// region root had an outer rewrite which was flushed (parent == null) -> done");
          stream.println(ind(3) +   "if (rewriteFlushed && parent == null) {");
          stream.println(ind(4) +     "return true;");
          stream.println(ind(3) +   "}");
          stream.println(ind(2) + "}");
          stream.println(ind(2) + "boolean innerRewrite = false;");
          stream.println(ind(2) + "if (rewriteFlushed) {");
          stream.println(ind(3) +   "// the region may have inner rewrites");
          stream.println(ind(3) +   "innerRewrite = inc_checkRegionForInnerRewrite();");
          stream.println(ind(2) + "} else {");
          stream.println(ind(3) +   "// region root had an inner rewrite which wasn't flushed");
          stream.println(ind(3) +   "innerRewrite = true;");
          stream.println(ind(2) + "}");
          stream.println(ind(2) + "// Inner rewrites in the region (including the root) means abort and notify the enclosing rewritten node");
          stream.println(ind(2) + "if (innerRewrite) {");
          stream.println(ind(3) +   "ASTNode enclosingNode = inc_locateEnclosingRewrittenNode();");
          stream.println(ind(3) +   "enclosingNode.handler().flushRegion();");
          stream.println(ind(3) +   "return false;");
          stream.println(ind(2) + "}");
          stream.println(ind(2) + "// Check NTAs, this may remove the region");
          stream.println(ind(2) + "boolean regionRemoved = false;");
          stream.println(ind(2) + "if (parent != null) {");
          stream.println(ind(3) +   "regionRemoved = parent.inc_flush_NTA(this);     // check NTA");
          stream.println(ind(2) + "}");
          stream.println(ind(2) + "// region is still here, flush remaining values and outer rewrites");
          stream.println(ind(2) + "if (!regionRemoved) {");
          stream.println(ind(3) +   "inc_flushRegion_rewrites();");
          stream.println(ind(3) +   "inc_flushRegion();");
          stream.println(ind(2) + "}");
          stream.println(ind(2) + "return true;"); 
          stream.println(ind + "}"); 
        }
        if (grammar().incrementalLevelNode) {
          stream.println(ind(2) + "inc_flush();");
          stream.println(ind(2) + "boolean rewriteFlushed = true;");
          stream.println(ind(2) + "if (parent != null) {");
          stream.println(ind(3) +   "rewriteFlushed = parent.inc_flush_child(this);");
          stream.println(ind(3) +   "// region root had an outer rewrite which was flushed (parent == null) -> done");
          stream.println(ind(3) +   "if (rewriteFlushed && parent == null) {");
          stream.println(ind(4) +     "return true;");
          stream.println(ind(3) +   "}");
          stream.println(ind(2) + "}");
          stream.println(ind(2) + "if (!rewriteFlushed) {");
          stream.println(ind(3) +   "ASTNode enclosingNode = inc_locateEnclosingRewrittenNode();");
          stream.println(ind(3) +   "enclosingNode.handler().flushRegion();");
          stream.println(ind(3) +   "return false;");
          stream.println(ind(2) + "}");
          stream.println(ind(2) + "if (parent != null) {");
          stream.println(ind(3) +   "parent.inc_flush_NTA(this);     // check NTA");
          stream.println(ind(2) + "}");
          stream.println(ind(2) + "return true;"); 
          stream.println(ind + "}"); 
        }
      }
      // end method: inc_flushRegionRoot

      // method: inc_checkRegionForInnerRewrite
      if (grammar().incrementalLevelRegion || grammar().incrementalLevelNode || grammar().incrementalLevelAttr) {
        if (name().equals("ASTNode")) {
          stream.println(ind + "public boolean ASTNode.inc_checkRegionForInnerRewrite() {");
          stream.println(ind(2) + "for (int i = 0; children != null && rewritten_children != null && " + 
                                            "i < children.length && i < rewritten_children.length; i++) {");
          stream.println(ind(3) +   "ASTNode child = children[i];");
          if (grammar().incrementalLevelRegion || grammar().incrementalLevelNode) {
          stream.println(ind(3) +   "if (child != null && !child.isRegionRoot()) {");
          } 
          if (grammar().incrementalLevelAttr) {
          stream.println(ind(3) +   "if (child != null) {");
          }
          stream.println(ind(4) +     "if (rewritten_children[i]) {");
          stream.println(ind(5) +       "if (init_children != null && i < init_children.length && init_children[i] == null) {");
          stream.println(ind(6) +         "return true;");
          stream.println(ind(5) +       "}");
          stream.println(ind(4) +     "}");
          if (grammar().incrementalLevelRegion || grammar().incrementalLevelNode) {
          stream.println(ind(4) +     "else {");
          stream.println(ind(5) +       "if (child.inc_checkRegionForInnerRewrite()) {");
          stream.println(ind(6) +         "return true;");
          stream.println(ind(5) +       "}");
          stream.println(ind(4) +     "}");
          }
          stream.println(ind(3) +   "}");
          stream.println(ind(2) + "}");
          stream.println(ind(2) + "return false;");
          stream.println(ind + "}");
        }
      }
      // end method: inc_checkRegionForInnerRewrite

      // method: inc_flushRegion
      if (grammar().incrementalLevelRegion) {
        stream.println(ind + "public void " + name() + ".inc_flushRegion() {");
        if (name().equals("ASTNode")) {
          stream.println(ind(2) + "inc_flush();");
          stream.println(ind(2) + "for (int i = 0; children != null && i < children.length; i++) {");
          stream.println(ind(3) +   "ASTNode child = children[i];");
          stream.println(ind(3) +   "if (child != null && !child.isRegionRoot()) {");
          stream.println(ind(4) +     "child.inc_flushRegion();");
          stream.println(ind(3) +   "}");
          stream.println(ind(2) + "}");
        } else {
          stream.println(ind(2) + "super.inc_flushRegion();");
        }
        // Flush NTAs if not region root
        for(Iterator itr = listOfCachedAttributes().iterator(); itr.hasNext();) {
          AttrDecl attr = (AttrDecl)itr.next();
          // NTAs
          if ((attr.isNTA() || attr.getNTA()) && !attr.isPrimitive() 
                && !(attr.type().equals("String") || attr.type().equals("java.lang.String"))) {
            if (attr.getNumParameter() > 0) {
              stream.println(ind(2) + "if (" + attr.attributeSignature() + "_list != null) {");
              stream.println(ind(3) +   "for (int index = 0; index < " + attr.attributeSignature() + 
                                              "_list.numChildren; index++) {");
              stream.println(ind(4) +     "ASTNode value = " + attr.attributeSignature() + 
                                              "_list.children[index];");              
              stream.println(ind(4) +     "if (!value.isRegionRoot()) {");
              stream.println(ind(5) +       "state().enterConstruction();");
              stream.println(ind(5) +       attr.attributeSignature() + "_list.removeChild(index);");
              // removeChild will decrease the index of all remaining children and numChildren
              // hence, to visit the remainder of the list index need to be decreased by one for each removeChild
              stream.println(ind(5) +       "index--;"); 
              stream.println(ind(5) +       "state().exitConstruction();");
              stream.println(ind(5) +       "value.inc_flush_subtree(handler());");
              // remove the value in the NTA values map
              stream.println(ind(5) +       "for (java.util.Iterator itr = " + attr.attributeSignature() + "_values.keySet().iterator(); itr.hasNext();) {");
              stream.println(ind(6) +         "Object key = itr.next();");
              stream.println(ind(6) +         "if (" + attr.attributeSignature() + "_values.get(key) == value) {");
              stream.println(ind(7) +           attr.attributeSignature() + "_values.remove(key);");
              stream.println(ind(7) +           "break;");
              stream.println(ind(6) +         "}");
              stream.println(ind(5) +       "}");
//              stream.print(attr.resetVisit());
//              stream.print(attr.resetCache());
              //if (grammar().incrementalTrack) {
              //  stream.println(ind(3) + "ASTNode$DepGraphNode.trackedFlushes++;");
              //}
              //stream.println(ind(5) +       "return true;");
              stream.println(ind(4) +     "}");
              stream.println(ind(3) +   "}");
              stream.println(ind(2) + "}");
            } else {
              Components comp = attr.findCorrespondingNTA();
//              if (comp == null || !(comp instanceof OptionalComponentNTA || comp instanceof ListComponentsNTA)) {
              if (comp == null || comp instanceof OptionalComponentNTA || comp instanceof ListComponentsNTA) {
                stream.println(ind(2) + "if (" + attr.attributeSignature() + "_value != null && !" + 
                                                  attr.attributeSignature() + "_value.isRegionRoot()) {");
                stream.println(ind(3) +   "state().enterConstruction();");
                stream.println(ind(3) +   attr.attributeSignature() + "_value.setParent(null);");
                stream.println(ind(3) +   "state().exitConstruction();");
                stream.println(ind(3) +   attr.attributeSignature() + "_value.inc_flush_subtree(handler());");
                stream.print(attr.resetVisit());
                stream.print(attr.resetCache());
                //if (grammar().incrementalTrack) {
                //  stream.println(ind(3) + "ASTNode$DepGraphNode.trackedFlushes++;");
                //}
                stream.println(ind(2) + "}");
              }
            }
          }
        }
        stream.println(ind + "}"); 
      }
      // end method: inc_flushRegion

      // method: inc_flushRegion_rewrites
      if (grammar().incrementalLevelRegion || grammar().incrementalLevelAttr) {
        if (name().equals("ASTNode")) {
          stream.println(ind + "public boolean ASTNode.inc_flushRegion_rewrites() {");
          stream.println(ind(2) + "for (int i = 0; children != null && i < children.length; i++) {"); 
          stream.println(ind(3) +   "ASTNode child = children[i];");
          if (grammar().incrementalLevelRegion) {
            stream.println(ind(3) +   "if (child == null || child.isRegionRoot()) continue;");
            stream.println(ind(3) +   "// rewritten child");

            stream.println(ind(3) +   "if (rewritten_children != null && i < rewritten_children.length && " +
                                         "rewritten_children[i]) {");
            stream.println(ind(4) +     "if (!inc_restoreInitialForIndex(i, handler())) {");
            stream.println(ind(5) +       "return false;");
            stream.println(ind(4) +     "}");
            stream.println(ind(3) +   "}");
            stream.println(ind(3) +   "// not rewritten child");
            stream.println(ind(3) +   "else {");
            stream.println(ind(4) +     "if (!child.inc_flushRegion_rewrites()) {");
            stream.println(ind(5) +       "return false;");
            stream.println(ind(4) +     "}");
            stream.println(ind(3) +   "}");
          }
          if (grammar().incrementalLevelAttr) {
            stream.println(ind(3) +   "if (child == null) continue;");
            stream.println(ind(3) +   "// rewritten child");
            stream.println(ind(3) +   "if (rewritten_children != null && i < rewritten_children.length && " +
                                         "rewritten_children[i]) {");
            stream.println(ind(4) +     "if (!inc_restoreInitialForIndex(i, getChild_handler)) {");
            stream.println(ind(5) +       "return false;");
            stream.println(ind(4) +     "}");
            stream.println(ind(3) +   "}");
          }
          stream.println(ind(2) + "}"); 
          stream.println(ind(2) + "return true;");
          stream.println(ind + "}"); 
        }
      }      
      // end method: inc_flushRegion_rewrites

      // method: inc_flush_subtree
      if (grammar().incrementalLevelRegion || grammar().incrementalLevelNode || 
          grammar().incrementalLevelAttr || grammar().incrementalLevelParam) {
        stream.println(ind + "protected void " + name() + ".inc_flush_subtree(ASTNode$DepGraphNode h) {");
        stream.println(ind(2) + "inc_state = inc_GARBAGE;");
        // NTAs
        for(Iterator itr = listOfCachedAttributes().iterator(); itr.hasNext();) {
          AttrDecl attr = (AttrDecl)itr.next(); 
          if ((attr.isNTA() || attr.getNTA()) && !attr.isPrimitive() 
              && !(attr.type().equals("String") || attr.type().equals("java.lang.String"))) {

            if (attr.getNumParameter() > 0) {
              stream.println(ind(2) + "if (" + attr.attributeSignature() + "_list != null) {");
              stream.println(ind(3) +   attr.attributeSignature() + "_list.inc_flush_subtree(h);");
              stream.println(ind(2) + "}");
            } else {
              Components comp = attr.findCorrespondingNTA();
              if (comp == null || !(comp instanceof OptionalComponentNTA || comp instanceof ListComponentsNTA)) {
                stream.println(ind(2) + "if (" + attr.attributeSignature() + "_value != null) {");
                stream.println(ind(3) +   attr.attributeSignature() + "_value.inc_flush_subtree(h);");
                stream.println(ind(2) + "}");
              }
            }
          }
        }
        // attributes and tokens
        if (grammar().incrementalLevelAttr) {
          for(Iterator itr = listOfCachedAttributes().iterator(); itr.hasNext();) {
            AttrDecl attr = (AttrDecl)itr.next();
            stream.println(ind(2) + "h.transferSetsFrom(" + attr.attributeSignature() + "_handler);");
          }
          for (int c = 0; c < getNumComponents(); c++) {
             Components comp = getComponents(c);
             if (comp instanceof TokenComponent) {
              stream.println(ind(2) + "h.transferSetsFrom(get" + ((TokenComponent)comp).getTokenId().getID() + "_handler);");
             }
           }
        }
        if (grammar().incrementalLevelParam) {
          for(Iterator itr = listOfCachedAttributes().iterator(); itr.hasNext();) {
            AttrDecl attr = (AttrDecl)itr.next();
            if (attr.getNumParameter() > 0) {
              stream.println(ind(2) + "if (" + attr.attributeSignature() + "_handler != null) {");
              stream.println(ind(3) +   "for (java.util.Iterator itr = " + attr.attributeSignature() + 
                                              "_handler.values().iterator(); itr.hasNext();) {");
              stream.println(ind(4) +     "h.transferSetsFrom((ASTNode$DepGraphNode)itr.next());");
              stream.println(ind(3) +   "}");
              stream.println(ind(2) + "}");
            } else {
              stream.println(ind(2) + "h.transferSetsFrom(" + attr.attributeSignature() + "_handler);");
            }
          }
          for (int c = 0; c < getNumComponents(); c++) {
             Components comp = getComponents(c);
             if (comp instanceof TokenComponent) {
              stream.println(ind(2) + "h.transferSetsFrom(get" + ((TokenComponent)comp).getTokenId().getID() + "_handler);");
             }
           }
        }

        if (name().equals("ASTNode")) {    
          stream.println(ind(2) + "// flush subtree of values, take sets from encountered handler and remove it from DDG");
          if (grammar().incrementalLevelRegion) {
            stream.println(ind(2) + "if (isRegionRoot()) {");
            stream.println(ind(3) +   "h.transferSetsFrom(handler());");
            stream.println(ind(2) + "}");
            stream.println(ind(2) + "inc_flush();");
          }
          if (grammar().incrementalLevelNode) {
            stream.println(ind(2) + "h.transferSetsFrom(handler());");
            stream.println(ind(2) + "inc_flush();");
          }
          if (grammar().incrementalLevelAttr) {
            stream.println(ind(3) +   "h.transferSetsFrom(getParent_handler);");
            stream.println(ind(3) +   "h.transferSetsFrom(getChild_handler);");
            stream.println(ind(3) +   "h.transferSetsFrom(numChildren_handler);");
          }
          if (grammar().incrementalLevelParam) {
            stream.println(ind(3) +   "h.transferSetsFrom(getParent_handler);");
            stream.println(ind(3) +   "h.transferSetsFrom(numChildren_handler);");
            stream.println(ind(3) +   "for (int i = 0; getChild_handler != null && i < getChild_handler.length; i++) {");
            stream.println(ind(4) +     "h.transferSetsFrom(getChild_handler[i]);");
            stream.println(ind(3) +   "}");
          }
          stream.println(ind(2) + "for (int i = 0; children != null && i < children.length; i++) {");
          stream.println(ind(3) +   "ASTNode child = children[i];");
          stream.println(ind(3) +   "if (child != null) {");
          stream.println(ind(4) +     "child.inc_flush_subtree(h);");
          stream.println(ind(3) +   "}");
          stream.println(ind(2) + "}");
        } else {
          stream.println(ind(2) + "super.inc_flush_subtree(h);");
        }
        stream.println(ind + "}"); 
      }
      // end method: inc_flush_subtree
    }
    
    
    // method: inc_notifyForRemove
    if (name().equals("ASTNode")) {  
      stream.println(ind + "public void ASTNode.inc_notifyForRemove() {");
      if (grammar().incrementalLevelParam || grammar().incrementalLevelAttr) {
        stream.println(ind(2) + "getParent_handler.notifyDependencies();");
      }
      if (grammar().incrementalLevelNode) {
        stream.println(ind(2) + "handler.flushRegion();");
      }
      if (grammar().incrementalLevelRegion) {
        stream.println(ind(2) + "handler().flushRegion();");
      }
      stream.println(ind + "}"); 
    } 
    // end method: inc_notifyForRemove
    
  }
  
  /**
   * Creates string with code checking if the value of an attribute,
   * identified with name and parameters, is a affected by a change.
   * TODO: Add support for attributes with more than one parameter
   */
  public String ASTDecl.emitAttrAffectedChecksString() {
    StringBuffer res = new StringBuffer();
    TemplateContext tt = templateContext();
    boolean firstAttr = true;      
    for(Iterator itr = listOfCachedAttributes().iterator(); itr.hasNext();) {
      AttrDecl attr = (AttrDecl)itr.next();
      res.append(firstAttr ? "" : "else ");
      tt.bind("AttrResetVisit", attr.resetVisit());
      tt.bind("AttrResetCache", attr.resetCache());
      tt.bind("IsNTA", attr.getNTA() || attr.isNTA());
      tt.bind("IsParamAttr", attr.getNumParameter() > 0);
      tt.bind("IsAttrWithOneParam", attr.getNumParameter() == 1);
      tt.bind("IsPrimitiveAttr", attr.isPrimitive());
      tt.bind("AttrSign", attr.attributeSignature());
      tt.bind("AttrName", attr.getName());
      tt.bind("AttrType", attr.type());
      String attrObjectType = attr.type();
      attrObjectType = attrObjectType.substring(0,1).toUpperCase() + attrObjectType.substring(1);
      tt.bind("AttrObjectType", attrObjectType);
      tt.bind("ParamTypeSignature", attr.getNumParameter() > 0 ? attr.getParameter(0).getTypeInSignature(): "");
      res.append(tt.expand("ASTDecl.checkAttrValueAffected"));
      firstAttr = false;
    }
    return res.toString();
  }
  
  /**
   * Creates string with code checking if an attribute, identified with 
   * name and parameters, should be flushed and dependencies notified.
   */  
  public String ASTDecl.emitAttrFlushChecksString() {
    if (grammar().incrementalLevelNode || grammar().incrementalLevelRegion) {
      return "";
    }
    StringBuffer res = new StringBuffer();
    TemplateContext tt = templateContext();
    boolean firstAttr = true;      
    for(Iterator itr = listOfCachedAttributes().iterator(); itr.hasNext();) {
      AttrDecl attr = (AttrDecl)itr.next();
      res.append(firstAttr ? "" : "else ");
      tt.bind("IsParamAttr", attr.getNumParameter() > 0);
      tt.bind("AttrSign", attr.attributeSignature());
      tt.bind("AttrType", attr.type());
      tt.bind("AttrResetVisit", attr.resetVisit());
      tt.bind("AttrResetCache", attr.resetCache());
      tt.bind("IsNTA", (attr.isNTA() || attr.getNTA()) && 
      		!attr.isPrimitive() && !(attr.type().equals("String") || 
      		attr.type().equals("java.lang.String")));
      res.append(tt.expand("ASTDecl.attrFlushCheck"));
      firstAttr = false;
    }
    return res.toString();
  }
}
