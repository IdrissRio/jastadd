/* Copyright (c) 2011-2013, Emma SÃ¶derberg <emma.soderberg@cs.lth.se>
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Lund University nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
aspect IncrementalDDG {

  /**
   * Generates the class representing dynamic dependency graph (DDG) nodes.
   */
  public void Grammar.genIncrementalDDGNode(PrintWriter out) {
    if (!grammar().incremental) return;
    TemplateContext tt = templateContext();
    tt.expand("Grammar.emitDDGNode", out);
  }
  
  /** 
   * Generate DDG nodes for storage that needs dependency tracking in an AST node.
   * The number of DDG nodes needed depend on the incremental configuration:
   *  - param: children by index, parent, attributes with parameters
   *  - attr:  children, parent, attributes
   *  - node:  one per node
   *  - region: on node if region root (non region roots use a method to find the root)
   */ 
  public void ASTDecl.genIncrementalHandlers(PrintWriter out) {
    if (!grammar().incremental) return; 
    TemplateContext tt = templateContext();
    if (grammar().incrementalLevelRegion && 
    	isRegionRoot() && !hasRegionRootAsSuperClass()) {
      tt.expand("ASTDecl.createNodeHandler", out);
    }
    if (grammar().incrementalLevelNode &&
      		name().equals("ASTNode")) {
      tt.expand("ASTDecl.createNodeHandler", out);
    } 
    if (grammar().incrementalLevelParam || 
    	grammar().incrementalLevelAttr) {
      
      if (name().equals("ASTNode")) {      
        tt.expand("ASTDecl.createASTHandlers", out);
      }
      // collect attributes
      ArrayList list = new ArrayList();
      for(int k = 0; k < getNumSynDecl(); k++) {
        AttrDecl attr = getSynDecl(k);
        if (attr.getLazy() || attr.isCircular()) 
          list.add(attr);
      }
      for(int k = 0; k < getNumInhDecl(); k++) {
        AttrDecl attr = getInhDecl(k);
        if (attr.getLazy() || attr.isCircular()) 
          list.add(attr);
      }
      for (int k = 0; k < getNumCollDecl(); k++) {
        CollDecl attr = getCollDecl(k);
        list.add(attr);      
      }
      // attribute code 
      for (Iterator itr = list.iterator(); itr.hasNext();) {
        AttrDecl attr = (AttrDecl)itr.next();
        tt.bind("AttributeName", attr.attributeSignature());
        tt.bind("IsParamAttr", attr.getNumParameter() > 0);
        tt.expand("ASTDecl.createAttributeHandler", out);        
      }
    }
  }

  /**
   * Generate a handler for token components. 
   * Tokens only get DDG nodes for certain incremental configurations: param, attr. 
   */
  String TokenComponent.jaddGenIncrementalTokenHandler(ASTDecl decl) {
    if (!grammar().incremental) return ""; 
    if (!isNTA()) {
      TemplateContext tt = templateContext();
      tt.bind("Host", decl.name());
      tt.bind("Id", getTokenId().getID());
      return tt.expand("TokenComponent.createTokenHandler");                 
    }
    return ""; // grammar().incrementalLevelNode
  }
  
  public String ASTDecl.genIncrementalChildInitMethod() {
    if (!grammar().incremental) return "";
    if (grammar().incrementalLevelParam) {
      return "\ngetChild_handler = new ASTNode$DepGraphNode[" + childCount() + "];";
    }
    return "";  
  }

  public void ASTDecl.jjtGenIncrementalRegions(PrintWriter stream) {
    if (!grammar().incremental) return; 
    // method: isRegionRoot()
    if (grammar().incrementalLevelNode) {
      if (name().equals("ASTNode")) {
        stream.println(ind + "public boolean ASTNode.isRegionRoot() {");
        stream.println(ind(2) + "return true;");
        stream.println(ind + "}"); 
      }
    }
    if (grammar().incrementalLevelRegion) {
      stream.println(ind + "public boolean " + name() + ".isRegionRoot() {");
      if (isRegionRoot())
        stream.println(ind(2) + "return true;");
      else {
        if (name().equals("ASTNode")) {
          stream.println(ind(2) + "return false;");
        } else { 
          stream.println(ind(2) + "return super.isRegionRoot();");
        }
      }
      stream.println(ind + "}"); 
    }
    // method end: isRegionRoot()

    // method: regionRoot()
    if (grammar().incrementalLevelRegion) {
      if (name().equals("ASTNode")) {
        if (isRegionRoot()) {
          stream.println(ind + "public ASTNode " + name() + ".regionRoot() {");
          stream.println(ind(2) + "return this;");
          stream.println(ind + "}"); 
        } else {
          stream.println(ind + "public ASTNode " + name() + ".regionRoot() {");
          stream.println(ind(2) + "return parent != null ? parent.regionRoot() : null;");
          stream.println(ind + "}"); 
        }
      } else {
      if (isRegionRoot()) {
        stream.println(ind + "public ASTNode " + name() + ".regionRoot() {");
        stream.println(ind(2) + "return this;");
        stream.println(ind + "}"); 
      } else {
        stream.println(ind + "public ASTNode " + name() + ".regionRoot() {");
        stream.println(ind(2) + "return super.regionRoot();");
        stream.println(ind + "}"); 
      }
      }
    }
    // method end: regionRoot()

    // method: handler()
    if (grammar().incrementalLevelRegion) {
      if (isRegionRoot()) {
        stream.println(ind + "public ASTNode$DepGraphNode " + name() + ".handler() {");
        stream.println(ind(2) + "return handler;");
        stream.println(ind + "}"); 
      } else {
        stream.println(ind + "public ASTNode$DepGraphNode " + name() + ".handler() {");
        if (name().equals("ASTNode")) {
          stream.println(ind(2) + "ASTNode root = regionRoot();");
          stream.println(ind(2) + "return root != null ? root.handler() : null;");
        } else {
          stream.println(ind(2) + "ASTNode$DepGraphNode h = super.handler();");
          stream.println(ind(2) + "if (h != null) return h;");
          stream.println(ind(2) + "ASTNode root = regionRoot();");
          stream.println(ind(2) + "return root != null ? root.handler() : null;");
        }
        stream.println(ind + "}"); 
      }
    }
    if (grammar().incrementalLevelNode) {
      if (name().equals("ASTNode")) {
        stream.println(ind + "public ASTNode$DepGraphNode ASTNode.handler() {");
        stream.println(ind(2) + "return handler;");
        stream.println(ind + "}"); 
      }
    }
    // method end: handler()

    // method: getParent() -- overloaded for region tracking
    if (grammar().incrementalLevelRegion) {
      if (isRegionRoot() && !name().equals("ASTNode")) {
        stream.println(ind + "public ASTNode " + name() + ".getParent() {");
        stream.println(ind(2) + "// region root");
        stream.println(ind(2) + "ASTNode parent = super.getParent();");
        stream.println(ind(2) + "if (state().IN_COMPUTATION > 0 && parent != null)");
        stream.println(ind(3) +   "parent.handler().addDependant(handler);");
        stream.println(ind(2) + "return parent;");
        stream.println(ind + "}");          
      }
    }
    // end method: getParent() -- overloaded for region tracking

    // method: getChild(int) -- overloaded for region tracking
    if (grammar().incrementalLevelRegion) {
//      stream.println(ind + "private boolean " + name() + ".IS_REGION_LEAF = " + isRegionLeaf() + ";");
//      stream.println(ind + "private boolean " + name() + ".IS_REGION_ROOT = " + isRegionRoot() + ";");

      if (isRegionLeaf()) {
        if (name().equals("List") || name().equals("Opt")) {
          if(grammar().java5) {
            stream.println(ind + "/**");
            stream.println(ind + " * @apilevel low-level");
            stream.println(ind + " */");
            stream.println(ind + "@SuppressWarnings(\"cast\") public T " + name() + ".getChild(int i) {");
            stream.println(ind(2) + "// region leaf");
            stream.println(ind(2) + "ASTNode child = super.getChild(i);");
            stream.println(ind(2) + "if (state().IN_COMPUTATION > 0 && child.isRegionRoot()) {");
            stream.println(ind(3) +   "child.handler().addDependant(handler());");
            stream.println(ind(2) + "}");
            stream.println(ind(2) + "return (T)child;");
            stream.println(ind + "}");    
            stream.println(ind + "/**");
            stream.println(ind + " * @apilevel low-level");
            stream.println(ind + " */");
            stream.println(ind + "@SuppressWarnings(\"cast\") public T " + name() + ".getChildNoTransform(int i) {");
            stream.println(ind(2) + "// region leaf");
            stream.println(ind(2) + "ASTNode child = super.getChildNoTransform(i);");
            stream.println(ind(2) + "if (state().IN_COMPUTATION > 0 && child.isRegionRoot()) {");
            stream.println(ind(3) +   "child.handler().addDependant(handler());");
            stream.println(ind(2) + "}");
            stream.println(ind(2) + "return (T)child;");
            stream.println(ind + "}");    
          } else {
            stream.println(ind + "/**");
            stream.println(ind + " * @apilevel low-level");
            stream.println(ind + " */");
            stream.println(ind + "public ASTNode " + name() + ".getChild(int i) {");
            stream.println(ind(2) + "// region leaf");
            stream.println(ind(2) + "ASTNode child = super.getChild(i);");
            stream.println(ind(2) + "if (state().IN_COMPUTATION > 0 && child.isRegionRoot()) {");
            stream.println(ind(3) +   "child.handler().addDependant(handler());");
            stream.println(ind(2) + "}");
            stream.println(ind(2) + "return child;");
            stream.println(ind + "}");
            stream.println(ind + "/**");
            stream.println(ind + " * @apilevel low-level");
            stream.println(ind + " */");
            stream.println(ind + "public ASTNode " + name() + ".getChildNoTransform(int i) {");
            stream.println(ind(2) + "// region leaf");
            stream.println(ind(2) + "ASTNode child = super.getChildNoTransform(i);");
            stream.println(ind(2) + "if (state().IN_COMPUTATION > 0 && child.isRegionRoot()) {");
            stream.println(ind(3) +   "child.handler().addDependant(handler());");
            stream.println(ind(2) + "}");
            stream.println(ind(2) + "return child;");
            stream.println(ind + "}");
          }
        }
        else if (!name().equals("ASTNode")) {
          stream.println(ind + "/**");
          stream.println(ind + " * @apilevel low-level");
          stream.println(ind + " */");
          stream.println(ind + "public ASTNode " + name() + ".getChild(int i) {");
          stream.println(ind(2) + "// region leaf");
          stream.println(ind(2) + "ASTNode child = super.getChild(i);");
          stream.println(ind(2) + "if (state().IN_COMPUTATION > 0 && child.isRegionRoot()) {");
          stream.println(ind(3) +   "child.handler().addDependant(handler());");
          stream.println(ind(2) + "}");
          stream.println(ind(2) + "return child;");
          stream.println(ind + "}");
          stream.println(ind + "/**");
          stream.println(ind + " * @apilevel low-level");
          stream.println(ind + " */");
          stream.println(ind + "public ASTNode " + name() + ".getChildNoTransform(int i) {");
          stream.println(ind(2) + "// region leaf");
          stream.println(ind(2) + "ASTNode child = super.getChildNoTransform(i);");
          stream.println(ind(2) + "if (state().IN_COMPUTATION > 0 && child.isRegionRoot()) {");
          stream.println(ind(3) +   "child.handler().addDependant(handler());");
          stream.println(ind(2) + "}");
          stream.println(ind(2) + "return child;");
          stream.println(ind + "}");
        }
      }
    }
    // end method: getChild(int) -- overloaded for region tracking

    // TODO revisit this method
/*
    // method: removeChild(int) -- overloaded for region tracking
    if (grammar().incrementalLevelRegion) {
      if (isRegionLeaf() && !name().equals("ASTNode")) {
        stream.println(ind + "public void " + name() + ".removeChild(int index) {");
        stream.println(ind(2) + "// region leaf");
        stream.println(ind(2) + "ASTNode child = getChild(index);");
        stream.println(ind(2) + "if (child.isRegionRoot()) {");
        stream.println(ind(3) +   "ASTNode$DepGraphNode handler = handler();");
        stream.println(ind(3) +   "if (handler != null) handler.flushRegion();");
        stream.println(ind(2) + "}");
        stream.println(ind(2) + "super.removeChild(index);");
        stream.println(ind + "}");
      }
    }
    // end method: removeChild(int) -- overloaded for region tracking

    // TODO revisit this method
    // method: insertChild(ASTNode,int) -- overloaded for region tracking
    if (grammar().incrementalLevelRegion) {
      if (isRegionLeaf() && !name().equals("ASTNode")) {
        stream.println("    public void " + name() + ".insertChild(ASTNode node, int index) {");
        stream.println("      // region leaf");
        stream.println("      if (node.isRegionRoot()) {");
        stream.println(ind(3) +   "ASTNode$DepGraphNode handler = handler();");
        stream.println(ind(3) +   "if (handler != null) handler.flushRegion();");
        stream.println("      }");
        stream.println("      super.insertChild(node, index);");
        stream.println("    }");
      }        
    }
    // end method: insertChild(ASTNode,int) -- overloaded for region tracking
*/

  } // end: jjtGenIncrementalRegions  

  public void ASTDecl.jjtGenIncrementalCopyHandlers(PrintWriter stream) {
    if (!grammar().incremental) return; 
    stream.println(ind + "protected void " + name() + ".inc_copyHandlers(" + name() + " copy) {");
    // ast handlers
    if (name().equals("ASTNode")) {
      if (grammar().incrementalLevelParam) {
        stream.println(ind(2) + "if (getChild_handler != null)");
        stream.println(ind(3) +   "copy.getChild_handler = (ASTNode$DepGraphNode[])getChild_handler.clone();");
        stream.println(ind(2) + "copy.numChildren_handler = new ASTNode$DepGraphNode(numChildren_handler, copy);");
        stream.println(ind(2) + "copy.getParent_handler = new ASTNode$DepGraphNode(getParent_handler, copy);");
        stream.println(ind(2) + "for (int i = 0; getChild_handler != null && i < getChild_handler.length; i++) {");
        stream.println(ind(3) +   "if (getChild_handler[i] != null) {");
        stream.println(ind(4) +     "copy.getChild_handler[i] = new ASTNode$DepGraphNode(getChild_handler[i], copy);");
        stream.println(ind(3) +   "}");
        stream.println(ind(2) + "}");
      }
      if (grammar().incrementalLevelAttr) {
        stream.println(ind(2) + "copy.getChild_handler = new ASTNode$DepGraphNode(getChild_handler, copy);");
        stream.println(ind(2) + "copy.numChildren_handler = new ASTNode$DepGraphNode(numChildren_handler, copy);");
        stream.println(ind(2) + "copy.getParent_handler = new ASTNode$DepGraphNode(getParent_handler, copy);");
      }
      if (grammar().incrementalLevelNode) {
        stream.println(ind(2) + "copy.handler = new ASTNode$DepGraphNode(handler, copy);");
      }
      if (grammar().incrementalLevelRegion) {
        if (isRegionRoot())
          stream.println(ind(2) + "copy.handler = new ASTNode$DepGraphNode(handler, copy);");
      }
    } else {
      if (grammar().incrementalLevelRegion || grammar().incrementalLevelNode) {
        if (isRegionRoot()) {
          stream.println(ind(2) + "copy.handler = new ASTNode$DepGraphNode(handler, copy);"); 
        } else {
          stream.println(ind(2) + "super.inc_copyHandlers(copy);");
        }
      }
      if (grammar().incrementalLevelAttr || grammar().incrementalLevelParam) {
        stream.println(ind(2) + "super.inc_copyHandlers(copy);");
      }
    }
    if (grammar().incrementalLevelParam || grammar().incrementalLevelAttr) {
      // tokens
      for (int c = 0; c < getNumComponents(); c++) {
        Components comp = getComponents(c);
        if (comp instanceof TokenComponent) {
          stream.println(ind(2) + "if (get" + ((TokenComponent)comp).getTokenId().getID() + "_handler != null) {");
          stream.println(ind(3) +   "copy.get" + ((TokenComponent)comp).getTokenId().getID() + 
                                    "_handler = new ASTNode$DepGraphNode(get" + 
                               ((TokenComponent)comp).getTokenId().getID() + "_handler, copy);\n");
          stream.println(ind(2) + "}");

         }
       }
      // Collect attributes: syn then inh
      ArrayList list = new ArrayList();
      for(int k = 0; k < getNumSynDecl(); k++) {
        AttrDecl attr = getSynDecl(k);
        if (attr != null && (attr.getLazy() || attr.isCircular())) 
          list.add(attr);
      }
      for(int k = 0; k < getNumInhDecl(); k++) {
        AttrDecl attr = getInhDecl(k);
        if (attr != null && (attr.getLazy() || attr.isCircular())) 
          list.add(attr);
      }
      // Attribute code: propagate change of all cached values being removed
      for(Iterator itr = list.iterator(); itr.hasNext();) {
        AttrDecl attr = (AttrDecl)itr.next();
        if (attr.getNumParameter() > 0) {
          if (grammar().incrementalLevelParam) {
            stream.println(ind(2) + "if (" + attr.attributeSignature() + "_handler != null) {");
            stream.println(ind(3) +   "copy." + attr.attributeSignature() + "_handler = new java.util.HashMap(4);");
            stream.println(ind(2) + "}");
          } else {
            stream.println(ind(2) + "if (" + attr.attributeSignature() + "_handler != null) {");
            stream.println(ind(3) + "copy." + attr.attributeSignature() + "_handler = new ASTNode$DepGraphNode(" + 
                                    attr.attributeSignature() + "_handler, copy);");
            stream.println(ind(2) + "}");
          }
        } else {
          stream.println(ind(2) + "if (" + attr.attributeSignature() + "_handler != null) {");
          stream.println(ind(3) + "copy." + attr.attributeSignature() + "_handler = new ASTNode$DepGraphNode(" + 
                                  attr.attributeSignature() + "_handler, copy);");
          stream.println(ind(2) + "}");
        }
      }    
    }
    // end of method
    stream.println(ind + "}");
  }

}