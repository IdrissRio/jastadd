/* Copyright (c) 2011-2013, Emma SÃ¶derberg <emma.soderberg@cs.lth.se>
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Lund University nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
aspect IncrementalFlush {

  public void ASTDecl.jjtGenIncrementalChangeFlush(PrintWriter stream) {
    if (!grammar().incremental) return; 
    if (grammar().incrementalLevelNode) {
      stream.println(ind(2) + "inc_flushRegionRoot();");
      stream.println(ind(2) + "handler.notifyDependencies();");
    }
    if (grammar().incrementalLevelRegion) {
      if (isRegionRoot()) {
        stream.println(ind(2) + "if (inc_flushRegionRoot()) {");
        stream.println(ind(3) +   "handler.clearDependencies();");
        stream.println(ind(3) +   "handler.notifyDependencies();");      
        stream.println(ind(2) + "}");
      }
    }
    // flush child start
    if (grammar().incrementalLevelParam) {
      if (name().equals("ASTNode")) {
        // stream.println("    if (attrID.equals(\"getChild\") && !state().IN_REWRITE_EVAL) {");
        stream.println(ind(2) + "if (attrID.equals(\"getChild\")) {");
        stream.println(ind(3) +   "int i = (Integer)_parameters;");
        stream.println(ind(3) +   "if (rewritten_children != null && i < rewritten_children.length && rewritten_children[i]) {");
        // make sure this condition is false before calling notify, there may be a circular dependency resulting in a double
        // flush otherwise, a double flush will cause null to be moved in as the initial child
        stream.println(ind(4) +     "rewritten_children[i] = false;");
        stream.println(ind(4) +     "children[i].inc_resetRewrites();");
        stream.println(ind(4) +     "// outer rewrites");
        stream.println(ind(4) +     "if (init_children[i] != null) {");
        stream.println(ind(5) +       "// set up change");
        stream.println(ind(5) +       "ASTNode oldChild = children[i];");
        stream.println(ind(5) +       "ASTNode newChild = init_children[i];");
        stream.println(ind(5) +       "// make change");
//        stream.println(ind(5) +       "oldChild.inc_throwAway();");
        stream.println(ind(5) +       "oldChild.inc_flush_subtree(getChild_handler[i]);");
        stream.println(ind(5) +       "children[i] = newChild;");
        stream.println(ind(5) +       "init_children[i] = null;");
        stream.println(ind(5) +       "// set parents and notify");
        stream.println(ind(5) +       "newChild.setParent(this);");
        stream.println(ind(5) +       "getChild_handler[i].notifyDependencies();");    
        stream.println(ind(4) +     "}");
        stream.println(ind(4) +     "// inner rewrites");
        stream.println(ind(4) +     "else {");
        stream.println(ind(5) +       "inc_restoreEnclosingRewrite();");
        stream.println(ind(4) +     "}");
        stream.println(ind(3) +   "}");
        stream.println(ind(2) + "}");
      }
    }
    if (grammar().incrementalLevelAttr) {
      if (name().equals("ASTNode")) {
        stream.println(ind(2) + "if (attrID.equals(\"getChild\")) {");
        stream.println(ind(3) +   "if (inc_checkRegionForInnerRewrite()) {");
        stream.println(ind(4) +     "ASTNode enclosingNode = inc_locateEnclosingRewrittenNode();");
        stream.println(ind(4) +     "enclosingNode.getChild_handler.flushRegion();");
        stream.println(ind(4) +     "return;");
        stream.println(ind(3) +   "} else {");
        stream.println(ind(4) +     "inc_flushRegion_rewrites();");
        stream.println(ind(4) +     "getChild_handler.notifyDependencies();");
        stream.println(ind(4) +     "return;");
        stream.println(ind(3) +   "}");
        stream.println(ind(2) + "}");
      }
    }
    // flush child end

    // flush attributes start
    if (grammar().incrementalLevelAttr || grammar().incrementalLevelParam) {
      ArrayList list = new ArrayList();
      for(int k = 0; k < getNumSynEq(); k++) {
        AttrDecl attr = getSynEq(k).decl();
        if (attr != null && (attr.getLazy() || attr.isCircular())) 
          list.add(attr);
      }
      for(int k = 0; k < getNumInhDecl(); k++) {
        AttrDecl attr = getInhDecl(k);
        if (attr != null && (attr.getLazy() || attr.isCircular())) 
          list.add(attr);
      }

      // Add attribute code: flush attributes
      boolean first = true;
      for(Iterator itr = list.iterator(); itr.hasNext();) {
        AttrDecl attr = (AttrDecl)itr.next();

        // start match attribute statement
        if (grammar().incrementalLevelParam) {
          stream.print(ind(2) + (first ? "" : "else "));
          stream.print("if (" + "attrID.equals(\"" + attr.attributeSignature() + "\")");
          if (attr.getNumParameter() > 0) 
            stream.print(" && " + attr.attributeSignature() + "_values != null" + 
              " && " + attr.attributeSignature() + "_values.containsKey(_parameters)");
          else stream.print(" && " + attr.attributeSignature() + "_computed");
          stream.println(") {");
        }
        if (grammar().incrementalLevelAttr) {
          stream.print(ind(2) + (first ? "" : "else "));
          stream.print("if (attrID.equals(\"" + attr.attributeSignature() + "\")");
          if (attr.getNumParameter() > 0) {
            stream.print(" && " + attr.attributeSignature() + "_values != null" + 
              " && !" + attr.attributeSignature() + "_values.isEmpty()");  
          } else stream.println(" && " + attr.attributeSignature() + "_computed");
          stream.println(") {");
        }

        // handle parameterized attributes
        if (attr.getNumParameter() > 0) {

          if (grammar().incrementalLevelParam) {
            // handler NTA
            if ((attr.isNTA() || attr.getNTA()) && !attr.isPrimitive() 
                && !(attr.type().equals("String") || attr.type().equals("java.lang.String"))) {
              stream.println(ind(3) + attr.type() + " value = (" + attr.type() + ")" + attr.attributeSignature() + "_values.remove(_parameters);");                 
              stream.println(ind(3) + "for (int i = 0; i < " + attr.attributeSignature() + "_list.children.length; i++) {");
              stream.println(ind(4) +   "ASTNode child = " + attr.attributeSignature() + "_list.children[i];");
              stream.println(ind(4) +   "if (child != null && value == child) {");
              // using dummy node to flush dependencies from NTA 
//              stream.println(ind(5) +     "value.inc_flush_subtree(new ASTNode$DepGraphNode(new Opt(), \"\", null));");
              stream.println(ind(5) +     "value.inc_flush_subtree((ASTNode$DepGraphNode)" + 
                                        attr.attributeSignature() + "_handler.get(_parameters));");
              stream.println(ind(5) +     attr.attributeSignature() + "_list.removeChild(i);");
              stream.println(ind(5) +     "break;");
              stream.println(ind(4) +   "}");
              stream.println(ind(3) + "}");
            } else {
              stream.println(ind(3) + attr.attributeSignature() + "_values.remove(_parameters);"); 
            }
          } else {
            // handler NTA
            if ((attr.isNTA() || attr.getNTA()) && !attr.isPrimitive() 
                && !(attr.type().equals("String") || attr.type().equals("java.lang.String"))) {
                stream.println(ind(2) + "if (" + attr.attributeSignature() + "_list != null) {");
                stream.println(ind(3) +     attr.attributeSignature() + "_list.setParent(null);");
                // using dummy node to flush dependencies from NTA 
//                stream.println(ind(3) +     attr.attributeSignature() + 
//                                  "_value.inc_flush_subtree(new ASTNode$DepGraphNode(new Opt(), \"\", null))");
                stream.println(ind(3) +     attr.attributeSignature() + "_list.inc_flush_subtree(" + 
                                  attr.attributeSignature() + "_handler);");
                stream.println(ind(2) + "}");
            }
            String u = attr.resetVisit() + attr.resetCache();
            u = u.replaceAll("#NAME#", attr.attributeSignature());
            stream.print(u);              
          }

        } else {
          // handle NTAs
          if ((attr.isNTA() || attr.getNTA()) && !attr.isPrimitive() && 
                !(attr.type().equals("String") || attr.type().equals("java.lang.String"))) {
            stream.println(ind(3) + "if (" + attr.attributeSignature() + "_value instanceof ASTNode) {");
            stream.println(ind(4) + attr.attributeSignature() + "_value.setParent(null);");
            // using dummy node to flush dependencies from NTA 
            if (grammar().incrementalLevelParam) {
//              stream.println(ind(4) + attr.attributeSignature() + "_value.inc_flush_subtree(new ASTNode$DepGraphNode(new Opt(), \"\", null));");
              stream.println(ind(4) + attr.attributeSignature() + "_value.inc_flush_subtree(" + attr.attributeSignature() + "_handler);");
            }
            else if (grammar().incrementalLevelAttr) {
              stream.println(ind(4) + attr.attributeSignature() + "_value.inc_flush_subtree(new ASTNode$DepGraphNode(new Opt(), \"\"));");
            } else {
              stream.println(ind(4) + attr.attributeSignature() + "_value.inc_flush_subtree(new ASTNode$DepGraphNode(new Opt()));");
            }
            stream.println(ind(3) + "}");
          }

          String u = attr.resetVisit() + attr.resetCache();
          u = u.replaceAll("#NAME#", attr.attributeSignature());
          stream.print(u);
        }
        // notify
        if (grammar().incrementalLevelParam) {
          if (attr.getNumParameter() > 0) {
            stream.println(ind(3) +   "ASTNode$DepGraphNode handler = (ASTNode$DepGraphNode)" + 
                                        attr.attributeSignature() + "_handler.remove(_parameters);");
            stream.println(ind(3) +   "handler.throwAway();");
            stream.println(ind(3) +   "handler.notifyDependencies();");
          } else {
            stream.println(ind(3) + attr.attributeSignature() + "_handler.notifyDependencies();");
          }
          if (!name().equals("ASTNode"))
            stream.println(ind(3) +   "super.reactToDependencyChange(attrID, _parameters);");
        } 
        if (grammar().incrementalLevelAttr) {
          stream.println(ind(3) + attr.attributeSignature() + "_handler.notifyDependencies();");
          stream.println(ind(3) +   "super.reactToDependencyChange(attrID);");
        }
      
        stream.println(ind(3) +   "return;");
        stream.println(ind(2) + "}");      // end match statement
        first = false;
      }  
    }
  }

  public void ASTDecl.jjtGenIncrementalTreeModification(PrintWriter stream) {
    if (!grammar().incremental) return; 
    if (name().equals("ASTNode")) {
      // rewrite code: intial copy store -- full flush also adds this
      if (!grammar().fullFlush) {
        // ES_TODO: These should be protected, public now for debugging reasons
        stream.println(ind + "public ASTNode[] ASTNode.init_children;");
        stream.println(ind + "public boolean[] ASTNode.rewritten_children;");
        // method: inc_hasEnclosingRewrittenNode
        stream.println(ind + "protected boolean ASTNode.inc_hasEnclosingRewrittenNode() {");
        stream.println(ind(2) + "ASTNode child = this;");
        stream.println(ind(2) + "ASTNode parent = this.parent;");
        stream.println(ind(2) + "while (parent != null) {");
        //stream.println(ind(3) +   "int index = parent.getIndexOfChild(child);");
        stream.println(ind(3) +   "if (parent.mayHaveRewrite()) {");
        //  stream.println(ind(3) +   "if (parent.rewritten_children != null && index >= 0 && " + 
        //  "index < parent.rewritten_children.length && parent.rewritten_children[index]) {");
        stream.println(ind(4) +     "return true;");
        stream.println(ind(3) +   "}");
        stream.println(ind(3) +   "child = parent;");
        stream.println(ind(3) +   "parent = parent.parent;");
        stream.println(ind(2) + "}");
        stream.println(ind(2) + "return false;");
        stream.println(ind + "}"); // end method: inc_hasEnclosingRewrittenNode
        // method: inc_locateEnclosingRewrittenNode
        if (grammar().incrementalLevelParam || grammar().incrementalLevelAttr) {
          stream.println(ind + "protected ASTNode ASTNode.inc_locateEnclosingRewrittenNode() {");
          stream.println(ind(2) + "ASTNode child = this;");
          stream.println(ind(2) + "ASTNode parent = this.parent;");
          stream.println(ind(2) + "while (parent != null) {");
          stream.println(ind(3) +   "if (child.mayHaveRewrite()) {");
          //  stream.println(ind(3) +   "if (parent.rewritten_children != null && index >= 0 && " + 
          //  "index < parent.rewritten_children.length && parent.rewritten_children[index]) {");
          stream.println(ind(4) +     "return parent;");
          stream.println(ind(3) +   "}");
          stream.println(ind(3) +   "child = parent;");
          stream.println(ind(3) +   "parent = parent.parent;");
          stream.println(ind(2) + "}");
          stream.println(ind(2) + "return null;");
          stream.println(ind + "}"); 
        }
        if (grammar().incrementalLevelRegion || grammar().incrementalLevelNode) {
          stream.println(ind + "protected ASTNode ASTNode.inc_locateEnclosingRewrittenNode() {");
          stream.println(ind(2) + "ASTNode node = parent;");
          stream.println(ind(2) + "while (node != null) {");
          stream.println(ind(3) +   "if (node.mayHaveRewrite()) {");
          //  stream.println(ind(3) +   "if (parent.rewritten_children != null && index >= 0 && " + 
          //  "index < parent.rewritten_children.length && parent.rewritten_children[index]) {");
          stream.println(ind(4) +     "return node;");
          stream.println(ind(3) +   "}");
          stream.println(ind(3) +   "node = node.parent;");
          stream.println(ind(2) + "}");
          stream.println(ind(2) + "return null;");
          stream.println(ind + "}"); 
        }
        // end method: inc_locateEnclosingRewrittenNode

        // method: inc_resetRewrites
        stream.println(ind + "protected void ASTNode.inc_resetRewrites() {");
        stream.println(ind(2) + "for (int i = 0; i < numChildren; i++) {");
        stream.println(ind(3) +   "if (rewritten_children != null && i < rewritten_children.length) {");
        stream.println(ind(4) +     "rewritten_children[i] = false;");
        stream.println(ind(4) +     "if (init_children[i] != null) {");
        stream.println(ind(5) +       "init_children[i].inc_throwAway();");
        stream.println(ind(5) +       "init_children[i] = null;");
        stream.println(ind(4) +     "}");
        stream.println(ind(3) +   "}");
        stream.println(ind(3) +   "if (children[i] != null) {");
        stream.println(ind(4) +     "children[i].inc_resetRewrites();");
        stream.println(ind(3) +   "}");
        stream.println(ind(2) + "}");
        stream.println(ind + "}"); // end method: inc_resetRewrites
      }

      // method: inc_restoreEnclosingRewrite  
      if (grammar().incrementalLevelParam) {  
        stream.println(ind + "protected void ASTNode.inc_restoreEnclosingRewrite() {");
        stream.println(ind(2) + "ASTNode child = this;");
        stream.println(ind(2) + "ASTNode parent = this.parent;");
        stream.println(ind(2) + "while (parent != null) {");
        stream.println(ind(3) +   "int index = -1;");
        stream.println(ind(3) +   "for (int i = 0; i < parent.children.length; i++) {");
        stream.println(ind(4) +     "if (parent.children[i] == child) {");
        stream.println(ind(5) +       "index = i;");
        stream.println(ind(4) +     "}");
        stream.println(ind(3) +   "}");
        stream.println(ind(3) +   "if (child.mayHaveRewrite() && parent.inc_restoreInitialForIndex(index, parent.getChild_handler[index])) {");
        stream.println(ind(4) +     "parent.getChild_handler[index].notifyDependencies();");
        stream.println(ind(4) +     "break;");
        stream.println(ind(3) +   "}");
        stream.println(ind(3) +   "child = parent;");
        stream.println(ind(3) +   "parent = parent.getParent();");
        stream.println(ind(2) + "}");
        stream.println(ind + "}"); 
      }
      // end method: inc_restoreEnclosingRewrite
    
      // method: inc_restoreInitialForIndex
      if (grammar().incrementalLevelRegion || grammar().incrementalLevelNode) {      
        stream.println(ind + "protected boolean ASTNode.inc_restoreInitialForIndex(int index, ASTNode$DepGraphNode h) {");
        stream.println(ind(2) + "if (init_children != null && index < init_children.length " + 
                                                  "&& init_children[index] != null) {");
        stream.println(ind(3) +   "ASTNode oldNode = children[index];");
        stream.println(ind(3) +   "state().enterConstruction();");
        stream.println(ind(3) +   "setChild(init_children[index], index);");
        stream.println(ind(3) +   "state().exitConstruction();");
        stream.println(ind(3) +   "oldNode.inc_flush_subtree(h);");
        stream.println(ind(3) +   "init_children[index] = null;");
        stream.println(ind(3) +   "rewritten_children[index] = false;");
        stream.println(ind(3) +   "return true;");
        stream.println(ind(2) + "}");
        stream.println(ind(2) + "return false;");
        stream.println(ind + "}"); 
      }
      if (grammar().incrementalLevelParam || grammar().incrementalLevelAttr) {
        stream.println(ind + "protected boolean ASTNode.inc_restoreInitialForIndex(int index, ASTNode$DepGraphNode h) {");
        stream.println(ind(2) + "if (init_children != null && index < init_children.length " + 
                                                  "&& init_children[index] != null) {");
        stream.println(ind(3) + "ASTNode oldNode = children[index];");
        stream.println(ind(3) + "state().enterConstruction();");
        stream.println(ind(3) + "setChild(init_children[index], index);");
        stream.println(ind(3) + "state().exitConstruction();");
        stream.println(ind(3) + "oldNode.inc_flush_subtree(h);");
        stream.println(ind(3) + "init_children[index] = null;");
        stream.println(ind(3) + "return true;");
        stream.println(ind(2) + "}");
        stream.println(ind(2) + "return false;");
        stream.println(ind + "}"); 

      }
      // end method: inc_restoreInitialForIndex

      // method: inc_locateInitialCopy
      stream.println(ind + "protected ASTNode ASTNode.inc_locateInitialCopy() {");
      // locate enclosing rewrite
      stream.println(ind(2) + "ASTNode child = this;");
      stream.println(ind(2) + "ASTNode parent = getParent();");
      stream.println(ind(2) + "java.util.LinkedList indexList = new java.util.LinkedList();");
      stream.println(ind(2) + "while (parent != null) {");
      stream.println(ind(3) +   "int index = child.childIndex;");
      stream.println(ind(3) +   "indexList.addFirst(new Integer(index));");
      stream.println(ind(3) +   "if (parent.init_children != null && index >= 0 && " +
                                "index < parent.init_children.length && parent.init_children[index] != null) {");
      // stream.println(ind(3) +   "if (parent.is$Final() != child.is$Final()) {");
      stream.println(ind(4) +     "break;");
      stream.println(ind(3) +   "}");
      stream.println(ind(3) +   "child = parent;");
      stream.println(ind(3) +   "parent = child.getParent();");
      stream.println(ind(2) + "}");
      // root reached -- no enclosing rewrite
      stream.println(ind(2) + "if (parent == null) {");
      stream.println(ind(3) +   "return null;");
      stream.println(ind(2) + "}");
      // root not reached -- enclosing rewrite found
      stream.println(ind(2) + "boolean first = true;");
      stream.println(ind(2) + "for (java.util.Iterator itr = indexList.iterator(); itr.hasNext();) {");
      stream.println(ind(3) +   "int index = ((Integer)itr.next()).intValue();");
      stream.println(ind(3) +   "if (first) {");
      stream.println(ind(4) +     "first = false;");
      stream.println(ind(4) +     "child = parent.init_children[index];");
      stream.println(ind(4) +     "parent = child;");
      stream.println(ind(3) +   "} else if (index < parent.getNumChildNoTransform()) {");
      stream.println(ind(4) +     "child = parent.getChildNoTransform(index);");
      stream.println(ind(4) +     "parent = child;");
      stream.println(ind(3) +   "} else return null;");
      // stream.println(ind(3) +   "child = parent.getChildNoTransform(index);");
      // stream.println(ind(3) +   "parent = child;");
      // stream.println(ind(3) +   "if (child == null) {");
      // stream.println(ind(4) +     "throw new RuntimeException(\"Incremental tree modification error: " + 
      //                                        "premature end of change point path\");");
      // stream.println(ind(3) +   "}");
      stream.println(ind(2) + "}");
      // initial change point found
      stream.println(ind(2) + "return child;");      
      stream.println(ind + "}"); // end method: inc_locateInitialCopy
    }
  }

}