/* Copyright (c) 2011-2013, Emma SÃ¶derberg <emma.soderberg@cs.lth.se>
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Lund University nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
aspect IncrementalFlush {

  public void ASTDecl.jjtGenIncrementalTreeModification(PrintWriter stream) {
    if (!grammar().incremental) return; 
    if (name().equals("ASTNode")) {
      // rewrite code: intial copy store -- full flush also adds this
      if (!grammar().fullFlush) {
        // ES_TODO: These should be protected, public now for debugging reasons
        stream.println(ind + "public ASTNode[] ASTNode.init_children;");
        stream.println(ind + "public boolean[] ASTNode.rewritten_children;");
        // method: inc_hasEnclosingRewrittenNode
        stream.println(ind + "protected boolean ASTNode.inc_hasEnclosingRewrittenNode() {");
        stream.println(ind(2) + "ASTNode child = this;");
        stream.println(ind(2) + "ASTNode parent = this.parent;");
        stream.println(ind(2) + "while (parent != null) {");
        //stream.println(ind(3) +   "int index = parent.getIndexOfChild(child);");
        stream.println(ind(3) +   "if (parent.mayHaveRewrite()) {");
        //  stream.println(ind(3) +   "if (parent.rewritten_children != null && index >= 0 && " + 
        //  "index < parent.rewritten_children.length && parent.rewritten_children[index]) {");
        stream.println(ind(4) +     "return true;");
        stream.println(ind(3) +   "}");
        stream.println(ind(3) +   "child = parent;");
        stream.println(ind(3) +   "parent = parent.parent;");
        stream.println(ind(2) + "}");
        stream.println(ind(2) + "return false;");
        stream.println(ind + "}"); // end method: inc_hasEnclosingRewrittenNode
        // method: inc_locateEnclosingRewrittenNode
        if (grammar().incrementalLevelParam || grammar().incrementalLevelAttr) {
          stream.println(ind + "protected ASTNode ASTNode.inc_locateEnclosingRewrittenNode() {");
          stream.println(ind(2) + "ASTNode child = this;");
          stream.println(ind(2) + "ASTNode parent = this.parent;");
          stream.println(ind(2) + "while (parent != null) {");
          stream.println(ind(3) +   "if (child.mayHaveRewrite()) {");
          //  stream.println(ind(3) +   "if (parent.rewritten_children != null && index >= 0 && " + 
          //  "index < parent.rewritten_children.length && parent.rewritten_children[index]) {");
          stream.println(ind(4) +     "return parent;");
          stream.println(ind(3) +   "}");
          stream.println(ind(3) +   "child = parent;");
          stream.println(ind(3) +   "parent = parent.parent;");
          stream.println(ind(2) + "}");
          stream.println(ind(2) + "return null;");
          stream.println(ind + "}"); 
        }
        if (grammar().incrementalLevelRegion || grammar().incrementalLevelNode) {
          stream.println(ind + "protected ASTNode ASTNode.inc_locateEnclosingRewrittenNode() {");
          stream.println(ind(2) + "ASTNode node = parent;");
          stream.println(ind(2) + "while (node != null) {");
          stream.println(ind(3) +   "if (node.mayHaveRewrite()) {");
          //  stream.println(ind(3) +   "if (parent.rewritten_children != null && index >= 0 && " + 
          //  "index < parent.rewritten_children.length && parent.rewritten_children[index]) {");
          stream.println(ind(4) +     "return node;");
          stream.println(ind(3) +   "}");
          stream.println(ind(3) +   "node = node.parent;");
          stream.println(ind(2) + "}");
          stream.println(ind(2) + "return null;");
          stream.println(ind + "}"); 
        }
        // end method: inc_locateEnclosingRewrittenNode

        // method: inc_resetRewrites
        stream.println(ind + "protected void ASTNode.inc_resetRewrites() {");
        stream.println(ind(2) + "for (int i = 0; i < numChildren; i++) {");
        stream.println(ind(3) +   "if (rewritten_children != null && i < rewritten_children.length) {");
        stream.println(ind(4) +     "rewritten_children[i] = false;");
        stream.println(ind(4) +     "if (init_children[i] != null) {");
        stream.println(ind(5) +       "init_children[i].inc_throwAway();");
        stream.println(ind(5) +       "init_children[i] = null;");
        stream.println(ind(4) +     "}");
        stream.println(ind(3) +   "}");
        stream.println(ind(3) +   "if (children[i] != null) {");
        stream.println(ind(4) +     "children[i].inc_resetRewrites();");
        stream.println(ind(3) +   "}");
        stream.println(ind(2) + "}");
        stream.println(ind + "}"); // end method: inc_resetRewrites
      }

      // method: inc_restoreEnclosingRewrite  
      if (grammar().incrementalLevelParam) {  
        stream.println(ind + "protected void ASTNode.inc_restoreEnclosingRewrite() {");
        stream.println(ind(2) + "ASTNode child = this;");
        stream.println(ind(2) + "ASTNode parent = this.parent;");
        stream.println(ind(2) + "while (parent != null) {");
        stream.println(ind(3) +   "int index = -1;");
        stream.println(ind(3) +   "for (int i = 0; i < parent.children.length; i++) {");
        stream.println(ind(4) +     "if (parent.children[i] == child) {");
        stream.println(ind(5) +       "index = i;");
        stream.println(ind(4) +     "}");
        stream.println(ind(3) +   "}");
        stream.println(ind(3) +   "if (child.mayHaveRewrite() && parent.inc_restoreInitialForIndex(index, parent.getChild_handler[index])) {");
        stream.println(ind(4) +     "parent.getChild_handler[index].notifyDependencies();");
        stream.println(ind(4) +     "break;");
        stream.println(ind(3) +   "}");
        stream.println(ind(3) +   "child = parent;");
        stream.println(ind(3) +   "parent = parent.getParent();");
        stream.println(ind(2) + "}");
        stream.println(ind + "}"); 
      }
      // end method: inc_restoreEnclosingRewrite
    
      // method: inc_restoreInitialForIndex
      if (grammar().incrementalLevelRegion || grammar().incrementalLevelNode) {      
        stream.println(ind + "protected boolean ASTNode.inc_restoreInitialForIndex(int index, ASTNode$DepGraphNode h) {");
        stream.println(ind(2) + "if (init_children != null && index < init_children.length " + 
                                                  "&& init_children[index] != null) {");
        stream.println(ind(3) +   "ASTNode oldNode = children[index];");
        stream.println(ind(3) +   "state().enterConstruction();");
        stream.println(ind(3) +   "setChild(init_children[index], index);");
        stream.println(ind(3) +   "state().exitConstruction();");
        stream.println(ind(3) +   "oldNode.inc_flush_subtree(h);");
        stream.println(ind(3) +   "init_children[index] = null;");
        stream.println(ind(3) +   "rewritten_children[index] = false;");
        stream.println(ind(3) +   "return true;");
        stream.println(ind(2) + "}");
        stream.println(ind(2) + "return false;");
        stream.println(ind + "}"); 
      }
      if (grammar().incrementalLevelParam || grammar().incrementalLevelAttr) {
        stream.println(ind + "protected boolean ASTNode.inc_restoreInitialForIndex(int index, ASTNode$DepGraphNode h) {");
        stream.println(ind(2) + "if (init_children != null && index < init_children.length " + 
                                                  "&& init_children[index] != null) {");
        stream.println(ind(3) + "ASTNode oldNode = children[index];");
        stream.println(ind(3) + "state().enterConstruction();");
        stream.println(ind(3) + "setChild(init_children[index], index);");
        stream.println(ind(3) + "state().exitConstruction();");
        stream.println(ind(3) + "oldNode.inc_flush_subtree(h);");
        stream.println(ind(3) + "init_children[index] = null;");
        stream.println(ind(3) + "return true;");
        stream.println(ind(2) + "}");
        stream.println(ind(2) + "return false;");
        stream.println(ind + "}"); 

      }
      // end method: inc_restoreInitialForIndex

      // method: inc_locateInitialCopy
      stream.println(ind + "protected ASTNode ASTNode.inc_locateInitialCopy() {");
      // locate enclosing rewrite
      stream.println(ind(2) + "ASTNode child = this;");
      stream.println(ind(2) + "ASTNode parent = getParent();");
      stream.println(ind(2) + "java.util.LinkedList indexList = new java.util.LinkedList();");
      stream.println(ind(2) + "while (parent != null) {");
      stream.println(ind(3) +   "int index = child.childIndex;");
      stream.println(ind(3) +   "indexList.addFirst(new Integer(index));");
      stream.println(ind(3) +   "if (parent.init_children != null && index >= 0 && " +
                                "index < parent.init_children.length && parent.init_children[index] != null) {");
      // stream.println(ind(3) +   "if (parent.is$Final() != child.is$Final()) {");
      stream.println(ind(4) +     "break;");
      stream.println(ind(3) +   "}");
      stream.println(ind(3) +   "child = parent;");
      stream.println(ind(3) +   "parent = child.getParent();");
      stream.println(ind(2) + "}");
      // root reached -- no enclosing rewrite
      stream.println(ind(2) + "if (parent == null) {");
      stream.println(ind(3) +   "return null;");
      stream.println(ind(2) + "}");
      // root not reached -- enclosing rewrite found
      stream.println(ind(2) + "boolean first = true;");
      stream.println(ind(2) + "for (java.util.Iterator itr = indexList.iterator(); itr.hasNext();) {");
      stream.println(ind(3) +   "int index = ((Integer)itr.next()).intValue();");
      stream.println(ind(3) +   "if (first) {");
      stream.println(ind(4) +     "first = false;");
      stream.println(ind(4) +     "child = parent.init_children[index];");
      stream.println(ind(4) +     "parent = child;");
      stream.println(ind(3) +   "} else if (index < parent.getNumChildNoTransform()) {");
      stream.println(ind(4) +     "child = parent.getChildNoTransform(index);");
      stream.println(ind(4) +     "parent = child;");
      stream.println(ind(3) +   "} else return null;");
      // stream.println(ind(3) +   "child = parent.getChildNoTransform(index);");
      // stream.println(ind(3) +   "parent = child;");
      // stream.println(ind(3) +   "if (child == null) {");
      // stream.println(ind(4) +     "throw new RuntimeException(\"Incremental tree modification error: " + 
      //                                        "premature end of change point path\");");
      // stream.println(ind(3) +   "}");
      stream.println(ind(2) + "}");
      // initial change point found
      stream.println(ind(2) + "return child;");      
      stream.println(ind + "}"); // end method: inc_locateInitialCopy
    }
  }

}
