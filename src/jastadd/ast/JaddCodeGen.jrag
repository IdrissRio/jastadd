/* Copyright (c) 2005-2013, The JastAdd Team
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Lund University nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
import ast.AST.*;

import java.io.*;
import java.util.*;
import java.util.regex.*;

aspect JaddCodeGen {
  public void Grammar.abstractAncestors() {
    ASTDecl cl;
    IdDecl name;
    
    // Add ASTNode
    cl = new ASTDecl();
    name = new IdDecl();
    name.setID("ASTNode");
    cl.setIdDecl(name);
    cl.setFileName("");
    addTypeDecl(cl);
    
    // Add List
    cl = new ASTDecl();
    name = new IdDecl();
    name.setID("List");
    cl.setIdDecl(name);
    cl.setFileName("");
    addTypeDecl(cl);

    // Add Opt
    cl = new ASTDecl();
    name = new IdDecl();
    name.setID("Opt");
    cl.setIdDecl(name);
    cl.setFileName("");
    addTypeDecl(cl);
  }

  syn int ASTDecl.numNonNTAComponents() {
    int num = 0;
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(!c.isNTA()) {
        num++;
      }
    }
    return num;
  }

  /**
   * Number of children, including NTAs but excluding tokens
   */
  syn int ASTDecl.childCount() {
    int i = 0;
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(!(c instanceof TokenComponent)) {
        i++;
      }
    }
    return i;
  }

  /**
   * Number of children, excluding NTAs and tokens
   */
  syn int ASTDecl.numRegularChildren() {
    int i = 0;
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(!c.isNTA() && !(c instanceof TokenComponent)) {
        i++;
      }
    }
    return i;
  }

  /**
   * Default constructor: creates list and opt nodes for
   * all list and opt children. Initializes NTAs.
   */
  public void ASTDecl.emitDefaultConstructor(PrintWriter out) {

    TemplateContext tt = templateContext();

    String finalInit = "";
    if(grammar().rewriteEnabled && isRootNode()) {
      if(grammar().stagedRewrites)
        finalInit = "is$Final(state().rewritePhase);";
      else
        finalInit = "is$Final(true);";
    }

    tt.bind("FinalInit", finalInit);

    if (isASTNode()) {
      tt.bind("InitChildren", "init$Children();");
    } else {
      tt.bind("InitChildren", "");
    }

    if (grammar().jjtree) {
      tt.bind("ParserName", grammar().parserName);
      tt.expand("ast.constructor.default:jjtree", out);
    } else {
      tt.expand("ast.constructor.default", out);
    }
  }

  /**
   * Emits the (nta) child initialization method
   */
  public void ASTDecl.emitChildInitMethod(PrintWriter out) {
    TemplateContext tt = templateContext();

    String initChildArray = "";
    if (childCount() > 0) {
      initChildArray = "children = new ASTNode[" + childCount() + "];";
      initChildArray += genIncrementalInitChildHandlers();
    }
    
    tt.bind("InitChildArray", initChildArray);

    StringBuffer childInit = new StringBuffer();
    childInit.append(genIncrementalConstructorStartConstruction());
    int i = 0;
    for (Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(c instanceof ListComponents) {
        childInit.append("setChild(new List(), " + i + ");\n");
        i++;
      } else if(c instanceof OptionalComponent) {
        childInit.append("setChild(new Opt(), " + i + ");\n");
        i++;
      } else if(c instanceof AggregateComponents) {
        i++;
      }
    }
    childInit.append(genIncrementalConstructorEndConstruction());

    tt.bind("ChildInit", childInit.toString());
    tt.expand("initChildren", out);
  }

  /**
   * Emits the constructor body for tree building constructors
   */
  public void ASTDecl.emitBuildingConstructorBody(PrintWriter out) {
    if(grammar().block) out.print(grammar().blockBegin);
      
    out.print(genIncrementalConstructorStartConstruction());
    
    int param = 0;
    int childIndex = 0;
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(!c.isNTA()) {
        if(c instanceof TokenComponent) {
          TokenComponent t = (TokenComponent)c;
          String tokenId = t.getTokenId().getID();
          out.println(ind(2) + "set" + tokenId + "(p" + param + ");");
        }
        else {
          out.println(ind(2) + "setChild(p" + param + ", " + childIndex + ");");
          childIndex++;
        }
        param += 1;
      } else {
        if(c instanceof ListComponents ||
          c instanceof OptionalComponent ||
          c instanceof AggregateComponents) {
        childIndex++;
        }
      }
    }
    if(grammar().rewriteEnabled && isRootNode()) {
      if(grammar().stagedRewrites)
        out.println(ind(2) + "is$Final(java.lang.Integer.MAX_VALUE);");
      else
        out.println(ind(2) + "is$Final(true);");
    }

    out.print(genIncrementalConstructorEndConstruction());
    out.print(genIncrementalTrackCreation());

    if(grammar().block) out.print(grammar().blockEnd);
  }

  /**
   * Constructor to build trees bottom up
   */
  public void ASTDecl.emitBuildingConstructor(PrintWriter out) {
    // we only build constructors if there are components
    if(!getComponents().hasNext())
      return;
    out.print(ind + "public " + name() + "." + name() + "(");
    int i = 0; // parameter index
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(!c.isNTA()) {
        if(i != 0) out.print(", ");
        out.print(c.constrParmType() + " p" + i);
        i++;
      }
    }
    out.println(") {");
    emitBuildingConstructorBody(out);
    out.println(ind + "}");
  }

  public void ASTDecl.emitSymbolConstructor(PrintWriter out) {
    // we only build constructors if there are components ...
    if(!getComponents().hasNext())
      return;
    // ... and one of these components is a string token component
    boolean stringArg = false;
    for(Iterator iter = getComponents(); !stringArg && iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(!c.isNTA() && c instanceof TokenComponent && c.constrParmType().equals("String") || c.constrParmType().equals("java.lang.String"))
        stringArg = true;
    }
    if(!stringArg) return;

    out.print(ind + "public " + name() + "." + name() + "(");
    int i = 0; // parameter index
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(!c.isNTA()) {
        if(i != 0) out.print(", ");
        if(c instanceof TokenComponent && c.constrParmType().equals("String") || c.constrParmType().equals("java.lang.String"))
          out.print("beaver.Symbol p" + i);
        else
          out.print(c.constrParmType() + " p" + i);
        i++;
      }
    }
    out.println(") {");
    emitBuildingConstructorBody(out);
    out.println(ind + "}");
  }

  public void Grammar.genReset(PrintWriter out) {
    templateContext().expand("ASTNode$State.reset", out);
  }

  public void Grammar.jjtGenASTNode$State(PrintWriter out) {
    templateContext().expand("ASTNode$State", out);
  }

  /**
   * String for calculating the initial child array size.
   * List nodes use the minimum list size as the initial child
   * array size.
   */
  syn String ASTDecl.initialChildArraySize() {
    return "(i+1>" + grammar().minListSize + " || !(this instanceof List))?i+1:" + grammar().minListSize;
  }

  /**
   * Print the getChild method to the output stream.
   */
  public void ASTDecl.emitGetChild(PrintWriter stream) {
    String returnTypeCast;
    if(grammar().java5) {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel low-level");
      stream.println(ind + " */");
      stream.println(ind + "@SuppressWarnings(\"cast\") public T ASTNode.getChild(int i) {");
      returnTypeCast = "(T) ";
    }
    else {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel low-level");
      stream.println(ind + " */");
      stream.println(ind + "public ASTNode ASTNode.getChild(int i) {");
      returnTypeCast = "";
    }

    if(grammar().rewriteEnabled) {
      if(grammar().block) stream.print(grammar().blockBegin);
      stream.println(ind(2) + "ASTNode node = this.getChildNoTransform(i);");
      stream.println(ind(2) + "if(node == null) return null;");
      stream.println(ind(2) + "if(node.is$Final()) {");
      jjtGenIncrementalTrackRewrite4(stream);
      genIncrementalTrackRewrite12(stream);
      stream.println(ind(3) +   "return " + returnTypeCast + "node;");
      stream.println(ind(3) + "}");
      stream.println(ind(2) + "if(!node.mayHaveRewrite()) {");
      if(grammar().stagedRewrites) {
        stream.println(ind(3) + "node.is$Final(this.is$Final);");
      } else {
        stream.println(ind(3) + "node.is$Final(this.is$Final());");
      }
      jjtGenIncrementalTrackRewrite4(stream);
      genIncrementalTrackRewrite12(stream);
      stream.println(ind(3) + "return " + returnTypeCast + "node;");
      stream.println(ind(2) + "}");
      stream.println(ind(2) + "if(!node.in$Circle()) {");
      jjtGenIncrementalTrackRewrite1(stream);
      emitFlushRewritesInitialize(stream);
      emitFlushRewritesCheckAndStoreInitValue(stream);
      stream.println(ind(3) + "int rewriteState;");
      stream.println(ind(3) + "int num = this.state().boundariesCrossed;");
      stream.println(ind(3) + "do {");
      stream.println(ind(4) + "this.state().push(ASTNode$State.REWRITE_CHANGE);");
      stream.println(ind(4) + "ASTNode oldNode = node;");
      stream.println(ind(4) + "oldNode.in$Circle(true);");
      jjtGenIncrementalTrackRewrite5(stream);
      stream.println(ind(4) + "node = node.rewriteTo();");
      stream.println(ind(4) + "if(node != oldNode) {");
      jjtGenIncrementalTrackRewrite7(stream);
      stream.println(ind(5) + "this.setChild(node, i);");
      jjtGenIncrementalTrackRewrite8(stream);
      stream.println(ind(4) + "}");
      stream.println(ind(4) + "oldNode.in$Circle(false);");
      stream.println(ind(4) + "rewriteState = this.state().pop();");
      jjtGenIncrementalTrackRewrite3(stream);
      emitFlushRewritesChildRewritten(stream);
      jjtGenIncrementalTrackRewrite6(stream);
      stream.println(ind(3) + "} while(rewriteState == ASTNode$State.REWRITE_CHANGE);");
      stream.println(ind(3) + "if(rewriteState == ASTNode$State.REWRITE_NOCHANGE && this.is$Final()) {");
      if(grammar().stagedRewrites) {
        stream.println(ind(4) + "node.is$Final(this.state().rewritePhase);");
      } else {
        stream.println(ind(4) + "node.is$Final(true);");
      }
      stream.println(ind(4) + "this.state().boundariesCrossed = num;");
      if(grammar().rewriteLimit > 0) {
        stream.println(ind(4) + "node.debugRewriteRemove();");
      }
      stream.println(ind(3) + "}");
      jjtGenIncrementalTrackRewrite2(stream);
      stream.println(ind(2) + "}");
      stream.println(ind(2) + "else if(this.is$Final() != node.is$Final()) this.state().boundariesCrossed++;");
      jjtGenIncrementalTrackRewrite11(stream);
      genIncrementalTrackRewrite12(stream);
      stream.println(ind(2) + "return " + returnTypeCast + "node;");
      if(grammar().block) stream.print(grammar().blockEnd);
    } else {
      // No rewrites
      stream.println(ind(2) + "ASTNode child = getChildNoTransform(i);");
      jjtGenIncrementalTrackGetChildNoTransform(stream);
      stream.println(ind(2) + "return " + returnTypeCast + "child;");
    }

    stream.println(ind + "}");
  }

  public void ASTDecl.emitAddChild(PrintWriter out) {
    if(grammar().java5) {
      out.println(ind + "/**");
      out.println(ind + " * @apilevel low-level");
      out.println(ind + " */");
      out.println(ind + "public void ASTNode.addChild(T node) {");
    } else {
      out.println(ind + "/**");
      out.println(ind + " * @apilevel low-level");
      out.println(ind + " */");
      out.println(ind + "public void ASTNode.addChild(ASTNode node) {");
    }
    out.println(ind(2) + "setChild(node, getNumChildNoTransform());");
    jjtGenIncrementalASTChangeAddChild1(out); 
    out.println(ind + "}");
  }

  public void ASTDecl.emitGetChildNoTransform(PrintWriter out) {
    if(grammar().java5) {
      out.println(ind + "/**");
      out.println(ind + " * <p><em>This method does not invoke AST transformations.</em></p>");
      out.println(ind + " * @apilevel low-level");
      out.println(ind + " */");
      out.println(ind + "@SuppressWarnings(\"cast\")");
      
      // Must be able to override get child methods for incremental evaluation
      if (grammar().incremental) { 
        jjtGenIncrementalTrackGetChildNoTransformNameGeneric(out);
      } else { 
        out.println(ind + "public final T ASTNode.getChildNoTransform(int i) {");
      }
      
      if(grammar().block) out.print(grammar().blockBegin);
      out.println(ind(2) + "if (children == null) return null;");
      out.println(ind(2) + "T child = (T)children[i];");
      jjtGenIncrementalTrackGetChildNoTransform(out);
      out.println(ind(2) + "return child;");        
      if(grammar().block) out.print(grammar().blockEnd);
      out.println(ind + "}");
    } else {
      out.println(ind + "/**");
      out.println(ind + " * <p><em>This method does not invoke AST transformations.</em></p>");
      out.println(ind + " * @apilevel low-level");
      out.println(ind + " */");
      
      // Must be able to override get child methods for incremental evaluation
      if (grammar().incremental) {
        jjtGenIncrementalTrackGetChildNoTransformName(out);
      } else { 
        out.println(ind + "public final ASTNode ASTNode.getChildNoTransform(int i) {");
      }
      
      if(grammar().block) out.print(grammar().blockBegin);
      out.println(ind(2) + "if (children == null) return null;");
      out.println(ind(2) + "ASTNode child = (ASTNode)children[i];");
      jjtGenIncrementalTrackGetChildNoTransform(out);
      out.println(ind(2) + "return child;");        
      if(grammar().block) out.print(grammar().blockEnd);
      out.println(ind + "}");
    }
  }

  public void ASTDecl.emitNumChildren(PrintWriter stream) {
    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel low-level");
    stream.println(ind + " */");
    stream.println(ind + "protected int ASTNode.numChildren;"); // added
    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel low-level");
    stream.println(ind + " */");
    stream.println(ind + "protected int ASTNode.numChildren() {");
    jjtGenIncrementalTrackNumChild(stream);
    stream.println(ind(2) + "return numChildren;");
    stream.println(ind + "}");
    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel low-level");
    stream.println(ind + " */");
    stream.println(ind + "public int ASTNode.getNumChild() {");
    if(grammar().block) stream.print(grammar().blockBegin);
    jjtGenIncrementalTrackNumChild(stream);
    stream.println(ind(2) + "return numChildren();");
    if(grammar().block) stream.print(grammar().blockEnd);
    stream.println(ind + "}");
    stream.println(ind + "/**");
    stream.println(ind + " * <p><em>This method does not invoke AST transformations.</em></p>");
    stream.println(ind + " * @apilevel low-level");
    stream.println(ind + " */");
    stream.println(ind + "public final int ASTNode.getNumChildNoTransform() {");
    if(grammar().block) stream.print(grammar().blockBegin);
    stream.println(ind(2) + "return numChildren();");
    if(grammar().block) stream.print(grammar().blockEnd);
    stream.println(ind + "}");
  }

  public void ASTDecl.emitSetChild(PrintWriter stream) {
    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel low-level");
    stream.println(ind + " */");
    stream.println(ind + "public void ASTNode.setChild(ASTNode node, int i) {");
    if(grammar().block) stream.print(grammar().blockBegin);
    if(grammar().debugMode) {
      stream.println(ind(2) + "debugNodeAttachment(node);");
    }
    jjtGenIncrementalASTChangeSetChild1(stream);
    stream.println(ind(2) + "if(children == null) {");
    stream.println(ind(3) + "children = new ASTNode[" + initialChildArraySize() + "];");
    jjtGenIncrementalASTChangeSetChild2(stream);
    stream.println(ind(2) + "} else if (i >= children.length) {");
    stream.println(ind(3) + "ASTNode c[] = new ASTNode[i << 1];");
    stream.println(ind(3) + "System.arraycopy(children, 0, c, 0, children.length);");
    stream.println(ind(3) + "children = c;");
    jjtGenIncrementalASTChangeSetChild3(stream);
    emitFlushRewritesSetChildCopyState(stream);
    stream.println(ind(2) + "}");
    jjtGenIncrementalASTChangeSetChild5(stream);
    stream.println(ind(2) + "children[i] = node;");
    stream.println(ind(2) + "if(i >= numChildren) numChildren = i+1;");
    stream.println(ind(2) + "if(node != null) { node.setParent(this); node.childIndex = i; }");
    jjtGenIncrementalASTChangeSetChild4(stream);
    emitFlushRewritesSetChildInitState(stream);
    if(grammar().block) stream.print(grammar().blockEnd);
    stream.println(ind + "}");
  }

  public void ASTDecl.emitInsertChild(PrintWriter stream) {
    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel low-level");
    stream.println(ind + " */");
    stream.println(ind + "public void ASTNode.insertChild(ASTNode node, int i) {");
    if(grammar().block) stream.print(grammar().blockBegin);
    if(grammar().debugMode) {
      stream.println(ind(2) + "debugNodeAttachment(node);");
    }
    jjtGenIncrementalASTChangeInsertChild3(stream);
    stream.println(ind(2) + "if(children == null) {");
    stream.println(ind(3) + "children = new ASTNode[" + initialChildArraySize() + "];");
    stream.println(ind(3) + "children[i] = node;");
    jjtGenIncrementalASTChangeInsertChild1(stream);
    stream.println(ind(2) + "} else {");
    stream.println(ind(3) + "ASTNode c[] = new ASTNode[children.length + 1];");
    stream.println(ind(3) + "System.arraycopy(children, 0, c, 0, i);");
    stream.println(ind(3) + "c[i] = node;");
    stream.println(ind(3) + "if(i < children.length) {");
    stream.println(ind(4) + "System.arraycopy(children, i, c, i+1, children.length-i);");
    stream.println(ind(4) + "for(int j = i+1; j < c.length; ++j) {");
    stream.println(ind(5) +   "if(c[j] != null)");
    stream.println(ind(6) +     "c[j].childIndex = j;");
    stream.println(ind(4) +   "}");
    stream.println(ind(3) + "}");
    stream.println(ind(3) + "children = c;");
    jjtGenIncrementalASTChangeInsertChild2(stream);
    emitFlushRewritesInsertChildUpdateState(stream);
    stream.println(ind(2) + "}");
    stream.println(ind(2) + "numChildren++;");
    stream.println(ind(2) + "if(node != null) { node.setParent(this); node.childIndex = i; }");
    if(grammar().block) stream.print(grammar().blockEnd);
    stream.println(ind + "}");
  }

  public void ASTDecl.emitRemoveChild(PrintWriter stream) {
    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel low-level");
    stream.println(ind + " */");
    stream.println(ind + "public void ASTNode.removeChild(int i) {");
    if(grammar().block) stream.print(grammar().blockBegin);
    stream.println(ind(2) + "if(children != null) {");
    jjtGenIncrementalASTChangeRemoveChild1(stream);
    stream.println(ind(3) + "ASTNode child = (ASTNode)children[i];");
    stream.println(ind(3) + "if(child != null) {");
    jjtGenIncrementalASTChangeRemoveChild3(stream); 
    stream.println(ind(4) + "child.parent = null;");
    stream.println(ind(4) + "child.childIndex = -1;");
    stream.println(ind(3) + "}");
    // ES_2012-03-01: Adding a check of this instance to make sure its a List, a move of children doesn't make
    // any sense for a node unless its a list. Also, there is a problem if a child of a non-List node is removed
    // and siblings are moved one step to the right, with null at the end.
    stream.println(ind(3) + "if (this instanceof List || this instanceof Opt) {");
    stream.println(ind(4) +   "System.arraycopy(children, i+1, children, i, children.length-i-1);");
    stream.println(ind(4) +   "children[children.length-1] = null;");
    stream.println(ind(4) +   "numChildren--;");
    // fix child indices
    stream.println(ind(4) +   "for(int j = i; j < numChildren; ++j) {");
    stream.println(ind(5) +     "if(children[j] != null) {");
    stream.println(ind(6) +       "child = (ASTNode) children[j];");
    stream.println(ind(6) +       "child.childIndex = j;");
    stream.println(ind(5) +     "}");
    stream.println(ind(4) +   "}");
    stream.println(ind(3) + "} else {");
    stream.println(ind(4) +   "children[i] = null;");
    stream.println(ind(3) + "}");
    jjtGenIncrementalASTChangeRemoveChild2(stream);
    emitFlushRewritesRemoveChild(stream);
    stream.println(ind(2) + "}");
    if(grammar().block) stream.print(grammar().blockEnd);
    stream.println(ind + "}");
  }

  public void ASTDecl.emitSetGetParent(PrintWriter out) {
    TemplateContext tt = templateContext();  
    tt.bind("IsRegionRoot", isRegionRoot());  
    tt.expand("ASTNode.getParent", out);
    tt.expand("ASTNode.setParent", out);
  }

  public void ASTDecl.jjtGenASTNode(PrintWriter stream) {
    TemplateContext tt = templateContext();
    tt.expand("ASTNode.declarations", stream);

    if(grammar().noStatic) {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "protected ASTNode$State ASTNode.state = null;");
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "public final ASTNode$State ASTNode.state() {");
      stream.println(ind(2) + "if(state == null) {");
      stream.println(ind(3) + "if(parent == null) {");
      stream.println(ind(4) + "state = new ASTNode$State();");
      if(grammar().debugMode) {
        // Debug mode should (probably) not be used here to ensure safe use of the state field
        //  Jesper 2013-01-10

        // Check if a new state object is created for a node that is not a root node
        StringBuffer s = new StringBuffer();
        s.append("if(");
        boolean first = true;
        for(Iterator iter = env().roots().iterator(); iter.hasNext(); ) {
          ASTDecl root = (ASTDecl)iter.next();
          if(!first)
            s.append(" && ");
          first = false;
          s.append("!(this instanceof " + root.name() + ")");
        }
        s.append(") throw new RuntimeException(\"Trying to evaluate state in a node which is not attached to the main tree\");");
        stream.println(s.toString());
      }
      stream.println(ind(3) + "}");
      stream.println(ind(3) + "else {");
      stream.println(ind(4) + "state = parent.state();");
      stream.println(ind(3) + "}");
      stream.println(ind(2) + "}");
      stream.println(ind(2) + "return state;");
      stream.println(ind + "}");
    }

    emitGetChild(stream);

    emitAddChild(stream);

    emitGetChildNoTransform(stream);

    emitNumChildren(stream);

    emitSetChild(stream);

    emitInsertChild(stream);

    emitRemoveChild(stream);

    emitSetGetParent(stream);

    tt.expand("ASTNode.debugDecls", stream);
  }

  public void ASTDecl.genCheckTreeStructure(PrintWriter stream) {
    stream.println(ind + "public void " + name() + ".jjtAddChild(Node n, int i) {");
    stream.println(ind(2) + "checkChild(n, i);");
    if(name().equals("ASTNode")) {
      stream.println(ind(2) + "if(i >= numChildren) numChildren = i+1;");
    }
    stream.println(ind(2) + "super.jjtAddChild(n, i);");
    stream.println("}\n");
    if(name().equals("Opt")) {
      stream.println(ind + "public void Opt.checkChild(Node n, int i) {");
      stream.println(ind(2) + "if(i > 0) throw new Error(\"Optional nodes can only have one child\");");
      stream.println(ind(2) + "if(!(n instanceof ASTNode)) throw new Error(\"Node type must be an instance of ASTNode\");");
      stream.println(ind + "}\n");
    }
    else if(name().equals("List")) {
      stream.println(ind + "public void List.checkChild(Node n, int i) {");
      stream.println(ind(2) + "if(!(n instanceof ASTNode)) throw new Error(\"The node type of child \" + i + \" must be an instance of ASTNode\");");
      stream.println(ind + "}\n");
    }
    else {
      int j = 0;
      stream.println(ind + "public void " + name() + ".checkChild(Node n, int i) {");
      for(Iterator iter = getComponents(); iter.hasNext(); ) {
        Components c = (Components)iter.next();
        c.genCheckTreeStructure(stream, j);
        if(!(c instanceof TokenComponent)) {
          j++;
        }
      }
      stream.println(ind + "}\n");
    }
  }

  public void Components.genCheckTreeStructure(PrintWriter stream, int j) {
  }

  public void ListComponents.genCheckTreeStructure(PrintWriter stream, int j) {
    TemplateContext tt = templateContext();
    tt.bind("ChildIndex", "" + j);
    tt.bind("HostClassName", hostClass().name());
    tt.expand("ListComponents.genCheckTreeStructure", stream);
  }

  public void OptionalComponent.genCheckTreeStructure(PrintWriter stream, int j) {
    TemplateContext tt = templateContext();
    tt.bind("ChildIndex", "" + j);
    tt.bind("HostClassName", hostClass().name());
    tt.expand("OptionalComponent.genCheckTreeStructure", stream);
  }

  public void AggregateComponents.genCheckTreeStructure(PrintWriter stream, int j) {
    TemplateContext tt = templateContext();
    tt.bind("ChildIndex", "" + j);
    tt.bind("HostClassName", hostClass().name());
    tt.expand("AggregateComponents.genCheckTreeStructure", stream);
  }

  public void ASTDecl.jjtGenDumpTree(PrintWriter stream) {
    stream.println(ind + "public void " + name() + ".dumpTree(String indent, java.io.PrintStream pStream) {");
    stream.print(ind(2) + "pStream.println(indent + \"" + name() + "\"");
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(c instanceof TokenComponent) {
        TokenComponent t = (TokenComponent)c;
        String id = t.getTokenId().getID();
        stream.print("+ \"\\\"\" + get" + id + "() + \"\\\"\"");
      }
    }
    stream.println(");");
    stream.println(ind(2) + "String childIndent = indent + \"  \";");
    stream.println(ind(2) + "for(int i = 0; i < getNumChild(); i++)");
    stream.println(ind(3) +   "getChild(i).dumpTree(childIndent, pStream);");
    stream.println(ind    + "}");
  }

  public void ASTDecl.jjtGenVisitor(PrintWriter stream) {
    stream.println(ind + "public Object " + name() + ".jjtAccept(" + grammar().parserName + "Visitor visitor, Object data) {");
    stream.println(ind(2) + "return visitor.visit(this, data);");
    stream.println(ind + "}");
  }

  public void ASTDecl.jjtGenConstructor(PrintWriter out) {

    emitDefaultConstructor(out);

    emitChildInitMethod(out);

    if(numNonNTAComponents() != 0) {
      emitBuildingConstructor(out);
      if(grammar().beaver)
        emitSymbolConstructor(out);
    }

    if(name().equals("Opt")) {
      if(grammar().java5)
        out.println(ind + "public Opt.Opt(T opt) {");
      else
        out.println(ind + "public Opt.Opt(ASTNode opt) {");  
      out.println(ind(2) + genIncrementalConstructorStartConstruction());
      out.println(ind(2) + "setChild(opt, 0);");
      out.println(ind(2) + genIncrementalConstructorEndConstruction());
      out.println(ind + "}\n");
    }
  }

  public void ASTDecl.jjtGen(PrintWriter stream) {
    String s;

    jjtGenConstructor(stream);
    //emitCloneNode(stream);
    //emitCopyNode(stream);
    //emitFullCopy(stream);
    //emitFlushCache(stream);
    if(grammar().jjtree) {
      jjtGenDumpTree(stream);
      jjtGenVisitor(stream);
      try {
        genCheckTreeStructure(stream);
      } catch (Exception e) {
        e.printStackTrace();
      }
    }

    // Generate code common for all nodes by adding them to ASTNode
    if(name().equals("ASTNode")) {
      jjtGenASTNode(stream);
      env().genRewriteOrderChecks(stream);
      env().genReset(stream);
      if(grammar().java5) {
        templateContext().expand("ASTNode.iterator", stream);
      }
    }
    else if(name().equals("List")) {
      if(grammar().java5)
        stream.println(ind + "public List<T> List.add(T node) {");
      else
        stream.println(ind + "public List List.add(ASTNode node) {");
      if(grammar().block) stream.append(grammar().blockBegin);
      if(grammar().debugMode) {
        stream.println(ind(2) + "if(node instanceof List)");
        stream.println(ind(3) + "throw new RuntimeException(\"Lists can not have children of type List\");");
        stream.println(ind(2) + "if(node instanceof Opt)");
        stream.println(ind(3) + "throw new RuntimeException(\"Lists can not have children of type Opt\");");
      }
      stream.println(ind(2) + "addChild(node);");
      stream.println(ind(2) + "return this;");
      if(grammar().block) stream.append(grammar().blockEnd);
      stream.println(ind + "}\n");
      stream.println(ind + "public void List.insertChild(ASTNode node, int i) {");
      if(grammar().block) stream.append(grammar().blockBegin);
      
      // Avoiding list touch rewrite
      if (!(grammar().incremental || grammar().fullFlush)) { 
        stream.println(ind(2) + "list$touched = true;");
      }
      
      stream.println(ind(2) + "super.insertChild(node, i);");
      if(grammar().block) stream.append(grammar().blockEnd);
      stream.println(ind + "}");
      if(grammar().java5)
        stream.println(ind + "public void List.addChild(T node) {");
      else
        stream.println(ind + "public void List.addChild(ASTNode node) {");
      if(grammar().block) stream.append(grammar().blockBegin);
      
      // Avoiding list touch rewrite
      if (!(grammar().incremental || grammar().fullFlush)) { 
        stream.println(ind(2) + "list$touched = true;");
      }
      
      stream.println(ind(2) + "super.addChild(node);");
      if(grammar().block) stream.append(grammar().blockEnd);
      stream.println(ind + "}");
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel low-level");
      stream.println(ind + " */");
      stream.println(ind + "public void List.removeChild(int i) {");
      if(grammar().block) stream.append(grammar().blockBegin);
      
      // Avoiding list touch rewrite
      if (!(grammar().incremental || grammar().fullFlush)) { 
        stream.println(ind(2) + "list$touched = true;");
      }
      
      stream.println(ind(2) + "super.removeChild(i);");
      if(grammar().block) stream.append(grammar().blockEnd);
      stream.println(ind + "}");
      stream.println(ind + "public int List.getNumChild() {");
      if(grammar().block) stream.append(grammar().blockBegin);
      
      // Avoiding list touch rewrite
      if (!(grammar().incremental || grammar().fullFlush)) {
        stream.println(ind(2) + "if(list$touched) {");
        stream.println(ind(3) + "for(int i = 0; i < getNumChildNoTransform(); i++)");
        stream.println(ind(4) + "getChild(i);");
        stream.println(ind(4) + "list$touched = false;");
        stream.println(ind(3) + "}");
      } 
      
      stream.println(ind(3) + "return getNumChildNoTransform();");
      if(grammar().block) stream.append(grammar().blockEnd);
      stream.println(ind + "}");
      
      // Avoiding list touch rewrite
      if (!(grammar().incremental || grammar().fullFlush)) { 
        stream.println(ind + "private boolean List.list$touched = true;");
      }
    }
    else if(name().equals("Opt")) {
      // do not override getNumChild with implementation below
    }
    else {

      if(grammar().jjtree) {
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel low-level");
        stream.println(ind + " */");
        stream.println(ind + "public int " + name() + ".getNumChild() {");
        jjtGenIncrementalTrackNumChild(stream); 
        stream.println(ind(2) + "return " + numRegularChildren() + ";");
        stream.println(ind + "}");
      }
      else {
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel low-level");
        stream.println(ind + " */");
        stream.println(ind + "protected int " +name() + ".numChildren() {");
        jjtGenIncrementalTrackNumChild(stream);
        stream.println(ind(2) + "return " + numRegularChildren() + ";");
        stream.println(ind + "}");
      }
      if(grammar().debugMode && isRootNode()) {
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel internal");
        stream.println(ind + " */");
        stream.println(ind + "protected boolean " + name() + ".debugNodeAttachmentIsRoot() { return true; }");
      }
    }
    if(grammar().rewriteEnabled) {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "public boolean " + name() + ".mayHaveRewrite() {");
      if(name().equals("List")) {
        
        // Avoiding list touch rewrite
        if (!(grammar().incremental || grammar().fullFlush)) {
          stream.println(ind(2) + "return true;");  // old code
        } else {
          stream.println(ind(2) + "return false;");
        }
        
      } else if(!hasRewrites())
        stream.println(ind(2) + "return false;");
      else if(!grammar().stagedRewrites || rewriteWithNoPhaseCondition())
        stream.println(ind(2) + "return true;");
      else {
        for(Iterator iter = rewritePhaseConditions().iterator(); iter.hasNext(); ) {
          String condition = (String)iter.next();
          stream.println(ind(2) + "if(" + condition + ") return true;");
        }
        stream.println(ind(2) + "return false;");
      }
      stream.println(ind + "}");
    }

    genIncremental(stream);
  }

  syn boolean ASTDecl.rewriteWithNoPhaseCondition() {
    for(int i = 0; i < getNumRewrite(); i++) {
      if(getRewrite(i).getCondition() == null)
        return true;
      String condition = Unparser.unparse(getRewrite(i).getCondition());
      if(condition.indexOf("inRewritePhase") == -1 && condition.indexOf("inExactRewritePhase") == -1)
        return true;
    }
    return superClass() instanceof ASTDecl && ((ASTDecl)superClass()).rewriteWithNoPhaseCondition();
  }

  syn java.util.Set ASTDecl.rewritePhaseConditions() {
    java.util.Set set = new java.util.LinkedHashSet();
    Pattern p = Pattern.compile("inRewritePhase\\([\\w\\.]*\\)|inExactRewritePhase\\([\\w\\.]*\\)");
    for(int i = 0; i < getNumRewrite(); i++) {
      if(getRewrite(i).getCondition() != null) {
        String condition = Unparser.unparse(getRewrite(i).getCondition());
        Matcher m = p.matcher(condition);
        while(m.find()) {
          String match = m.group();
          set.add(match);
        }
      }
    }
    if(superClass() instanceof ASTDecl)
      set.addAll(((ASTDecl)superClass()).rewritePhaseConditions());
    return set;
  }

  public abstract void Components.jaddGen(int index, boolean publicModifier, ASTDecl decl);

  syn String ListComponents.annotations() = suppressWarnings();

  public void ListComponents.jaddGen(int index, boolean publicModifier, ASTDecl decl) {
    TemplateContext tt = templateContext();
    tt.bind("ListType", grammar().java5 ? "List<" + getId().type() + ">" : "List");
    tt.bind("Type", getId().type());
    tt.bind("Name", getId().name());
    tt.bind("Index", String.valueOf(index));
    tt.bind("Host", decl.name());
    tt.bind("Modifier", publicModifier ? "public" : "private");

    String name = decl.name();
    String s =
      tt.expand("ListComponent.setList") +
      tt.expand("ListComponent.getNumChild") +
      tt.expand("ListComponent.getNumChildNoTransform") +
      tt.expand("ListComponent.getChildAt") +
      tt.expand("ListComponent.addChild") +
      tt.expand("ListComponent.addChildNoTransform") +
      tt.expand("ListComponent.setChild") +
      tt.expand("ListComponent.getList1") +
      tt.expand("ListComponent.getList1NoTransform") +
      tt.expand("ListComponent.getList2") +
      tt.expand("ListComponent.getList2NoTransform") +
      tt.expand("ListComponent.getListChildPosition");
    parse(s);
  }

  syn String OptionalComponent.annotations() = suppressWarnings();

  public void OptionalComponent.jaddGen(int index, boolean publicModifier, ASTDecl decl) {
    TemplateContext tt = templateContext();
    tt.bind("OptType", grammar().java5 ? "Opt<" + getId().type() + ">" : "Opt");
    tt.bind("Type", getId().type());
    tt.bind("Name", getId().name());
    tt.bind("Index", String.valueOf(index));
    tt.bind("Host", decl.name());
    tt.bind("Modifier", publicModifier ? "public" : "private");

    String s =
      tt.expand("OptionalComponent.setOpt1") +
      tt.expand("OptionalComponent.setOpt2") +
      tt.expand("OptionalComponent.hasOpt") +
      tt.expand("OptionalComponent.getOpt1") +
      tt.expand("OptionalComponent.getOpt2") +
      tt.expand("OptionalComponent.getOptNoTransform") +
      tt.expand("OptionalComponent.getOptChildPosition");
    parse(s);
  }


  String TokenComponent.setIDComment() {
    return ind + "/**\n" +
      ind + " * Replaces the lexeme #ID#.\n" +
      ind + " * @param value The new value for the lexeme #ID#.\n" +
      ind + " * @apilevel high-level\n" +
      ind + " */\n";
  }
  String TokenComponent.getIDComment() {
    return ind + "/**\n" +
      ind + " * Retrieves the value for the lexeme #ID#.\n" +
      ind + " * @return The value for the lexeme #ID#.\n" +
      ind + " * @apilevel high-level\n" +
      ind + " */\n";
  }
  private boolean TokenComponent.called = false;
  public void TokenComponent.jaddGen(int index, boolean publicModifier, ASTDecl decl) {
    String name = decl.name();
    StringBuffer buf = new StringBuffer();
    // Generate attribute, get- and set-method for the token string
    buf.append(setIDComment());
    buf.append(
        genIncrementalTokenHandler(decl) +
        ind + "public void #HOST#.set#ID#(#TYPE# value) {\n" +
        (grammar().block ? grammar().blockBegin : "") +
        ind(2) + "token#TYPEINSIGNATURE#_#ID# = value;\n" +
        jaddGenIncrementalTokenChange("value") +
        (grammar().block ? grammar().blockEnd : "") +
        ind + "}\n"
        );
    if(decl.redefinesTokenComponent(this)) {
      buf.append(ind + "/**\n");
      buf.append(ind + " * @apilevel internal\n");
      buf.append(ind + " */\n");
      buf.append(ind + "protected #TYPE# #HOST#.token#TYPEINSIGNATURE#_#ID#;\n");
    }
    if(!isNTA()) {
      boolean isStringToken = getTokenId().getTYPE().equals("String") || getTokenId().getTYPE().equals("java.lang.String");
      if(isStringToken && grammar().beaver) {
        if(decl.redefinesTokenComponent(this)) {
          buf.append(
              ind + "public int #HOST#.#ID#start;\n" +
              ind + "public int #HOST#.#ID#end;\n"
              );
        }
        buf.append(
            ind + "/**\n" +
            ind + " * JastAdd-internal setter for lexeme #ID# using the Beaver parser.\n" +
            ind + " * @apilevel internal\n" +
            ind + " */\n" +
            ind + "public void #HOST#.set#ID#(beaver.Symbol symbol) {\n" +
            (grammar().block ? grammar().blockBegin : "") +
            ind(2) + "if(symbol.value != null && !(symbol.value instanceof String))\n" +
            ind(3) + "throw new UnsupportedOperationException(\"set#ID# is only valid for String lexemes\");\n" +
            ind(2) + "token#TYPEINSIGNATURE#_#ID# = (String)symbol.value;\n" +
            ind(2) + "#ID#start = symbol.getStart();\n" +
            ind(2) + "#ID#end = symbol.getEnd();\n" +
            jaddGenIncrementalTokenChange("symbol") + 
            (grammar().block ? grammar().blockEnd : "") +
            ind + "}\n"
            );
      }
      if(isStringToken)
        buf.append(
            getIDComment() +
            ind + "public #TYPE# #HOST#.get#ID#() {\n" +
            (grammar().block ? grammar().blockBegin : "") +
            jaddGenIncrementalTokenTrack() +
            ind(2) + "return token#TYPEINSIGNATURE#_#ID# != null ? token#TYPEINSIGNATURE#_#ID# : \"\";\n" +
            (grammar().block ? grammar().blockEnd : "") +
            ind + "}\n");
      else
        buf.append(
            getIDComment() +
            ind + "public #TYPE# #HOST#.get#ID#() {\n" +
            (grammar().block ? grammar().blockBegin : "") +
            jaddGenIncrementalTokenTrack() +
            ind(2) + "return token#TYPEINSIGNATURE#_#ID#;\n" +
            (grammar().block ? grammar().blockEnd : "") +
            ind + "}\n");
    }
    String s = buf.toString();
    s = s.replaceAll("#ID#", getTokenId().getID());
    s = s.replaceAll("#TYPE#", getTokenId().getTYPE());
    s = s.replaceAll("#TYPEINSIGNATURE#", ASTNode.convTypeNameToSignature(getTokenId().getTYPE()));
    s = s.replaceAll("#HOST#", name);
    if(!publicModifier)
      s = s.replaceAll(ind + "public ", ind + "private ");
    //stream.println(s);
    parse(s);

  }

  public void AggregateComponents.jaddGen(int index, boolean publicModifier, ASTDecl decl) {
    String name = decl.name();
    String s;
    // Generate get-method for component
    s =
      ind + "/**\n" +
      ind + " * Replaces the #NAME# child.\n" +
      ind + " * @param node The new node to replace the #NAME# child.\n" +
      ind + " * @apilevel high-level\n" +
      ind + " */\n" +
      ind + "public void #HOST#.set#NAME#(#TYPE# node) {\n" + 
      (grammar().block ? grammar().blockBegin : "") +
      ind(2) + genIncrementalConstructorStartConstruction() +
      ind(2) + "setChild(node, #INDEX#);\n" + 
      ind(2) + genIncrementalConstructorEndConstruction() +
      (grammar().block ? grammar().blockEnd : "") +
      ind + "}\n";
    if(!isNTA()) {
      s +=
        ind + "/**\n" +
        ind + " * Retrieves the #NAME# child.\n" +
        ind + " * @return The current node used as the #NAME# child.\n" +
        ind + " * @apilevel high-level\n" +
        ind + " */\n" +
        ind + "public #TYPE# #HOST#.get#NAME#() {\n" +
        (grammar().block ? grammar().blockBegin : "") +
        ind(2) + "return (#TYPE#)getChild(#INDEX#);\n" + 
        (grammar().block ? grammar().blockEnd : "") +
        ind + "}\n" + 
        ind + "/**\n" +
        ind + " * Retrieves the #NAME# child.\n" +
        ind + " * <p><em>This method does not invoke AST transformations.</em></p>\n" +
        ind + " * @return The current node used as the #NAME# child.\n" +
        ind + " * @apilevel low-level\n" +
        ind + " */\n" +
        ind + "public #TYPE# #HOST#.get#NAME#NoTransform() {\n" +
        (grammar().block ? grammar().blockBegin : "") +
        ind(2) + "return (#TYPE#)getChildNoTransform(#INDEX#);\n" + 
        (grammar().block ? grammar().blockEnd : "") +
        ind + "}\n";
    }
    else {
      s +=
        ind + "/**\n" +
        ind + " * Retrieves the #NAME# child.\n" +
        ind + " * <p><em>This method does not invoke AST transformations.</em></p>\n" +
        ind + " * @return The current node used as the #NAME# child.\n" +
        ind + " * @apilevel low-level\n" +
        ind + " */\n" +
        ind + "public #TYPE# #HOST#.get#NAME#NoTransform() {\n" +
        (grammar().block ? grammar().blockBegin : "") +
        ind(2) + "return (#TYPE#)getChildNoTransform(#INDEX#);\n" + 
        (grammar().block ? grammar().blockEnd : "") +
        ind + "}\n" +
        ind + "/**\n" +
        ind + " * Retrieves the child position of the optional child #NAME#.\n" +
        ind + " * @return The the child position of the optional child #NAME#.\n" +
        ind + " * @apilevel low-level\n" +
        ind + " */\n" +
        ind + "protected int #HOST#.get#NAME#ChildPosition() {\n" +
        ind(2) + "return #INDEX#;\n" +
        ind + "}\n";
    }
    s = s.replaceAll("#TYPE#", getId().type());
    s = s.replaceAll("#NAME#", getId().name());
    s = s.replaceAll("#INDEX#", String.valueOf(index));
    s = s.replaceAll("#HOST#", name);
    if(!publicModifier)
      s = s.replaceAll(ind + "public ", ind + "private ");
    //stream.println(s);
    parse(s);
  }

  protected void Components.parse(String s) {
    jrag.AST.JragParser jp = new jrag.AST.JragParser(new java.io.StringReader(s));
    jp.root = hostClass().env();

    // The file name is not meaningful, as the component is completely generated
    // from a node type specification
    jp.setFileName("");

    // EMMA_2011-09-08: Adding this to give .ast generated methods an enclosing 
    // aspect "Ast" which allows for refinement of these methods. For example,
    // "getA" generated from "B ::= A" can be refined using the "Ast" aspect.
    //jp.enclosingAspect = "Ast";

    try {
      while(true) {
        jp.AspectBodyDeclaration();
      }
    } catch (Exception e) {
      // TODO: handle aspect parsing exception
      //System.err.println("Aspect parsing error: " + e.getMessage());
      //e.printStackTrace(System.err);
    }
  }
}
