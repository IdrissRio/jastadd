/* Copyright (c) 2005-2013, The JastAdd Team
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Lund University nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
import java.util.*;
import java.io.*;

import org.jastadd.ast.AST.*;
import org.jastadd.jrag.*;

import org.jastadd.jrag.AST.ASTCompilationUnit;
import org.jastadd.jrag.AST.ASTBlock;

import org.jastadd.JastAdd;

aspect AttributeKind {
  syn String AttrDecl.attributeKind();
  eq SynDecl.attributeKind() = isNTA() ? "syn nta" : "syn";
  eq InhDecl.attributeKind() = "inh";
  eq CollDecl.attributeKind() = "coll";
}

aspect JragCodeGen {

  /**
   * Generate the declaredat documentation tag. If no file name is available
   * then no tag is generated.
   *
   * @param fileName the name of the source file containing the declaration
   * @param line the line number in the source file where the declaration occurs
   * @return the declaredat tag
   */
  public static String ASTNode.declaredat(String fileName, int line) {
    fileName = fileName.trim();
    if (fileName.length() == 0) {
      return "";
    } else {
      // replace backslashes in the file path with slashes in order to avoid
      // unintentional (and possibly illegal) unicode escape sequences
      return "@declaredat " + escapedFileName(fileName) + ":" + line;
    }
  }

  syn String AttrDecl.declaredat() =
    ASTNode.declaredat(getFileName(), getStartLine());

  syn String AttrEq.declaredat() =
    ASTNode.declaredat(getFileName(), getStartLine());

  syn String Rewrite.declaredat() =
    ASTNode.declaredat(getFileName(), getStartLine());

  syn String RewriteList.declaredat() =
    ASTNode.declaredat(getFileName(), getStartLine());

  refine  public boolean AttrDecl.getLazy() {
    if (config().cacheAll)
      return true;
    else if (config().cacheNone)
      return declaredNTA();
    else
      return declaredNTA() || refined();
  }

  refine  public boolean SynDecl.getLazy() {
    if (config().cacheAll)
      return true;
    else if (config().cacheNone)
      return declaredNTA();
    else
      return declaredNTA() || refined();
  }

  refine  public boolean InhDecl.getLazy() {
    if (config().cacheAll)
      return true;
    else if (config().cacheNone)
      return declaredNTA();
    else
      return declaredNTA() || refined();
  }

  refine  public boolean CollDecl.getLazy() {
    if (config().cacheAll)
      return true;
    else if (config().cacheNone)
      return false;
    else
      return declaredNTA() || refined();
  }

  public String Grammar.genImportsList() {
    Set imports = new LinkedHashSet();
    for (Iterator iter = getCompUnits(); iter.hasNext(); ) {
        org.jastadd.jrag.AST.ASTCompilationUnit u =
          (org.jastadd.jrag.AST.ASTCompilationUnit) iter.next();
        imports.addAll(Unparser.getImports(u));
    }
    StringBuilder buf = new StringBuilder();
    for (Iterator iter = imports.iterator(); iter.hasNext(); ) {
      buf.append(iter.next());
      buf.append('\n');
    }
    return buf.toString();
  }

  public void InterfaceDecl.emitMembers(PrintStream out) {
    for (Iterator iter = getClassBodyDeclsItr(); iter.hasNext(); ) {
      ClassBodyObject obj = (ClassBodyObject)iter.next();
      org.jastadd.jrag.AST.SimpleNode n = obj.node;
      //out.println(ind + "// Declared in " + obj.fileName + " at line " + obj.line);
      if (n instanceof org.jastadd.jrag.AST.ASTAspectMethodDeclaration) {
        try {
          StringBuffer buf = new StringBuffer();
          org.jastadd.jrag.AST.ASTAspectMethodDeclaration decl = (org.jastadd.jrag.AST.ASTAspectMethodDeclaration)n;
          ClassBodyDeclUnparser.unparseAbstract(decl, buf);
          out.print(buf);
        } catch (Exception e) {
          System.err.println("Error generating " + obj.signature() + " in " + name());
          e.printStackTrace();
        }
      }
      else if (n instanceof org.jastadd.jrag.AST.ASTAspectRefineMethodDeclaration) {
        try {
          StringBuffer buf = new StringBuffer();
          org.jastadd.jrag.AST.ASTAspectRefineMethodDeclaration decl = (org.jastadd.jrag.AST.ASTAspectRefineMethodDeclaration)n;
          ClassBodyDeclUnparser.unparseAbstract(decl, buf);
          out.print(buf);
        } catch (Exception e) {
          System.err.println("Error generating " + obj.signature() + " in " + name());
          e.printStackTrace();
        }
      }
      else if (n instanceof org.jastadd.jrag.AST.ASTBlock) {
        // do not emit refined implementations
      }
      else {
        if (!obj.comments.equals("")) {
          out.print(obj.comments + " ");
        }
        out.print(obj.modifiers());
        StringBuffer buf = new StringBuffer();
        n.jjtAccept(new ClassBodyDeclUnparser(), buf);
        out.print(buf.toString());
      }
      out.println();
    }
  }

  public void TypeDecl.emitMembers(PrintStream out) { }

  public void ASTDecl.emitMembers(PrintStream out) {
    for (Iterator iter = getClassBodyDeclsItr(); iter.hasNext(); ) {
      ClassBodyObject obj = (ClassBodyObject)iter.next();
      org.jastadd.jrag.AST.SimpleNode node = obj.node;
      out.print(obj.modifiers());
      out.println(docComment(obj));
      out.print(config().indent);
      StringBuffer buf = new StringBuffer();
      node.jjtAccept(new ClassBodyDeclUnparser(), buf);
      out.print(buf.toString());
      out.println();
    }
  }

  public void TypeDecl.emitAbstractSyns(PrintStream out) {
    for (int i = 0; i < getNumSynDecl(); i++) {
      AttrDecl attr = getSynDecl(i);
      out.println(attr.docComment());
      attr.emitSynDecl(out);
    }
  }

  public void AttrDecl.emitSynDecl(PrintStream out) {
    templateContext().expand("AttrDecl.synDecl", out);
  }

  public void AttrDecl.emitAbstractSynDecl(PrintStream out) {
    templateContext().expand("AttrDecl.abstractSynDecl", out);
  }

  /**
   * Generate abstract method declarations for synthesized attributes
   * that lack an equation.
   */
  public void ASTDecl.emitAbstractSyns(PrintStream out) {
    for (int i = 0; i < getNumSynDecl(); i++) {
      AttrDecl attr = getSynDecl(i);
      boolean equ = false;
      for (int j = 0; j < getNumSynEq(); j++) {
        if (getSynEq(j).signature().equals(attr.signature())) {
          equ = true;
        }
      }
      if (!equ) {
        attr.emitAbstractSynDecl(out);
      }
    }
  }

  syn String AttrEq.attributeKind() = decl().attributeKind();

  public String AttrDecl.initLazyMaps() {
    StringBuilder sb = new StringBuilder();
    if (config().lazyMaps) {
      if (!isCircular()) {
        if (getNumParameter() != 0 && config().visitCheckEnabled && config().rewriteEnabled) {
          sb.append("if (" + signature() + "_visited == null) " + signature() + "_visited = " + config().createDefaultMap + ";\n");
        }
        else if (getNumParameter() != 0 && config().visitCheckEnabled) {
          sb.append("if (" + signature() + "_visited == null) " + signature() + "_visited = " + config().createDefaultSet + ";\n");
        }
      }
      if (getNumParameter() != 0 && (getLazy() || isCircular())) {
        sb.append("if (" + signature() + "_values == null) " + signature() + "_values = " + config().createDefaultMap + ";\n");
      }
    }
    return sb.toString();
  }

  public void AttrDecl.emitVisitedDeclarations(PrintStream out) {
    if ( !config().visitCheckEnabled && !isCircular()) {
      return;
    }

    String type;
    String init;
    if (isCircular()) {
      if (getNumParameter() == 0) {
        type = "int";
        init = " = -1";
      } else {
        // the visited flag is part of the State$Value object
        return;
      }
    } else if (config().rewriteEnabled) {
      if (getNumParameter() == 0) {
        type = "int";
        init = " = -1";
      } else {
        type = config().typeDefaultMap;
        if (config().lazyMaps) {
          init = "";
        } else {
          init = " = " + config().createDefaultMap;
        }
      }
    } else if (getNumParameter() == 0) {
      type = "boolean";
      init = " = false";
    } else {
      type = config().typeDefaultSet;
      if (config().lazyMaps) {
          init = "";
      } else {
          init = " = " + config().createDefaultSet;
      }
    }

    TemplateContext tt = templateContext();
    tt.bind("Type", type);
    tt.bind("Init", init);
    tt.expand("AttrDecl.emitVisitedDeclarations", out);
  }

  public String AttrDecl.visitedException() {
    TemplateContext tt = templateContext();
    tt.bind("ClassName", getClass().getName());
    return tt.expand("AttrDecl.visitedException");
  }

  syn String AttrDecl.resetVisit() = resetVisit("");

  public String AttrDecl.resetVisit(String prefix) {
    String signature = prefix + signature();
    if (isCircular()) {
      if (getNumParameter() == 0) {
        return signature + "_visited = -1;\n";
      } else {
        // visited is handled in value object
        return "";
      }
    }
    if (!config().visitCheckEnabled) return "";
    else if (config().rewriteEnabled) {
      if (getNumParameter() == 0)
        return signature + "_visited = -1;\n";
      else {
        if (config().lazyMaps)
          return signature + "_visited = null;\n";
        else
          return signature + "_visited = " + config().createDefaultMap + ";\n";
      }
    }
    if (getNumParameter() == 0)
      return signature + "_visited = false;\n";
    else {
      if (config().lazyMaps)
        return signature + "_visited = null;\n";
      else
        return signature + "_visited = " + config().createDefaultSet + ";\n";
    }
  }

  public String AttrDecl.visitedCheck() {
    return templateContext().expand("AttrDecl.visitedCheck");
  }

  public String AttrDecl.setVisited() {
    if (!config().visitCheckEnabled && !isCircular()) {
      return "";
    }
    return templateContext().expand("AttrDecl.setVisited");
  }

  public String AttrDecl.clearVisited() {
    if (!config().visitCheckEnabled && !isCircular()) {
      return "";
    } else if (config().rewriteEnabled) {
      if (getNumParameter() == 0)
        return signature() + "_visited = -1;\n";
      else
        return signature() + "_visited.remove(_parameters);\n";
    } else if (getNumParameter() == 0) {
      return signature() + "_visited = false;\n";
    } else {
      return signature() + "_visited.remove(_parameters);\n";
    }
  }

  public void AttrDecl.emitCacheDeclarations(PrintStream out) {
    if (getLazy()) {
      templateContext().expand("AttrDecl.cacheDeclarations", out);
    }
  }

  syn boolean AttrDecl.declaredNTA() = false;
  eq SynDecl.declaredNTA() = getNTA();
  eq InhDecl.declaredNTA() = getNTA();

  public String Parameter.toReferenceType() {
    return toReferenceType(getName(), getType());
  }

  public String ASTNode.toReferenceType(String value, String type) {
    if (type.equals("int"))
      return config().java5 ? "Integer.valueOf(" + value + ")" : "new Integer(" + value + ")";
    else if (type.equals("short"))
      return config().java5 ? "Short.valueOf(" + value + ")" : "new Short(" + value + ")";
    else if (type.equals("long"))
      return config().java5 ? "Long.valueOf(" + value + ")" : "new Long(" + value + ")";
    else if (type.equals("float"))
      return config().java5 ? "Float.valueOf(" + value + ")" : "new Float(" + value + ")";
    else if (type.equals("double"))
      return config().java5 ? "Double.valueOf(" + value + ")" : "new Double(" + value + ")";
    else if (type.equals("boolean"))
      return "Boolean.valueOf(" + value + ")";
    else if (type.equals("char"))
      return config().java5 ? "Character.valueOf(" + value + ")" : "new Character(" + value + ")";
    else return value;
  }

  public String ASTNode.fromReferenceType(String value, String type) {
    if (type.equals("int"))
      return "((Integer)" + value + ").intValue()";
    else if (type.equals("short"))
      return "((Short)" + value + ").shortValue()";
    else if (type.equals("long"))
      return "((Long)" + value + ").longValue()";
    else if (type.equals("float"))
      return "((Float)" + value + ").floatValue()";
    else if (type.equals("double"))
      return "((Double)" + value + ").doubleValue()";
    else if (type.equals("boolean"))
      return "((Boolean)" + value + ").booleanValue()";
    else if (type.equals("char"))
      return "((Character)" + value + ").charValue()";
    else
      return "(" + type + ")" + value;
  }

  public boolean AttrDecl.isPrimitive() {
    String type = getType();
    return type.equals("int") || type.equals("short") || type.equals("long") ||
      type.equals("float") || type.equals("double") || type.equals("boolean") ||
      type.equals("char") || type.equals("byte");
  }

  public boolean AttrDecl.isPrimitive(String type) {
    return type.equals("int") || type.equals("short") || type.equals("long") ||
      type.equals("float") || type.equals("double") || type.equals("boolean") ||
      type.equals("char") || type.equals("byte");
  }

  public boolean TokenComponent.isPrimitive() {
    String type = getTokenId().getTYPE();
    return type.equals("int") || type.equals("short") || type.equals("long") ||
      type.equals("float") || type.equals("double") || type.equals("boolean") ||
      type.equals("char") || type.equals("byte");
  }

  public String AttrDecl.parameterStructure() {
    if (getNumParameter() == 0 || (!getLazy() && !isCircular() && !config().visitCheckEnabled)) {
      return "";
    } else if (getNumParameter() == 1) {
      return "Object _parameters = " + getParameter(0).toReferenceType() + ";\n";
    } else {
      StringBuilder sb = new StringBuilder();
      sb.append("java.util.List _parameters = new java.util.ArrayList(" + getNumParameter() + ");\n");
      for (int i = 0; i < getNumParameter(); i++) {
        sb.append("_parameters.add(" + getParameter(i).toReferenceType() + ");\n");
      }
      return sb.toString();
    }
  }

  public String AttrDecl.cacheInit() {
    if (!getLazy())
      return "";
    return cacheInitCircular() + cacheInitRewrite();
  }
  
  public String AttrDecl.cacheInitCircular() {
    if (!config().circularEnabled) {
      return "";
    } else {
      return "boolean intermediate = state.INTERMEDIATE_VALUE;\n" + 
             "state.INTERMEDIATE_VALUE = false;\n";
    }
  }
  
  public String AttrDecl.cacheInitRewrite() {
    if (!config().rewriteEnabled) {
      return "";
    } else {
      return "int num = state.boundariesCrossed;\n" +
             "boolean isFinal = this.is$Final();";
    }
  }

  public String AttrDecl.callCompute() {
    if (getLazy() && getNumParameter() == 0)
      return signature() + "_value = " + name() + "_compute(" + parameters() + ");\n";
    else
      return getType() + " " + signature() + "_value = " + name() + "_compute(" + parameters() + ");\n";
  }

  // TODO: INH
  public String InhDecl.callCompute() {
    if (getLazy() && getNumParameter() == 0) {
      return inhDebugString() +
        signature() + "_value = getParent().Define_" + getTypeInSignature() + "_" + name() + "(" + interfaceParametersStart() + ");\n";
    } else {
      return inhDebugString() +
        getType() + " " + signature() + "_value = getParent().Define_" + getTypeInSignature() + "_" + name() + "(" + interfaceParametersStart() + ");\n";
    }
  }

  public String AttrDecl.cacheStore() {
    if (getFinal()) {
      return "if (true)";
    }
    StringBuilder cacheCond = new StringBuilder();
    cacheCond.append(cacheStoreRewrite());
    String circularCond = (!isCircular() ? cacheStoreCircular() : "");
    if (cacheCond.length() != 0 && !circularCond.isEmpty()) {
      cacheCond.append(" && ");
    }
    cacheCond.append(circularCond);
    if (cacheCond.length() == 0) {
      cacheCond.append("true");
    }
    return "if (" + cacheCond.toString() + ")";
  }

  public String AttrDecl.cacheStoreCircular() {
    if (config().circularEnabled) {
      if (config().cacheCycle) {
        return "(!state.IN_CIRCLE || (state.IN_CIRCLE && (!state.INTERMEDIATE_VALUE || state.LAST_CYCLE)))";
      }
      return "!state.INTERMEDIATE_VALUE";
    } else {
      return "";
    }  
  }

  public String AttrDecl.cacheStoreRewrite() {
    if (config().rewriteEnabled) {
      return "(isFinal && num == state().boundariesCrossed)";
    } else {
      return "";
    }
  }
  
  public String AttrDecl.cacheRestore() {
    if (config().circularEnabled) {
      return "state.INTERMEDIATE_VALUE |= intermediate;\n";
    } else {
      return "";
    }
  }

  syn String AttrDecl.attributeValueReference() =
        toReferenceType(signature() + "_value", getType());

  syn boolean AttrDecl.isNTAToken() =
    isNTA() && !(findCorrespondingNTA() instanceof TokenComponent);

  syn boolean AttrEq.hasComputeBlock() = true;
  eq SynEq.hasComputeBlock() = getRHS() instanceof ASTBlock;

  /**
   * @return Compute method without "_compute" suffix
   */
  public void AttrDecl.emitInlineCompute(AttrEq equ, PrintStream out) {
    TemplateContext tt = templateContext();
    tt.bind("ParamDecl", equ.parametersDecl());
    tt.bind("ComputeBody", equ.computeMethodBody());
    tt.bind("FromRefTypeParam", fromReferenceType(signature() + "_values.get(_parameters)", getType()));
    tt.expand("AttrDecl.emitInlineCompute", out);
  }

  public String AttrEq.computeMethodBody() {
    return "{ }";
  }

  public String SynEq.computeMethodBody() {
    if (hasComputeBlock())
      return Unparser.unparse(getRHS());
    else
      return "{  return " + Unparser.unparse(getRHS()) + ";  }";
  }

  /**
   * @return Code for the method to compute this attribute
   */
  public void AttrEq.emitComputeMethod(PrintStream out) {
  }

  public void SynEq.emitComputeMethod(PrintStream out) {
    TemplateContext tt = templateContext();
    tt.bind("ComputeBody", computeMethodBody());
    tt.expand("SynEq.emitComputeMethod", out);
  }

  syn String AttrDecl.inhDebugString() {
    if (!config().debugMode) {
      return "";
    } else {
      return config().ind(2) + "if (getParent() == null) throw new RuntimeException(\"Trying to evaluate attribute in subtree not attached to main tree\");\n";
    }
  }

  public boolean TypeDecl.hasLazySynEqFor(AttrDecl attr) {
    if (attr instanceof SynDecl) {
      SynEq synEq = lookupSynEq(attr.signature());
      return synEq != null && (synEq.decl().getLazy() || synEq.decl().isCircular()) ;
    }
    return false;
  }

  syn String AttrDecl.cycleLimitCheck() = "";
   // TODO: fixme cycleLimit > 0 ?
   //    "if (state().CIRCLE_INDEX > " + cycleLimit + ") throw new java.lang.RuntimeException(\"Iteration limit " + cycleLimit + " exceeded\");\n" : "";

  public void AttrDecl.emitEquation(String paramDecl, PrintStream out) {
    TemplateContext tt = templateContext();
    tt.bind("ParamDecl", paramDecl);
    tt.bind("FromRefTypeParam", fromReferenceType(signature() + "_values.get(_parameters)", getType()));
    tt.expand("AttrDecl.genEquation", out);
  }

  public void AttrDecl.emitCircularEquationNoParams(PrintStream out) {
    TemplateContext tt = templateContext();
    tt.bind("Cond1", differs("new_" + signature() + "_value", signature() + "_value"));
    tt.bind("Cond2", differs("new_" + signature() + "_value", signature() + "_value"));
    tt.bind("BottomValue", Unparser.unparse(getBottomValue()));
    tt.bind("TracePrintReturnNewValue", tracePrintReturnNewValue(signature() + "_value"));
    tt.bind("TracePrintReturnPreviousValue", tracePrintReturnPreviousValue(signature() + "_value"));
    tt.expand("ASTDecl.genCircularEquationNoParams", out);
  }

  public void AttrDecl.emitCircularEquationWithParams(String paramDecl, PrintStream out) {
    TemplateContext tt = templateContext();
    tt.bind("BottomValue", toReferenceType(Unparser.unparse(getBottomValue()), getType()));
    tt.bind("Cond1", differs("new_" + signature() + "_value", fromReferenceType("_value.value", getType())));
    tt.bind("ToRefType", toReferenceType("new_" + signature() + "_value", getType()));
    tt.bind("FromRefType", fromReferenceType("_value.value", getType()));
    tt.bind("FromRefTypeParamCircular", fromReferenceType("_o", getType()));
    tt.bind("FromRefTypeParam", fromReferenceType(signature() + "_values.get(_parameters)", getType()));
    tt.bind("ParamDecl", paramDecl);
    tt.bind("TracePrintReturnNewValue", tracePrintReturnNewValue("new_" + signature() + "_value"));
    tt.bind("TracePrintReturnPreviousValue", tracePrintReturnPreviousValue(fromReferenceType(signature() + "_values.get(_parameters)" , getType())));
    tt.expand("ASTDecl.genCircularEquationWithParams", out);
  }

  /**
   * Generates the method to compute an attribute
   * @param attr The attribute we are adding a compute method for
   * @param paramDecl
   * @param out
   */
  public void ASTDecl.emitEquation(AttrDecl attr, String paramDecl, PrintStream out) {
    if (!attr.isCircular()) {
      attr.emitEquation(paramDecl, out);
    } else {
      if (attr.getNumParameter() == 0) {
        attr.emitCircularEquationNoParams(out);
      } else {
        attr.emitCircularEquationWithParams(paramDecl, out);
      }
    }
  }

  public String AttrDecl.circularComputeCall() { return ""; }
  public String SynDecl.circularComputeCall() { return name() + "_compute(" + parameters() + ")"; }
  public String InhDecl.circularComputeCall() {
    return "getParent().Define_" + getTypeInSignature() + "_" + name() + "(" + interfaceParametersStart() + ")";
  }

  syn boolean AttrDecl.isParameterized() =
    getNumParameter() != 0;

  public String AttrDecl.cacheCycleCheck() {
    if (!config().cacheCycle) return "";
    TemplateContext tt = templateContext();
    String ind = config().indent;
    if (getNumParameter() == 0) {
      return
        "if (state.LAST_CYCLE) {\n" +
        signature() + "_computed = true;\n" +
        inhDebugString() +
        tt.expand("AttrDecl.incHookAttrCompStartCircular") +
        ind + getType() + " new_" + signature() + "_value = " + circularComputeCall() + ";\n" +
        tt.expand("AttrDecl.incHookAttrCompEndCircular") +
        ind + "return new_" + signature() + "_value;\n" +
        "}\n";
    } else {
      if (config().java5) {
        return
          "if (state.LAST_CYCLE) {\n" +
          inhDebugString() +
          ind + signature() + "_values.put(_parameters, new_" + signature() + "_value);\n" +
          "}\n";
      } else {
        return
          "if (state.LAST_CYCLE) {\n" +
          inhDebugString() +
          ind + signature() + "_values.put(_parameters, " + toReferenceType("new_" + signature() + "_value", getType()) + ");\n" +
          "}\n";
      }
    }
  }

  public String AttrDecl.addComponentCheck() {
    if (!config().componentCheck || !config().visitCheckEnabled) return "";
    String arg = getNumParameter() == 0 ? "null" : "_parameters";
    String ind = config().indent;
    if (getNumParameter() == 0) {
      if (config().rewriteEnabled)
        return
        "if (" + signature() + "_visited == state.boundariesCrossed && !state.containsEvalEntry(this, \"" + signature() + "\", null))\n" +
        ind + "throw new java.lang.RuntimeException(\"XXX\");\n";
      else
        return
        "if (" + signature() + "_visited != -1 && !state.containsEvalEntry(this, \"" + signature() + "\", null))\n" +
        ind + "throw new java.lang.RuntimeException(\"XXX\");\n";
    }
    else {
      if (config().rewriteEnabled) {
        if (config().java5)
          return
          "if (new Integer(state.boundariesCrossed).equals(_value.visited) && !state.containsEvalEntry(this, \"" + signature() + "\", _parameters))\n" +
          ind + "throw new java.lang.RuntimeException(\"XXX\");\n";
        else
          return
          "if (new Integer(state.boundariesCrossed).equals(Integer.valueOf(_value.visited)) && !state.containsEvalEntry(this, \"" + signature() + "\", _parameters))\n" +
          ind + "throw new java.lang.RuntimeException(\"XXX\");\n";
      } else
        return
        "if (_value.visited != -1 && !state.containsEvalEntry(this, \"" + signature() + "\", _parameters))\n" +
        ind + "throw new java.lang.RuntimeException(\"XXX\");\n";
    }
  }

  public String AttrDecl.addAddToComponent() {
    if (!config().componentCheck || !config().visitCheckEnabled) return "";
    if (getNumParameter() == 0) {
      return
        "state.addEvalEntry(this, \"" + signature() + "\", null);\n";
    } else {
      return
        "state.addEvalEntry(this, \"" + signature() + "\", _parameters);\n";
    }
  }

  public String AttrDecl.differs(String s1, String s2) {
    if (isPrimitive())
      return s1 + " != " + s2;
    else
      return "(" + s1 + "==null && " + s2 + "!=null) || (" + s1 + "!=null && !" + s1 + ".equals(" + s2 + "))";
  }

  public void ASTDecl.emitCacheDeclarations(PrintStream out, AttrDecl attr) {
    boolean needsCacheDeclaration = true;
    if (attr instanceof SynDecl) {
      // EMMA_2011-09-13: Setting this to true to get declarations for each
      // equation of an attribute. If an equation lacks its own visited declaration
      // and calls an overriden equation it can cause a circularity exception.
      needsCacheDeclaration = true; // superClass() == null || !superClass().hasLazySynEqFor(attr);
    }
    String ind = config().indent;
    if (!attr.isCircular()) {
      if (needsCacheDeclaration) {
        attr.emitVisitedDeclarations(out);
        attr.emitCacheDeclarations(out);
      }
    } else {
      if (attr.getNumParameter() == 0) {
        if (!needsCacheDeclaration && attr instanceof SynDecl &&
            superClass() != null && superClass().lookupSynEq(attr.signature()) != null
            && !superClass().lookupSynEq(attr.signature()).decl().isCircular()) {

          needsCacheDeclaration = true;
        }
        if (needsCacheDeclaration) {
          attr.emitVisitedDeclarations(out);
          out.println(ind + "/**");
          out.println(ind + " * @apilevel internal");
          out.println(ind + " */");
          out.println(ind + "protected boolean " + attr.signature() + "_computed = false;");
          out.println(ind + "/**");
          out.println(ind + " * @apilevel internal");
          out.println(ind + " */");
          out.println(ind + "protected boolean " + attr.signature() + "_initialized = false;");
          out.println(ind + "/**");
          out.println(ind + " * @apilevel internal");
          out.println(ind + " */");
          out.println(ind + "protected " + attr.getType() + " " + attr.signature() + "_value;");
          return;
        }
      }
      else {
        if (needsCacheDeclaration) {
          attr.emitVisitedDeclarations(out);
          if (config().lazyMaps) {
            out.println(ind + "protected " + config().typeDefaultMap + " " + attr.signature() + "_values;");
            return;
          } else {
            out.println(ind + "protected " + config().typeDefaultMap + " " + attr.signature() + "_values = " + config().createDefaultMap + ";");
            return;
          }
        }
      }
    }
  }

  syn String AttrEq.getType() = decl().getType();

  public void ASTDecl.emitSynEquations(PrintStream out) {
    for (int i = 0; i < getNumSynEq(); i++) {
       AttrEq equ = getSynEq(i);
       AttrDecl attr = equ.decl();
       emitCacheDeclarations(out, attr);
       if (attr.isNTA() || attr.getLazy() || attr.isCircular()) {
         out.println(equ.docComment());
         emitEquation(attr, equ.parametersDecl(), out);
         equ.emitComputeMethod(out);
       } else {
         attr.emitInlineCompute(equ, out);
       }
    }
  }

  public boolean AttrDecl.isNTA() {
    return false;
  }

  public boolean SynDecl.isNTA() {
    return findCorrespondingNTA() != null;
  }

  public int AttrDecl.indexNTAchild() {
    Components comp = findCorrespondingNTA();
    TypeDecl c = hostClass();
    while (c != null) {
      int index = 0;
      for (Iterator iter = c.getComponents(); iter.hasNext(); ) {
        Components next = (Components)iter.next();
        if (next == comp)
          return index;
        if (!(next instanceof TokenComponent))
          index++;
      }
      c = c instanceof ASTDecl ? ((ASTDecl)c).superClass() : null;
    }
    return -1;
  }

  public Components AttrDecl.findCorrespondingNTA() {
    if (!getName().startsWith("get"))
      return null;
    String attrName = getName().substring(3);
    TypeDecl c = hostClass();
    while (c != null) {
      for (Iterator iter = c.getComponents(); iter.hasNext(); ) {
        Components comp = (Components)iter.next();
        if (comp.name().equals(attrName) && (
            comp instanceof OptionalComponentNTA
            || comp instanceof TokenComponentNTA
            || comp instanceof AggregateComponentsNTA )) {
          return comp;
        }
        if (attrName.equals(comp.name() + "Opt") && comp instanceof OptionalComponentNTA) {
          return comp;
        }
        if (attrName.equals(comp.name() + "List") && comp instanceof ListComponentsNTA) {
          return comp;
        }
      }
      c = c instanceof ASTDecl ? ((ASTDecl)c).superClass() : null;
    }
    return null;
  }

  public String AttrDecl.higherOrderAttributeCode() {
    return "";
  }

  public String SynDecl.higherOrderAttributeCode() {
    if (getNTA()) {
      if (config().rewriteEnabled) {
        if (config().stagedRewrites) {
          return templateContext().expand("SynDecl.higherOrderAttributeCode:stagedrewrites");
        } else {
          return templateContext().expand("SynDecl.higherOrderAttributeCode:nostagedrewrites");
        }
      } else {
        return templateContext().expand("SynDecl.higherOrderAttributeCode:norewrite");
      }
    } else {
      // non-NTA
      StringBuilder result = new StringBuilder();
      Components comp = findCorrespondingNTA();
      if (comp != null) {
        String attrName = getName().substring(3); // remove get
        if (comp.name().equals(attrName) && (
              comp instanceof OptionalComponentNTA
              || comp instanceof TokenComponentNTA
              || comp instanceof AggregateComponentsNTA )) {
          result.append(config().indent + "set" + attrName + "(" + signature() + "_value);\n");
        }
        if (attrName.equals(comp.name() + "Opt") && comp instanceof OptionalComponentNTA) {
          result.append("set" + attrName + "(" + signature() + "_value);\n");
        }
        if (attrName.equals(comp.name() + "List") && comp instanceof ListComponentsNTA) {
          result.append("set" + attrName + "(" + signature() + "_value);\n");
        }
      }
      return result.toString();
    }
  }

  public void TypeDecl.emitInhDeclarations(PrintStream out) {
    for (int i = 0; i < getNumInhDecl(); i++) {
       AttrDecl attr = getInhDecl(i);
       out.println(attr.docComment());
       attr.emitInhDecl(out);
    }
  }

  public void AttrDecl.emitInhDecl(PrintStream out) {
    templateContext().expand("AttrDecl.inhDecl", out);
  }

  public void ASTDecl.emitInhDeclarations(PrintStream out) {
    for (int i = 0; i < getNumInhDecl(); i++) {
       AttrDecl attr = getInhDecl(i);
       out.println(attr.docComment());
       emitEquation(attr, attr.parametersDecl(), out);
       emitCacheDeclarations(out, attr);
    }
  }

  syn boolean TypeDecl.hasInhEq(String attrName) {
    for (int i = 0; i < getNumInhEq(); i++) {
      InhEq equ = getInhEq(i);
      if (equ.getName().equals(attrName)) {
        return true;
      }
    }
    return false;
  }
  eq ASTDecl.hasInhEq(String attrName) =
    super.hasInhEq(attrName) || superClass() != null && superClass().hasInhEq(attrName);

  syn Components InhEq.getComponents() {
    TypeDecl c = hostClass();
    if (c != null)
      return c.components(childName());
    return  null;
  }
  syn String InhEq.childName() = getChildName().startsWith("get") ? getChildName().substring(3) : getChildName();

  syn AttrDecl InhEq.getChildAttrDecl() {
    AttrDecl decl = hostClass().lookupSynDeclPrefix(childName());
    if (decl == null) decl = hostClass().lookupInhDeclPrefix(childName());
    return decl;
  }

  syn SynDecl TypeDecl.lookupSynDeclPrefix(String signature) {
    for (int i = 0; i < getNumSynDecl(); i++)
      if (getSynDecl(i).signature().equals(signature) || getSynDecl(i).signature().startsWith(signature + "_"))
        return getSynDecl(i);
    return null;
  }
  eq ASTDecl.lookupSynDeclPrefix(String signature) {
    SynDecl decl = super.lookupSynDeclPrefix(signature);
    if (decl != null || superClass() == null)
      return decl;
    return superClass().lookupSynDeclPrefix(signature);
  }
  syn InhDecl TypeDecl.lookupInhDeclPrefix(String signature) {
    for (int i = 0; i < getNumInhDecl(); i++)
      if (getInhDecl(i).signature().equals(signature) || getInhDecl(i).signature().startsWith(signature + "_"))
        return getInhDecl(i);
    return null;
  }
  syn InhDecl ASTDecl.lookupInhDeclPrefix(String signature) {
    InhDecl decl = super.lookupInhDeclPrefix(signature);
    if (decl != null || superClass() == null)
      return decl;
    return superClass().lookupInhDeclPrefix(signature);
  }

  public Iterator Grammar.inhAttrSet() {
    return inhEqMap().keySet().iterator();
  }

  syn lazy HashMap Grammar.inhEqMap() {
    HashMap map = new LinkedHashMap();
    for (int i = 0; i < getNumTypeDecl(); i++) {
      if (getTypeDecl(i) instanceof ASTDecl) {
        map.putAll(((ASTDecl)getTypeDecl(i)).inhEqMap());
      }
    }
    return map;
  }

  syn lazy String Rewrite.aspectName() =
    getAspectName();

  public String Grammar.genResetDuringCounters() {
    StringBuffer sb = new StringBuffer();
    TemplateContext tt = templateContext();
    for (Iterator iter = rewriteAspects().iterator(); iter.hasNext(); ) {
      String name = (String)iter.next();
      tt.bind("Name", name);
      tt.expand("Grammar.genResetDuringCounters", sb);
    }
    return sb.toString();
  }

  syn String AttrEq.inhDebugString() = decl().inhDebugString();

  public void AttrEq.emitInhEqSignature(PrintStream out) {
    templateContext().expand("AttrEq.emitInhEqSignature", out);
  }

  //  TODO: INH
  public void ASTDecl.emitInhEqSignatures(PrintStream out) {
    if (name().equals(config().astNodeType)) {
      for (Iterator iter = grammar().inhEqMap().entrySet().iterator(); iter.hasNext(); ) {
        java.util.Map.Entry entry = (java.util.Map.Entry)iter.next();
        String attrId = (String)entry.getKey();
        AttrEq attr = (AttrEq)((LinkedList)entry.getValue()).get(0);
        if (!hasInhEq(attr.decl().name())) {
          attr.emitInhEqSignature(out);
        }
      }
    }
  }

  syn boolean AttrDecl.hasCache() = getLazy() || isCircular();
  syn boolean AttrDecl.isAttrNTA() = isNTA() && !(findCorrespondingNTA() instanceof TokenComponent);

}
