/* Copyright (c) 2005-2013, The JastAdd Team
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Lund University nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
import java.util.*;
import java.io.*;

import ast.AST.*;
import jrag.*;

import jrag.AST.ASTCompilationUnit;
import jrag.AST.ASTBlock;

import jastadd.JastAdd;

aspect AttributeKind {
  syn String AttrDecl.attributeKind();
  eq SynDecl.attributeKind() = isNTA() ? "syn nta" : "syn";
  eq InhDecl.attributeKind() = "inh";
  eq CollDecl.attributeKind() = "coll";
}

aspect JragCodeGen {

  public static String ASTNode.ind = "  ";
  public static java.util.List<String> ASTNode.indList = new ArrayList<String>(32);

  /**
   * Generate the declaredat documentation tag. If no file name is available
   * then no tag is generated.
   *
   * @param fileName the name of the source file containing the declaration
   * @param line the line number in the source file where the declaration occurs
   * @return the declaredat tag
   */
  public static String ASTNode.declaredat(String fileName, int line) {
    fileName = fileName.trim();
    if (fileName.length() == 0) {
      return "";
    } else {
      // replace backslashes in the file path with slashes in order to avoid
      // unintentional (and possibly illegal) unicode escape sequences
      return "@declaredat " + escapedFileName(fileName) + ":" + line;
    }
  }

  syn String AttrDecl.declaredat() =
    ASTNode.declaredat(getFileName(), getStartLine());

  syn String AttrEq.declaredat() =
    ASTNode.declaredat(getFileName(), getStartLine());

  syn String Rewrite.declaredat() =
    ASTNode.declaredat(getFileName(), getStartLine());

  syn String RewriteList.declaredat() =
    ASTNode.declaredat(getFileName(), getStartLine());

  /**
   * Builds an indentation string equal to a certain level of
   * indentation.
   *
   * @param level the required indentation level
   * @return the indentation string
   */
  public static final String ASTNode.ind(int level) {
    while (indList.size() <= level) {
      if (indList.size() == 0) {
        indList.add("");
      } else {
        indList.add(indList.get(indList.size()-1) + ind);
      }
    }
    return indList.get(level);
  }

  // EMMA_2009-11-16: Modifying cache conditions, using cacheNone instead of noCaching
  refine  public boolean AttrDecl.getLazy() {
    if (grammar().cacheAll)
      return true;
    else if (grammar().cacheNone)
      return declaredNTA();
    else
      return declaredNTA() || refined(); //Ast.AttrDecl.getLazy(); 
//    return (Ast.AttrDecl.getLazy() || grammar().cacheAll) && (!noCaching || declaredNTA());
  }
  refine  public boolean SynDecl.getLazy() {
    if (grammar().cacheAll)
      return true;
    else if (grammar().cacheNone)
      return declaredNTA();
    else
      return declaredNTA() || refined(); //Ast.SynDecl.getLazy();
//    return (Ast.SynDecl.getLazy() || grammar().cacheAll) && (!noCaching || declaredNTA());
  }
  refine  public boolean InhDecl.getLazy() {
    if (grammar().cacheAll)
      return true;
    else if (grammar().cacheNone)
      return declaredNTA();
    else
      return declaredNTA() || refined(); //Ast.InhDecl.getLazy(); 
//    return (Ast.InhDecl.getLazy() || grammar().cacheAll) && (!noCaching || declaredNTA());
  }
  refine  public boolean CollDecl.getLazy() {
    if (grammar().cacheAll)
      return true;
    else if (grammar().cacheNone)
      return false;
    else
      return declaredNTA() || refined(); //Ast.CollDecl.getLazy();
//    return (Ast.CollDecl.getLazy() || grammar().cacheAll) && !noCaching;
  }

  public String Grammar.genImportsList() {
    Set imports = new LinkedHashSet();
    for(Iterator iter = getCompUnits(); iter.hasNext(); ) {
        jrag.AST.ASTCompilationUnit u =
          (jrag.AST.ASTCompilationUnit) iter.next();
        imports.addAll(Unparser.getImports(u));
    }
    StringBuffer buf = new StringBuffer();
    for(Iterator iter = imports.iterator(); iter.hasNext(); ) {
      buf.append(iter.next());
      buf.append('\n');
    }
    return buf.toString();
  }

  public void InterfaceDecl.emitMembers(PrintStream out) {
    for(Iterator iter = getClassBodyDeclsItr(); iter.hasNext(); ) {
      ClassBodyObject o = (ClassBodyObject)iter.next();
      jrag.AST.SimpleNode n = o.node;
      //out.println(ind + "// Declared in " + o.fileName + " at line " + o.line);
      if(n instanceof jrag.AST.ASTAspectMethodDeclaration) {
        try {
          StringBuffer buf = new StringBuffer();
          jrag.AST.ASTAspectMethodDeclaration decl = (jrag.AST.ASTAspectMethodDeclaration)n;
          ClassBodyDeclUnparser.unparseAbstract(decl, buf);
          out.print(buf);
        } catch (Exception e) {
          System.err.println("Error generating " + o.signature() + " in " + name());
          e.printStackTrace();
        }
      }
      else if(n instanceof jrag.AST.ASTAspectRefineMethodDeclaration) {
        try {
          StringBuffer buf = new StringBuffer();
          jrag.AST.ASTAspectRefineMethodDeclaration decl = (jrag.AST.ASTAspectRefineMethodDeclaration)n;
          ClassBodyDeclUnparser.unparseAbstract(decl, buf);
          out.print(buf);
        } catch (Exception e) {
          System.err.println("Error generating " + o.signature() + " in " + name());
          e.printStackTrace();
        }
      }
      else if(n instanceof jrag.AST.ASTBlock) {
        // do not emit refined implementations
      }
      else {
        if(!o.comments.equals("")) {
          out.print(o.comments + " ");
        }
        out.print(o.modifiers);
        StringBuffer buf = new StringBuffer();
        n.jjtAccept(new ClassBodyDeclUnparser(), buf);
        out.print(buf.toString());
      }
      out.println();
    }
  }

  public void TypeDecl.emitMembers(PrintStream out) { }

  public String ASTDecl.javadocComment(ClassBodyObject obj) {
    String comment = obj.comments;
    if (comment == null) {
      return ind + augmentComment(obj,
                            "/**\n" +
                            ind + " */");
    }
    comment.trim();
    if (comment.length() < 5) {
      return ind + augmentComment(obj,
                            "/**\n" +
                            ind + " */");
    }

    int end = comment.lastIndexOf("*/");
    int start = end == -1 ? -1 : comment.lastIndexOf("/**", end);

    if (start != -1) {
      return ind +
        augmentComment(obj, comment.substring(start, end+2));
    } else {
      return ind + augmentComment(obj,
                       "/**\n" +
                       ind + " */");
    }
  }

  public String ASTDecl.augmentComment(ClassBodyObject obj, String comment) {
    StringBuffer sb = new StringBuffer();
    sb.append(comment.substring(0, comment.length()-2));
    sb.append("* @ast method \n");
    if (obj.aspectName() != null && obj.aspectName().length() > 0) {
      sb.append(ind + " * @aspect " + obj.aspectName() + "\n");
    }
    sb.append(ind + " * " + ASTNode.declaredat(obj.getFileName(), obj.getStartLine()) + "\n");
    sb.append(ind + " */\n");
    return sb.toString();
  }

  public void ASTDecl.emitMembers(PrintStream out) {
    for (Iterator iter = getClassBodyDeclsItr(); iter.hasNext(); ) {
      ClassBodyObject obj = (ClassBodyObject)iter.next();
      jrag.AST.SimpleNode node = obj.node;
      out.print(obj.modifiers);
      out.print(javadocComment(obj));
      out.print(ind);
      StringBuffer buf = new StringBuffer();
      node.jjtAccept(new ClassBodyDeclUnparser(), buf);
      out.print(buf.toString());
      out.println();
    }
  }

  syn String ASTDecl.annotations() = suppressWarnings();
  syn String AttrDecl.annotations() = suppressWarnings();

  public void TypeDecl.emitAbstractSyns(PrintStream out) {
    for(int i = 0; i < getNumSynDecl(); i++) {
      AttrDecl attr = getSynDecl(i);
      out.print(attr.hostFileComment(ind));
      attr.emitSynDecl(out);
    }
  }

  public void AttrDecl.emitSynDecl(PrintStream out) {
    templateContext().expand("AttrDecl.synDecl", out);
  }

  public void ASTDecl.emitAbstractSyns(PrintStream out) {
    for(int i = 0; i < getNumSynDecl(); i++) {
      AttrDecl attr = getSynDecl(i);
      boolean equ = false;
      for(int j = 0; j < getNumSynEq(); j++) {
        if(getSynEq(j).signature().equals(attr.signature())) {
          equ = true;
        }
      }
      if(!equ) {
        out.print(attr.hostFileComment(ind));
        out.print(suppressWarnings());
        out.println(ind + "public abstract " + attr.getType() + " " + attr.attributeName() + "(" + attr.parametersDecl() + ");");
      }
    }
  }

  public String AttrDecl.attributeSignature() {
    if(getNumParameter() == 0) {
      return getName();
    }
    StringBuffer s = new StringBuffer();
    s.append(getName());
    for(int i = 0; i < getNumParameter(); i++) {
      s.append("_" + getParameter(i).getTypeInSignature());
    }
    return s.toString();
  }

  public String AttrDecl.attributeName() {
    return getName();
  }

  public String AttrEq.attributeSignature() {
    if(getNumParameter() == 0) {
      return getName();
    }
    StringBuffer s = new StringBuffer();
    s.append(getName());
    for(int i = 0; i < getNumParameter(); i++) {
      s.append("_" + getParameter(i).getTypeInSignature());
    }
    return s.toString();
  }

  public String AttrEq.attributeName() {
    return getName();
  }

  public String AttrDecl.hostFileComment(String ind) {
    return javadocFileComment(ind);
  }

  public String AttrDecl.javadocFileComment(String ind) {
    TemplateContext tt = templateContext();
    String comment = getComment().trim();
    if (comment.length() >= 5 && comment.startsWith("/**")) {
      tt.bind("SourceComment", comment.substring(3, comment.indexOf("*/")));
    } else {
      tt.bind("SourceComment", "");
    }
    return tt.expand("AttrDecl.javaDoc");
  }

  syn String AttrEq.attributeKind() = decl().attributeKind();

  public String AttrEq.hostFileComment(String ind) {
    TemplateContext tt = templateContext();
    String comment = getComment().trim();

    if (comment.isEmpty()) {
      comment = decl().getComment().trim();
    }

    if (comment.length() >= 5 && comment.startsWith("/**")) {
      tt.bind("SourceComment", comment.substring(3, comment.indexOf("*/")));
    } else {
      tt.bind("SourceComment", "");
    }
    return tt.expand("AttrEq.javaDoc");
  }

  public String AttrDecl.initLazyMaps() {
    StringBuffer s = new StringBuffer();
    if(grammar().lazyMaps) {
      if(!isCircular()) {
        if(getNumParameter() != 0 && grammar().visitCheckEnabled && grammar().rewriteEnabled) {
          s.append("if(" + attributeSignature() + "_visited == null) " + attributeSignature() + "_visited = " + grammar().createDefaultMap + ";\n");
        }
        else if(getNumParameter() != 0 && grammar().visitCheckEnabled) {
          s.append("if(" + attributeSignature() + "_visited == null) " + attributeSignature() + "_visited = " + grammar().createDefaultSet + ";\n");
        }
      }
      if(getNumParameter() != 0 && (getLazy() || isCircular())) {
        s.append("if(" + attributeSignature() + "_values == null) " + attributeSignature() + "_values = " + grammar().createDefaultMap + ";\n");
      }
    }
    return s.toString();
  }

  public void AttrDecl.emitVisitedDeclarations(PrintStream out) {
    if(!grammar().visitCheckEnabled && !isCircular()) {
      return;
    }

    String type;
    String init;
    if(isCircular()) {
      if(getNumParameter() == 0) {
        type = "int";
        init = " = -1";
      } else {
        // the visited flag is part of the State$Value object
        return;
      }
    } else if(grammar().rewriteEnabled) {
      if(getNumParameter() == 0) {
        type = "int";
        init = " = -1";
      } else {
        type = grammar().typeDefaultMap;
        if(grammar().lazyMaps) {
          init = "";
        } else {
          init = " = " + grammar().createDefaultMap;
        }
      }
    } else if(getNumParameter() == 0) {
      type = "boolean";
      init = " = false";
    } else {
      type = grammar().typeDefaultSet;
      if(grammar().lazyMaps) {
          init = "";
      } else {
          init = " = " + grammar().createDefaultSet;
      }
    }

    TemplateContext tt = templateContext();
    tt.bind("Type", type);
    tt.bind("Init", init);
    tt.expand("AttrDecl.emitVisitedDeclarations", out);
  }

  public String AttrDecl.visitedException() {
    TemplateContext tt = templateContext();
    tt.bind("ClassName", getClass().getName());
    return tt.expand("AttrDecl.visitedException");
  }

  public String AttrDecl.resetVisit() {
    if(isCircular()) {
      if(getNumParameter() == 0)
        return ind(2) + "#NAME#_visited = -1;\n";
      else {
        // visited is handled in value object
        return "";
      }
    }
    if(!grammar().visitCheckEnabled) return "";
    else if(grammar().rewriteEnabled) {
      if(getNumParameter() == 0)
        return ind(2) + "#NAME#_visited = -1;\n";
      else {
        if(grammar().lazyMaps)
          return ind(2) + "#NAME#_visited = null;\n";
        else
          return ind(2) + "#NAME#_visited = " + grammar().createDefaultMap + ";\n";
      }
    }
    if(getNumParameter() == 0)
      return ind(2) + "#NAME#_visited = false;\n";
    else {
      if(grammar().lazyMaps)
        return ind(2) + "#NAME#_visited = null;\n";
      else
        return ind(2) + "#NAME#_visited = " + grammar().createDefaultSet + ";\n";
    }
  }

  public String AttrDecl.visitedCheck() {
    TemplateContext tt = templateContext();
    tt.bind("NonParameterized", getNumParameter() == 0);
    return tt.expand("AttrDecl.visitedCheck");
  }

  public String AttrDecl.setVisited() {
    if(!grammar().visitCheckEnabled && !isCircular()) {
      return "";
    }

    TemplateContext tt = templateContext();
    tt.bind("NonParameterized", getNumParameter() == 0);
    return tt.expand("AttrDecl.setVisited");
  }

  public String AttrDecl.clearVisited() {
    if(!grammar().visitCheckEnabled && !isCircular()) {
      return "";
    } else if(grammar().rewriteEnabled) {
      if(getNumParameter() == 0)
        return attributeSignature() + "_visited = -1;\n";
      else
        return attributeSignature() + "_visited.remove(_parameters);\n";
    } else if(getNumParameter() == 0) {
      return attributeSignature() + "_visited = false;\n";
    } else {
      return attributeSignature() + "_visited.remove(_parameters);\n";
    }
  }

  public void AttrDecl.emitCacheDeclarations(PrintStream out) {
    if(!getLazy())
      return;
    if(getNumParameter() == 0) {
      out.println(ind + "/**");
      out.println(ind + " * @apilevel internal");
      out.println(ind + " */");
      out.println(ind + "protected boolean " + attributeSignature() + "_computed = false;");
      out.println(ind + "/**");
      out.println(ind + " * @apilevel internal");
      out.println(ind + " */");
      out.println(ind + "protected " + getType() + " " + attributeSignature() + "_value;");
      return;
    } else if(declaredNTA()) {
      if(grammar().lazyMaps) {
        out.println(ind + "/**");
        out.println(ind + " * @apilevel internal");
        out.println(ind + " */");
        out.println(ind + "protected " + grammar().typeDefaultMap + " " + attributeSignature() + "_values;");
        out.println(ind + "/**");
        out.println(ind + " * @apilevel internal");
        out.println(ind + " */");
        out.println(ind + "protected List " + attributeSignature() + "_list;");
        return;
      } else {
        out.println(ind + "/**");
        out.println(ind + " * @apilevel internal");
        out.println(ind + " */");
        out.println(ind + "protected " + grammar().typeDefaultMap + " " + attributeSignature() + "_values = " + grammar().createDefaultMap + ";");
        out.println(ind + "/**");
        out.println(ind + " * @apilevel internal");
        out.println(ind + " */");
        out.println(ind + "protected List " + attributeSignature() + "_list;");
        return;
      }
    }
    else {
      if (grammar().lazyMaps) {
        out.println(ind + "protected " + grammar().typeDefaultMap + " " + attributeSignature() + "_values;");
        return;
      } else {
        out.println(ind + "protected " + grammar().typeDefaultMap + " " + attributeSignature() + "_values = " + grammar().createDefaultMap + ";");
        return;
      }
    }
  }

  syn boolean AttrDecl.declaredNTA() = false;
  eq SynDecl.declaredNTA() = getNTA();
  eq InhDecl.declaredNTA() = getNTA();

  public String AttrDecl.resetCache() {
    if(!getLazy() && !isCircular())
      return "";
    if(getNumParameter() == 0) {
      if(isCircular()) {
        if(isPrimitive())
          return ind(2) + "#NAME#_computed = false;\n" +
                 ind(2) + "#NAME#_initialized = false;\n";
        else
          return ind(2) + "#NAME#_computed = false;\n" +
                 ind(2) + "#NAME#_initialized = false;\n" +
                 ind(2) + "#NAME#_value = null;\n";
      }
      if(isPrimitive())
        return ind(2) + "#NAME#_computed = false;\n";
      else
        return ind(2) + "#NAME#_computed = false;\n" +
               ind(2) + "#NAME#_value = null;\n";
    }
    else if(isCircular()) {
        if(grammar().lazyMaps)
          return ind(2) + "#NAME#_values = null;\n";
        else
          return ind(2) + "#NAME#_values = " + grammar().createDefaultMap + ";\n";
    }
    else {
      // ES: Must also set the internal list to null when flushing parameterized NTAs
      if (getNTA()) {
        if(grammar().lazyMaps)
          return ind(2) + "#NAME#_values = null;\n" + ind(2) + "#NAME#_list = null;";
        else
          return ind(2) + "#NAME#_values = " + grammar().createDefaultMap + ";\n" + ind(2) + "#NAME#_list = null;\n";        
      } else {
        if(grammar().lazyMaps)
          return ind(2) + "#NAME#_values = null;\n";
        else
          return ind(2) + "#NAME#_values = " + grammar().createDefaultMap + ";\n";
      }        
    }
  }

  public String Parameter.toReferenceType() {
    return toReferenceType(getName(), getType());
  }

  public String ASTNode.toReferenceType(String value, String type) {
    if(type.equals("int"))
      return grammar().java5 ? "Integer.valueOf(" + value + ")" : "new Integer(" + value + ")";
    else if(type.equals("short"))
      return grammar().java5 ? "Short.valueOf(" + value + ")" : "new Short(" + value + ")";
    else if(type.equals("long"))
      return grammar().java5 ? "Long.valueOf(" + value + ")" : "new Long(" + value + ")";
    else if(type.equals("float"))
      return grammar().java5 ? "Float.valueOf(" + value + ")" : "new Float(" + value + ")";
    else if(type.equals("double"))
      return grammar().java5 ? "Double.valueOf(" + value + ")" : "new Double(" + value + ")";
    else if(type.equals("boolean"))
      return "Boolean.valueOf(" + value + ")";
    else if(type.equals("char"))
      return grammar().java5 ? "Character.valueOf(" + value + ")" : "new Character(" + value + ")";
    else return value;
  }

  public String ASTNode.fromReferenceType(String value, String type) {
    if(type.equals("int"))
      return "((Integer)" + value + ").intValue()";
    else if(type.equals("short"))
      return "((Short)" + value + ").shortValue()";
    else if(type.equals("long"))
      return "((Long)" + value + ").longValue()";
    else if(type.equals("float"))
      return "((Float)" + value + ").floatValue()";
    else if(type.equals("double"))
      return "((Double)" + value + ").doubleValue()";
    else if(type.equals("boolean"))
      return "((Boolean)" + value + ").booleanValue()";
    else if(type.equals("char"))
      return "((Character)" + value + ").charValue()";
    else
      return "(" + type + ")" + value;
  }

  public boolean AttrDecl.isPrimitive() {
    String type = getType();
    return type.equals("int") || type.equals("short") || type.equals("long") ||
      type.equals("float") || type.equals("double") || type.equals("boolean") ||
      type.equals("char") || type.equals("byte");
  }

  public boolean AttrDecl.isPrimitive(String type) {
    return type.equals("int") || type.equals("short") || type.equals("long") ||
      type.equals("float") || type.equals("double") || type.equals("boolean") ||
      type.equals("char") || type.equals("byte");
  }

  public boolean TokenComponent.isPrimitive() {
    String type = getTokenId().getTYPE();
    return type.equals("int") || type.equals("short") || type.equals("long") ||
      type.equals("float") || type.equals("double") || type.equals("boolean") ||
      type.equals("char") || type.equals("byte");
  }


  public String AttrDecl.cacheCheck() {
    if(!getLazy() && !isCircular())
      return "";
    if(isNTA() && !(findCorrespondingNTA() instanceof TokenComponent)) {
      int index = indexNTAchild();
      if(getNumParameter() == 0)
        return // ES_2011-09-22: Code generation for incremental evaluation, tracking
               (grammar().incremental ? genIncrementalTracking() : "") +
                //
               "if(" + attributeSignature() + "_computed) {\n" +
               traceEndCachedAttr() +
               ind + "return (" + getType() + ") getChild(" + attributeSignature() + "ChildPosition());\n" +
               "}\n";
      else
        return // ES_2011-09-22: Code generation for incremental evaluation, tracking
               (grammar().incremental ? genIncrementalTracking() : "") +
                //
               "if(" + attributeSignature() + "_values.containsKey(_parameters)) {\n" +
               traceEndCachedAttr() +
               ind + "return (" + getType() + ") getChild(" + attributeSignature() + "ChildPosition()));\n" +
               "}\n";
    }
    if(getNumParameter() == 0)
      return // ES_2011-09-22: Code generation for incremental evaluation, tracking
             (grammar().incremental ? genIncrementalTracking() : "") +
             //
             "if(" + attributeSignature() + "_computed) {\n" +
             traceEndCachedAttr() +
             ind + "return " + attributeSignature() + "_value;\n" +
             "}\n";
    else {
      if(isCircular())
        return // ES_2011-09-22: Code generation for incremental evaluation, tracking
               (grammar().incremental ? genIncrementalTracking() : "") +
               //
               "if(" + attributeSignature() + "_values.containsKey(_parameters)) {\n" +
               ind + "Object _o = " + attributeSignature() + "_values.get(_parameters);\n" +
               ind + "if(!(_o instanceof ASTNode$State.CircularValue)) {\n" +
               traceEndCachedAttr() +
               ind(2) + "return " + fromReferenceType("_o", getType()) + ";\n" +
               ind + "}\n" +
               ind + "else\n" +
               ind(2) + "_value = (ASTNode$State.CircularValue)_o;\n" +
               "}\n";
      else
        return // ES_2011-09-22: Code generation for incremental evaluation, tracking
               (grammar().incremental ? genIncrementalTracking() : "") +
               //
               "if(" + attributeSignature() + "_values.containsKey(_parameters)) {\n" +
               traceEndCachedAttr() +
               ind + "return " + fromReferenceType(attributeSignature() + "_values.get(_parameters)", getType()) + ";\n" +
               "}\n";
    }
  }

  public String AttrDecl.parameterStructure() {
    if(getNumParameter() == 0 || (!getLazy() && !isCircular() && !grammar().visitCheckEnabled)) {
      return "";
    } else if(getNumParameter() == 1) {
      return "Object _parameters = " + getParameter(0).toReferenceType() + ";\n";
    } else {
      StringBuffer s = new StringBuffer();
      s.append("java.util.List _parameters = new java.util.ArrayList(" + getNumParameter() + ");\n");
      for(int i = 0; i < getNumParameter(); i++) {
        s.append("_parameters.add(" + getParameter(i).toReferenceType() + ");\n");
      }
      return s.toString();
    }
  }

  public String AttrDecl.cacheInit(String ind) {
    if(!getLazy())
      return "";
    return cacheInitRewrite();
  }

  public String AttrDecl.cacheInitRewrite() {
    if(!grammar().rewriteEnabled) {
      return "";
    } else {
      return "int num = state.boundariesCrossed;\n" +
             "boolean isFinal = this.is$Final();";
    }
  }

  public String AttrDecl.callCompute() {
    if(getLazy() && getNumParameter() == 0)
      return ind(2) + "" + attributeSignature() + "_value = #METHODNAME#_compute(#PARM#);\n";
    else
      return ind(2) + "#TYPE# " + attributeSignature() + "_value = #METHODNAME#_compute(#PARM#);\n";
  }

  // TODO: INH
  public String InhDecl.callCompute() {
    if(getLazy() && getNumParameter() == 0) {
      return inhDebugString() +
        ind(2) + "" + attributeSignature() + "_value = getParent().Define_#TYPEINSIGNATURE#_#METHODNAME#(" + interfaceParametersStart() + ");\n";
    } else {
      return inhDebugString() +
        ind(2) + "#TYPE# " + attributeSignature() + "_value = getParent().Define_#TYPEINSIGNATURE#_#METHODNAME#(" + interfaceParametersStart() + ");\n";
    }
  }

  public String AttrDecl.cacheStoreRewrite() {
    if(!grammar().rewriteEnabled || getFinal())
      return ind + "if(true)";
    else
      return ind + "if(isFinal && num == state().boundariesCrossed)";
  }

  public String AttrDecl.cacheStore() {
    if(!getLazy())
      return "";
    if(getNumParameter() == 0) {
      return cacheStoreRewrite() + "{" +
        (grammar().incremental ? genIncrementalTrackingStackTransfer() : "") +
        " " + attributeSignature() + "_computed = true; }\n" +
        (grammar().incremental ? genIncrementalTrackingStackClear() : "");
    } else {
      return cacheStoreRewrite() + "{" +
        (grammar().incremental ? genIncrementalTrackingStackTransfer() : "") +
        " " + attributeSignature() + "_values.put(_parameters, " + toReferenceType("" + attributeSignature() + "_value", getType()) + "); }\n" +
        (grammar().incremental ? genIncrementalTrackingStackClear() + "\n" : "");
    }
  }

  public String AttrDecl.returnStmt() {
    if(isNTA() && !(findCorrespondingNTA() instanceof TokenComponent)) {
      int index = indexNTAchild();
      // ES_2011-09-22: Code generation for incremental evaluation, stack
      return getType() + " node = (" + getType() + ") this.getChild(" + attributeSignature() + "ChildPosition());\n" +
          (grammar().incremental ? genIncrementalTrackingStackExit() : "") +
          ind(2) + "return node;\n";
      // OLD: return "return (" + getType() + ") this.getChild(" + attributeSignature() + "ChildPosition());\n";
      //
    }

    if (isCircular()) {
      return ind(2) + "return " + attributeSignature() + "_value;\n";
    }

    // ES_2011-09-22: Code generation for incremental evaluation, stack
    return (grammar().incremental ? genIncrementalTrackingStackExit() : "") +
        ind(2) + "return " + attributeSignature() + "_value;\n";
    // OLD: return "return " + attributeSignature() + "_value;\n";
    //
  }

  syn boolean AttrEq.hasComputeBlock() = true;
  eq SynEq.hasComputeBlock() = getRHS() instanceof ASTBlock;

  /**
   * @return Compute method without "_compute" suffix
   */
  public void AttrDecl.emitInlineCompute(AttrEq equ, PrintStream out) {
    TemplateContext tt = templateContext();
    tt.bind("ParamDecl", equ.parametersDecl());
    tt.bind("ComputeBody", equ.computeMethodBody());
    tt.expand("AttrDecl.emitInlineCompute", out);
  }

  public String AttrEq.computeMethodBody() {
    return "{ }";
  }

  public String SynEq.computeMethodBody() {
    if(hasComputeBlock())
      return Unparser.unparse(getRHS());
    else
      return "{  return " + Unparser.unparse(getRHS()) + ";  }";
  }

  /**
   * @return Code for the method to compute this attribute
   */
  public String AttrEq.computeMethod() {
    return "";
  }

  public String SynEq.computeMethod() {
    return
      ind + "/**\n" +
      ind + " * @apilevel internal\n" +
      ind + " */\n" +
      ind + "private #TYPE# #METHODNAME#_compute(#PARMDECL#) " + computeMethodBody() + "\n";
  }

  syn String AttrDecl.inhDebugString() {
    if(!grammar().debugMode) {
      return "";
    } else {
      return ind(2) + "if(getParent() == null) throw new RuntimeException(\"Trying to evaluate attribute in subtree not attached to main tree\");\n";
    }
  }

  public boolean TypeDecl.hasLazySynEqFor(AttrDecl attr) {
    if(attr instanceof SynDecl) {
      SynEq synEq = lookupSynEq(attr.signature());
      return synEq != null && (synEq.decl().getLazy() || synEq.decl().isCircular()) ;
    }
    return false;
  }

  syn String AttrDecl.cycleLimitCheck() = "";
   // TODO: fixme cycleLimit > 0 ?
   //    "if(state().CIRCLE_INDEX > " + cycleLimit + ") throw new java.lang.RuntimeException(\"Iteration limit " + cycleLimit + " exceeded\");\n" : "";

  /**
   * Generates the method to compute an attribute
   * @param attr The attribute we are adding a compute method for
   */
  public String ASTDecl.genEquation(AttrDecl attr) {
    if (!attr.isCircular()) {
      return
           suppressWarnings() +
           ind + "public #TYPE# #METHODNAME#(#PARMDECL#) {\n" +
           (grammar().block ? ind(2) + grammar().blockBegin : "") +
           attr.parameterStructure() +
           attr.traceBeginAttr() +
           attr.initLazyMaps() +
           attr.cacheCheck() +
           // ES_2011-09-22: Code generation for incremental evaluation, tracking
           (grammar().incremental ? attr.genIncrementalTrackingStackEnter() : "") + 
           //
           (grammar().rewriteEnabled ? ind(3) + "ASTNode$State state = state();\n" : "") +
           attr.addInterruptedCircleDeclaration() +
           attr.visitedCheck() +
           attr.setVisited() +
           attr.addCheckInterruptedCircle() +
           attr.cacheInit(ind) +
           attr.callCompute() +
           attr.higherOrderAttributeCode() +
           attr.cacheStore() +
           attr.clearVisited() +
           attr.addClearInterruptedCircle() +
           attr.traceEndAttr() +
           ind(2) + attr.returnStmt() +
           (grammar().block ? ind(2) + grammar().blockEnd : "") +
           ind + "}\n";
    }
    else {
      if(attr.getNumParameter() == 0) {
        return
           suppressWarnings() +
           ind + "public #TYPE# #METHODNAME#(#PARMDECL#) {\n" +
           (grammar().block ? grammar().blockBegin : "") +
           attr.traceComputeContext() +
           attr.parameterStructure() +
           attr.cacheCheck() +
           ind(2) + "ASTNode$State state = state();\n" +
           attr.addComponentCheck() +
           ind(2) + "if (!" + attr.attributeSignature() + "_initialized) {\n" +
           ind(3) + "" + attr.attributeSignature() + "_initialized = true;\n" +
           ind(3) + "" + attr.attributeSignature() + "_value = " + Unparser.unparse(attr.getBottomValue()) + ";\n" +
           ind(2) + "}\n" +
           ind(2) + "if (!state.IN_CIRCLE) {\n" +
           ind(3) + "state.IN_CIRCLE = true;\n" +
           attr.tracePrintCycleBeginString() +
           attr.addAddToComponent() +
           attr.cacheInitRewrite() +
           // TODO: fixme
           // ind(3) + "state().CIRCLE_INDEX = 1;\n" +
           ind(3) + "do {\n" +
           ind(4) + "" + attr.attributeSignature() + "_visited = state.CIRCLE_INDEX;\n" +
           ind(4) + "state.CHANGE = false;\n" +
           attr.inhDebugString() +
           attr.tracePrintBeginComputingValue() +
           // ES_2012-01-25: Code generation for incremental evaluation, tracking
           (grammar().incremental ? attr.genIncrementalTrackingStackEnter2() : "") + 
           //
           ind(4) + "#TYPE# new_" + attr.attributeSignature() + "_value = " + attr.circularComputeCall() + ";\n" +
           // ES_2012-01-25: Code generation for incremental evaluation, tracking
           (grammar().incremental ? attr.genIncrementalTrackingStackExit2() : "") + 
           //
           ind(4) + "if (" + attr.differs("new_" + attr.attributeSignature() + "_value", "" + attr.attributeSignature() + "_value") + ")\n" +
           ind(5) + "state.CHANGE = true;\n" +
           ind(4) + "" + attr.attributeSignature() + "_value = new_" + attr.attributeSignature() + "_value; \n" +
           ind(4) + "state.CIRCLE_INDEX++;\n" +
           attr.tracePrintStartingCycle() +
           attr.cycleLimitCheck() +
           ind(3) + "} while (state.CHANGE);\n" +
           ind(3) + attr.cacheStoreRewrite() + " {\n" +
           ind(3) + "" + attr.attributeSignature() + "_computed = true;\n" +
           attr.cacheCycleInit() +
           ind(3) + "}\n" +
           ind(3) + "else {\n" +
           attr.resetCycleInit() +
           ind(4) + "" + attr.attributeSignature() + "_computed = false;\n" +
           ind(4) + "" + attr.attributeSignature() + "_initialized = false;\n" +
           ind(3) + "}\n" +
           ind(3) + "state.IN_CIRCLE = false; \n" +
           attr.tracePrintReturnNewValue("" + attr.attributeSignature() + "_value") +
           attr.tracePrintCycleEndString() +
           ind(3) + attr.returnStmt() +
           ind(2) + "}\n" +
           ind(2) + "if(" + attr.attributeSignature() + "_visited != state.CIRCLE_INDEX) {\n" +
           ind(3) + "" + attr.attributeSignature() + "_visited = state.CIRCLE_INDEX;\n" +
           attr.cacheCycleCheck() +
           attr.resetCycleCheck() +
           attr.addAddToComponent() +
           attr.inhDebugString() +
           attr.tracePrintBeginComputingValue() +
           // ES_2012-01-25: Code generation for incremental evaluation, tracking
           (grammar().incremental ? attr.genIncrementalTrackingStackEnter2() : "") + 
           //
           ind(3) + "#TYPE# new_" + attr.attributeSignature() + "_value = " + attr.circularComputeCall() + ";\n" +
           // ES_2012-01-25: Code generation for incremental evaluation, tracking
           (grammar().incremental ? attr.genIncrementalTrackingStackExit2() : "") + 
           //
           ind(3) + "if (" + attr.differs("new_" + attr.attributeSignature() + "_value", "" + attr.attributeSignature() + "_value") + ")\n" +
           ind(4) + "state.CHANGE = true;\n" +
           ind(3) + "" + attr.attributeSignature() + "_value = new_" + attr.attributeSignature() + "_value; \n" +
           attr.tracePrintReturnNewValue("" + attr.attributeSignature() + "_value") +
           ind(3) + attr.returnStmt() +
           ind(2) + "}\n" +
           attr.tracePrintReturnPreviousValue("" + attr.attributeSignature() + "_value") +
           ind(2) + attr.returnStmt() +
           (grammar().block ? grammar().blockEnd : "") +
           ind + "}\n";
      }
      else {
        return
           suppressWarnings() +
           ind + "public #TYPE# #METHODNAME#(#PARMDECL#) {\n" +
           (grammar().block ? grammar().blockBegin : "") +
           attr.traceComputeContext() +
           attr.parameterStructure() +
           attr.initLazyMaps() +
           ind(2) + "ASTNode$State.CircularValue _value;\n" +
           attr.cacheCheck() +
           ind(2) + "else {\n" +
           ind(3) + "_value = new ASTNode$State.CircularValue();\n" +
           ind(3) + "" + attr.attributeSignature() + "_values.put(_parameters, _value);\n" +
           ind(3) + "_value.value = " + toReferenceType(Unparser.unparse(attr.getBottomValue()), attr.getType()) + ";\n" +
           ind(2) + "}\n" +
           ind(2) + "ASTNode$State state = state();\n" +
           attr.addComponentCheck() + 
           ind(2) + "if (!state.IN_CIRCLE) {\n" +
           ind(3) + "state.IN_CIRCLE = true;\n" +
           attr.tracePrintCycleBeginString() +
           attr.cacheInitRewrite() +
           attr.addAddToComponent() +
           // TODO: fixme
           // ind(3) + "state().CIRCLE_INDEX = 1;\n" +
           ind(3) + "#TYPE# new_" + attr.attributeSignature() + "_value;\n" +
           ind(3) + "do {\n" + 
           // EMMA_2011-09-08: Adding java1.4 code
           (grammar().java5 ? 
             ind(4) + "_value.visited = new Integer(state.CIRCLE_INDEX);\n"
           :
             ind(4) + "_value.visited = state.CIRCLE_INDEX;\n"
           ) +
           ind(4) + "state.CHANGE = false;\n" +
           attr.inhDebugString() +
           attr.tracePrintBeginComputingValue() +
           // ES_2012-09-25: Code generation for incremental evaluation, tracking
           (grammar().incremental ? attr.genIncrementalTrackingStackEnter2() : "") + 
           //
           ind(4) + "new_" + attr.attributeSignature() + "_value = " + attr.circularComputeCall() + ";\n" +
           // ES_2012-09-25: Code generation for incremental evaluation, tracking
           (grammar().incremental ? attr.genIncrementalTrackingStackExit2() : "") + 
           //
           ind(4) + "if (" + attr.differs("new_" + attr.attributeSignature() + "_value", fromReferenceType("_value.value", attr.getType())) + ") {\n" +
           ind(5) + "state.CHANGE = true;\n" +
           ind(5) + "_value.value = " + toReferenceType("new_" + attr.attributeSignature() + "_value", attr.getType()) + ";\n" +
           ind(4) + "}\n" +
           ind(4) + "state.CIRCLE_INDEX++;\n" +
           attr.tracePrintStartingCycle() +
           attr.cycleLimitCheck() +
           ind(3) + "} while (state.CHANGE);\n" +
           ind(3) + attr.cacheStoreRewrite() + " {\n" +
           // EMMA_2011-09-08: Adding java1.4 code
           (grammar().java5 ?
             ind(4) + "" + attr.attributeSignature() + "_values.put(_parameters, new_" + attr.attributeSignature() + "_value);\n"
           : 
             ind(4) + "" + attr.attributeSignature() + "_values.put(_parameters, " + toReferenceType("new_" + attr.attributeSignature() + "_value", attr.getType()) + ");\n"
           ) +
           attr.cacheCycleInit() +
           ind(3) + "}\n" +
           ind(3) + "else {\n" +
           ind(4) + "" + attr.attributeSignature() + "_values.remove(_parameters);\n" +
           attr.resetCycleInit() +
           ind(3) + "}\n" +
           ind(3) + "state.IN_CIRCLE = false; \n" +
           attr.tracePrintReturnNewValue("new_" + attr.attributeSignature() + "_value") +
           attr.tracePrintCycleEndString() +
           ind(3) + "return new_" + attr.attributeSignature() + "_value;\n" +
           ind(2) + "}\n" +
           // EMMA_2011-09-08: Adding java1.4 code
           (grammar().java5 ?
             ind(2) + "if(!new Integer(state.CIRCLE_INDEX).equals(_value.visited)) {\n"
           :
             ind(2) + "if(!new Integer(state.CIRCLE_INDEX).equals(Integer.valueOf(_value.visited))) {\n"
           ) +
           // EMMA_2011-09-08: Adding java1.4 code
           (grammar().java5 ?
             ind(3) + "_value.visited = new Integer(state.CIRCLE_INDEX);\n"
           :
             ind(3) + "_value.visited = state.CIRCLE_INDEX;\n" 
            ) +
           attr.inhDebugString() +
           attr.tracePrintBeginComputingValue() +
           // ES_2012-09-25: Code generation for incremental evaluation, tracking
           (grammar().incremental ? attr.genIncrementalTrackingStackEnter2() : "") + 
           //
           ind(3) + "#TYPE# new_" + attr.attributeSignature() + "_value = " + attr.circularComputeCall() + ";\n" +
           // ES_2012-09-25: Code generation for incremental evaluation, tracking
           (grammar().incremental ? attr.genIncrementalTrackingStackExit2() : "") + 
           //
           attr.cacheCycleCheck() + 
           attr.resetCycleCheck() +
           ind(3) + "else if (" + attr.differs("new_" + attr.attributeSignature() + "_value", fromReferenceType("_value.value", attr.getType())) + ") {\n" +
           ind(4) + "state.CHANGE = true;\n" +
           // EMMA_2011-09-08: Adding java1.4 code
           (grammar().java5 ?
             ind(4) + "_value.value = new_" + attr.attributeSignature() + "_value;\n" 
           :
             ind(4) + "_value.value = " + toReferenceType("new_" + attr.attributeSignature() + "_value", attr.getType()) + ";\n" 
           ) +
           ind(3) + "}\n" +
           attr.tracePrintReturnNewValue("new_" + attr.attributeSignature() + "_value") +
           ind(3) + "return new_" + attr.attributeSignature() + "_value;\n" +
           ind(2) + "}\n" +
           attr.tracePrintReturnPreviousValue(fromReferenceType("" + attr.attributeSignature() + "_values.get(_parameters)" , attr.getType())) +
           ind(2) + "return " + fromReferenceType("_value.value" , attr.getType()) + ";\n" +
           (grammar().block ? grammar().blockEnd : "") +
           ind + "}\n";
      }
    }
  }

  public String AttrDecl.circularComputeCall() { return ""; }
  public String SynDecl.circularComputeCall() { return "#METHODNAME#_compute(#PARM#)"; }
  public String InhDecl.circularComputeCall() {
    return "getParent().Define_#TYPEINSIGNATURE#_#METHODNAME#(" + interfaceParametersStart() + ")";
  }

  public String AttrDecl.resetCycleInit() {
     return
        ind(3) + "state.RESET_CYCLE = true;\n" +
        inhDebugString() +
        ind(3) + circularComputeCall() + ";\n" +
        ind(3) + "state.RESET_CYCLE = false;\n";
  }

  public String AttrDecl.resetCycleCheck() {
     if(getNumParameter() == 0)
       return
         ind(3) + "if (state.RESET_CYCLE) {\n" +
         ind(4) + "" + attributeSignature() + "_computed = false;\n" +
         ind(4) + "" + attributeSignature() + "_initialized = false;\n" +
         ind(4) + "" + attributeSignature() + "_visited = -1;\n" +
         ind(4) + returnStmt() +
         ind(3) + "}\n";
     else
       return
         ind(3) + "if (state.RESET_CYCLE) {\n" +
         ind(4) + "" + attributeSignature() + "_values.remove(_parameters);\n" +
         ind(3) + "}\n";
  }

  public String AttrDecl.cacheCycleInit() {
     if (!grammar().cacheCycle) return "";
     return
        ind(3) + "state.LAST_CYCLE = true;\n" +
        inhDebugString() +
        ind(3) + circularComputeCall() + ";\n" +
        ind(3) + "state.LAST_CYCLE = false;\n";
  }

  public String AttrDecl.cacheCycleCheck() {
     if (!grammar().cacheCycle) return "";
     if(getNumParameter() == 0)
       return
         ind(3) + "if (state.LAST_CYCLE) {\n" +
         ind(4) + "" + attributeSignature() + "_computed = true;\n" +
         inhDebugString() +
         // ES_2011-09-23: Code generation for incremental evaluation, 
         // separating return stmt to place a tracking statement in the middle 
         (grammar().incremental ? genIncrementalTrackingStackEnter2() : "") +
         ind(4) + "#TYPE# new_" + attributeSignature() + "_value = " + circularComputeCall() + ";\n" +
         (grammar().incremental ? genIncrementalTrackingStackExit2() : "") +
         ind(4) + "return new_" + attributeSignature() + "_value;\n" +
         // OLD: ind(4) + "return " + circularComputeCall() + ";\n" +
         //
         ind(3) + "}\n";
     else {
       // EMMA_2011-09-08: Adding java1.4 code
       if (grammar().java5) 
         return
           ind(3) + "if (state.LAST_CYCLE) {\n" +
           inhDebugString() +
           ind(4) + "" + attributeSignature() + "_values.put(_parameters, new_" + attributeSignature() + "_value);\n" +
           ind(3) + "}\n";
       else
         return
           ind(3) + "if (state.LAST_CYCLE) {\n" +
           inhDebugString() +
           ind(4) + "" + attributeSignature() + "_values.put(_parameters, " + toReferenceType("new_" + attributeSignature() + "_value", getType()) + ");\n" +
           ind(3) + "}\n";
     }
  }

  public String AttrDecl.addComponentCheck() {
    if(!grammar().componentCheck || !grammar().visitCheckEnabled) return "";
    String arg = getNumParameter() == 0 ? "null" : "_parameters";
    if(getNumParameter() == 0) {
      if(grammar().rewriteEnabled)
        return
        ind(2) + "if(" + attributeSignature() + "_visited == state.boundariesCrossed && !state.containsEvalEntry(this, \"" + attributeSignature() + "\", null))\n" +
        ind(3) + "throw new java.lang.RuntimeException(\"XXX\");\n";
      else
        return
        ind(2) + "if(" + attributeSignature() + "_visited != -1 && !state.containsEvalEntry(this, \"" + attributeSignature() + "\", null))\n" +
        ind(3) + "throw new java.lang.RuntimeException(\"XXX\");\n";
    }
    else {
      if(grammar().rewriteEnabled) {
        // EMMA_2011-09-08: Adding support for java1.4
        if (grammar().java5) 
          return
          ind(2) + "if(new Integer(state.boundariesCrossed).equals(_value.visited) && !state.containsEvalEntry(this, \"" + attributeSignature() + "\", _parameters))\n" +
          ind(3) + "throw new java.lang.RuntimeException(\"XXX\");\n";
        else 
          return
          ind(2) + "if(new Integer(state.boundariesCrossed).equals(Integer.valueOf(_value.visited)) && !state.containsEvalEntry(this, \"" + attributeSignature() + "\", _parameters))\n" +
          ind(3) + "throw new java.lang.RuntimeException(\"XXX\");\n";    
      } else
        return
        ind(2) + "if(_value.visited != -1 && !state.containsEvalEntry(this, \"" + attributeSignature() + "\", _parameters))\n" +
        ind(3) + "throw new java.lang.RuntimeException(\"XXX\");\n";
    }
  }

  public String AttrDecl.addAddToComponent() {
    if(!grammar().componentCheck || !grammar().visitCheckEnabled) return "";
    if(getNumParameter() == 0)
      return
        ind(2) + "state.addEvalEntry(this, \"" + attributeSignature() + "\", null);\n";
    else
      return
        ind(2) + "state.addEvalEntry(this, \"" + attributeSignature() + "\", _parameters);\n";
  }

  public String AttrDecl.addInterruptedCircleDeclaration() {
    if(!grammar().componentCheck) return "";
    return "boolean interruptedCircle = false;\n";
  }

  public String AttrDecl.addCheckInterruptedCircle() {
    if(!grammar().componentCheck) return "";
    return
      "if(state.IN_CIRCLE) {\n" +
      ind + "interruptedCircle = true;\n" +
      ind + "state.IN_CIRCLE = false;\n" +
      ind + "state.pushEvalStack();\n" +
      "}\n";
  }

  public String AttrDecl.addClearInterruptedCircle() {
    if(!grammar().componentCheck) return "";
    return
      "if(interruptedCircle) {\n" +
      ind + "state.IN_CIRCLE = true;\n" +
      ind + "state.popEvalStack();\n" +
      "}\n";
  }

  public String AttrDecl.differs(String s1, String s2) {
    if (isPrimitive())
      return s1 + "!=" + s2;
    else
      return "(" + s1 + "==null && " + s2 + "!=null) || (" + s1 + "!=null && !" + s1 + ".equals(" + s2 + "))";
  }

  public void ASTDecl.emitCacheDeclarations(PrintStream out, AttrDecl attr) {
    boolean needsCacheDeclaration = true;
    if(attr instanceof SynDecl) {
      // EMMA_2011-09-13: Setting this to true to get declarations for each 
      // equation of an attribute. If an equation lacks its own visited declaration
      // and calls an overriden equation it can cause a circularity exception.
      needsCacheDeclaration = true; // superClass() == null || !superClass().hasLazySynEqFor(attr);
    }
    if (!attr.isCircular()) {
      if (needsCacheDeclaration) {
        attr.emitVisitedDeclarations(out);
        attr.emitCacheDeclarations(out);
      }
    } else {
      if (attr.getNumParameter() == 0) {
        if (!needsCacheDeclaration && attr instanceof SynDecl &&
            superClass() != null && superClass().lookupSynEq(attr.signature()) != null
            && !superClass().lookupSynEq(attr.signature()).decl().isCircular()) {

          needsCacheDeclaration = true;
        }
        if (needsCacheDeclaration) {
          attr.emitVisitedDeclarations(out);
          out.println(ind + "/**");
          out.println(ind + " * @apilevel internal");
          out.println(ind + " */");
          out.println(ind + "protected boolean " + attr.attributeSignature() + "_computed = false;");
          out.println(ind + "/**");
          out.println(ind + " * @apilevel internal");
          out.println(ind + " */");
          out.println(ind + "protected boolean " + attr.attributeSignature() + "_initialized = false;");
          out.println(ind + "/**");
          out.println(ind + " * @apilevel internal");
          out.println(ind + " */");
          out.println(ind + "protected " + attr.getType() + " " + attr.attributeSignature() + "_value;");
          return;
        }
      }
      else {
        if (needsCacheDeclaration) {
          attr.emitVisitedDeclarations(out);
          if (grammar().lazyMaps) {
            out.println(ind + "protected " + grammar().typeDefaultMap + " " + attr.attributeSignature() + "_values;");
            return;
          } else {
            out.println(ind + "protected " + grammar().typeDefaultMap + " " + attr.attributeSignature() + "_values = " + grammar().createDefaultMap + ";");
            return;
          }
        }
      }
    }
  }

  public void ASTDecl.emitSynEquations(PrintStream out) {
    for(int i = 0; i < getNumSynEq(); i++) {
       AttrEq equ = getSynEq(i);
       AttrDecl attr = equ.decl();
       String s = "";
       if (attr.isNTA() || attr.getLazy() || attr.isCircular()) {
         s += equ.hostFileComment(ind);
         s += genEquation(attr);
         s += equ.computeMethod();
       } else {
         attr.emitInlineCompute(equ, out);
         if (!s.isEmpty())
           s = attr.hostFileComment(ind) + s;
       }
       s = s.replaceAll("#TYPE#", attr.getType());
       s = s.replaceAll("#TYPEINSIGNATURE#", attr.getTypeInSignature());
       s = s.replaceAll("#NAME#", attr.attributeSignature());
       s = s.replaceAll("#METHODNAME#", attr.attributeName());
       s = s.replaceAll("#PARMDECL#", equ.parametersDecl());
       s = s.replaceAll("#PARM#", attr.parameters());
       out.print(s);

       emitCacheDeclarations(out, attr);
    }
  }


  public boolean AttrDecl.isNTA() {
    return false;
  }

  public boolean SynDecl.isNTA() {
    return findCorrespondingNTA() != null;
  }

  public int AttrDecl.indexNTAchild() {
    Components comp = findCorrespondingNTA();
    TypeDecl c = hostClass();
    while(c != null) {
      int index = 0;
      for(Iterator iter = c.getComponents(); iter.hasNext(); ) {
        Components next = (Components)iter.next();
        if(next == comp)
          return index;
        if(!(next instanceof TokenComponent))
          index++;
      }
      c = c instanceof ASTDecl ? ((ASTDecl)c).superClass() : null;
    }
    return -1;
  }

  public Components AttrDecl.findCorrespondingNTA() {
    if(!getName().startsWith("get"))
      return null;
    String attrName = getName().substring(3);
    TypeDecl c = hostClass();
    while(c != null) {
      for(Iterator iter = c.getComponents(); iter.hasNext(); ) {
        Components comp = (Components)iter.next();
        if(comp.name().equals(attrName) && (
            comp instanceof OptionalComponentNTA
            || comp instanceof TokenComponentNTA
            || comp instanceof AggregateComponentsNTA )) {
          return comp;
        }
        if(attrName.equals(comp.name() + "Opt") && comp instanceof OptionalComponentNTA) {
          return comp;
        }
        if(attrName.equals(comp.name() + "List") && comp instanceof ListComponentsNTA) {
          return comp;
        }
      }
      c = c instanceof ASTDecl ? ((ASTDecl)c).superClass() : null;
    }
    return null;
  }

  public String AttrDecl.higherOrderAttributeCode() {
    return "";
  }

  public String SynDecl.higherOrderAttributeCode() {
    if(getNTA()) {
      TemplateContext tt = templateContext();
      tt.bind("NonParameterized", getNumParameter() == 0);

      if(grammar().rewriteEnabled) {
        if(grammar().stagedRewrites) {
          return tt.expand("SynDecl.higherOrderAttributeCode:stagedrewrites");
        } else {
          return tt.expand("SynDecl.higherOrderAttributeCode:nostagedrewrites");
        }
      } else {
        return tt.expand("SynDecl.higherOrderAttributeCode:norewrite");
      }
    } else {
      // non-NTA
      StringBuffer result = new StringBuffer();
      Components comp = findCorrespondingNTA();
      if(comp != null) {
        String attrName = getName().substring(3); // remove get
        if(comp.name().equals(attrName) && (
              comp instanceof OptionalComponentNTA
              || comp instanceof TokenComponentNTA
              || comp instanceof AggregateComponentsNTA )) {
          result.append(ind(3) + "set" + attrName + "(" + attributeSignature() + "_value);\n");
        }
        if(attrName.equals(comp.name() + "Opt") && comp instanceof OptionalComponentNTA) {
          result.append(ind(2) + "set" + attrName + "(" + attributeSignature() + "_value);\n");
        }
        if(attrName.equals(comp.name() + "List") && comp instanceof ListComponentsNTA) {
          result.append(ind(2) + "set" + attrName + "(" + attributeSignature() + "_value);\n");
        }
      }
      return result.toString();
    }
  }

  public void TypeDecl.emitInhDeclarations(PrintStream out) {
    for(int i = 0; i < getNumInhDecl(); i++) {
       AttrDecl attr = getInhDecl(i);
       out.print(attr.hostFileComment(ind));
       attr.emitInhDecl(out);
    }
  }

  public void AttrDecl.emitInhDecl(PrintStream out) {
    templateContext().expand("AttrDecl.inhDecl", out);
  }

  public void ASTDecl.emitInhDeclarations(PrintStream out) {
    for(int i = 0; i < getNumInhDecl(); i++) {
       AttrDecl attr = getInhDecl(i);
       out.print(attr.hostFileComment(ind));
       String s;
       s = genEquation(attr);
       s = s.replaceAll("#TYPE#", attr.getType());
       s = s.replaceAll("#TYPEINSIGNATURE#", attr.getTypeInSignature());
       s = s.replaceAll("#NAME#", attr.attributeSignature());
       s = s.replaceAll("#METHODNAME#", attr.attributeName());
       s = s.replaceAll("#PARMDECL#", attr.parametersDecl());
       s = s.replaceAll("#PARM#", attr.parameters());
       s = s.replaceAll("#INTERFACEPARM#", attr.interfaceParameters());
       out.print(s);

       emitCacheDeclarations(out, attr);
    }
  }

  syn boolean TypeDecl.hasInhEq(String attrName) {
    for(int i = 0; i < getNumInhEq(); i++) {
      InhEq equ = getInhEq(i);
      if(equ.getName().equals(attrName)) {
        return true;
      }
    }
    return false;
  }
  eq ASTDecl.hasInhEq(String attrName) =
    super.hasInhEq(attrName) || superClass() != null && superClass().hasInhEq(attrName);

  syn Components InhEq.getComponents() {
    TypeDecl c = hostClass();
    if(c != null)
      return c.components(sonName());
    return  null;
  }
  syn String InhEq.sonName() = getSonName().startsWith("get") ? getSonName().substring(3) : getSonName();

  syn AttrDecl InhEq.getSonAttrDecl() {
    AttrDecl decl = hostClass().lookupSynDeclPrefix(sonName());
    if(decl == null) decl = hostClass().lookupInhDeclPrefix(sonName());
    return decl;
  }

  syn SynDecl TypeDecl.lookupSynDeclPrefix(String signature) {
    for(int i = 0; i < getNumSynDecl(); i++)
      if(getSynDecl(i).signature().equals(signature) || getSynDecl(i).signature().startsWith(signature + "_"))
        return getSynDecl(i);
    return null;
  }
  eq ASTDecl.lookupSynDeclPrefix(String signature) {
    SynDecl decl = super.lookupSynDeclPrefix(signature);
    if(decl != null || superClass() == null)
      return decl;
    return superClass().lookupSynDeclPrefix(signature);
  }
  syn InhDecl TypeDecl.lookupInhDeclPrefix(String signature) {
    for(int i = 0; i < getNumInhDecl(); i++)
      if(getInhDecl(i).signature().equals(signature) || getInhDecl(i).signature().startsWith(signature + "_"))
        return getInhDecl(i);
    return null;
  }
  syn InhDecl ASTDecl.lookupInhDeclPrefix(String signature) {
    InhDecl decl = super.lookupInhDeclPrefix(signature);
    if(decl != null || superClass() == null)
      return decl;
    return superClass().lookupInhDeclPrefix(signature);
  }


  public void ASTDecl.emitInhEquations(PrintStream out) {
    for(Iterator idIter = inhAttrSet(); idIter.hasNext(); ) {
      String attrId = (String)idIter.next();
      Iterator iter = inhAttrEqs(attrId);
      InhEq equ = (InhEq)iter.next();
      InhDecl decl = (InhDecl)equ.decl();

      String s;
      out.println(ind + "/**");
      out.println(ind + " * " + equ.declaredat());
      out.println(ind + " * @apilevel internal");
      out.println(ind + " */");
      s = ind + "public #TYPE# Define_#TYPEINSIGNATURE#_#METHODNAME#(#INTERFACEPARMDECL#) {";
      s = s.replaceAll("#TYPE#", decl.type());
      s = s.replaceAll("#TYPEINSIGNATURE#", decl.getTypeInSignature());
      s = s.replaceAll("#NAME#", decl.attributeSignature());
      s = s.replaceAll("#METHODNAME#", decl.attributeName());
      s = s.replaceAll("#PARMDECL#", decl.parametersDecl());
      s = s.replaceAll("#INTERFACEPARMDECL#", decl.interfaceParametersDecl());
      out.println(s);

      // have we already generated a component equation?
      boolean hasComponentEq = false;
      boolean hasGetChildEq = false;

      do {
        s = ind(2);
        if (hasComponentEq) {
          s += "else ";
        }
        hasComponentEq = true;

        Components c = equ.getComponents();
        if(c instanceof ListComponents) {
          s += "if(caller == get#NAME#ListNoTransform())";
        }
        else if(c instanceof OptionalComponent) {
          s += "if(caller == get#NAME#OptNoTransform())";
        }
        else if(c != null) {
          s += "if(caller == get#NAME#NoTransform())";
        }
        else if(equ.getSonName().equals("getChild")) {
          hasGetChildEq = true;
        }
        else {
          AttrDecl attrDecl = equ.getSonAttrDecl();
          if(attrDecl.getNumParameter() == 0)
            s += "if(caller == #NAME#_value)";
          else
            s += "if(caller == " + attrDecl.signature() + "_list)";
        }

        s = s.replaceAll("#NAME#", String.valueOf(equ.sonName()));
        if(c instanceof ListComponents) {
          String childIndex = equ.hasIndex() ? equ.getIndex().getName() : "childIndex";
          if(equ.getRHS() instanceof ASTBlock) { // Block
            s +=
              ind +"{ \n" +
              ind(2) + "int " + childIndex + " = caller.getIndexOfChild(child);\n" +
              ind(2) + Unparser.unparse(equ.getRHS()) + "\n" +
              ind + "}\n";
          }
          else { // Expr
            s +=
              ind + "{\n" +
              ind(2) + "int " + childIndex + " = caller.getIndexOfChild(child);\n" +
              ind(2) + "return " + Unparser.unparse(equ.getRHS()) + ";\n" +
              ind + "}\n";
          }

        }
        else if(c != null) {
          if(equ.getRHS() instanceof ASTBlock) { // Block
            s += Unparser.unparse(equ.getRHS()) + "\n";
          }
          else { // Expr
            s += " {\n" +
              ind(3) + "return " + Unparser.unparse(equ.getRHS()) + ";\n" +
              ind(2) + "}\n";
          }
        }
        else if(equ.getSonName().equals("getChild")) {
          String childIndex = equ.hasIndex() ? equ.getIndex().getName() : "childIndex";
          if(equ.getRHS() instanceof ASTBlock) { // Block
            s += " { \n   int " + childIndex + " = this.getIndexOfChild(caller);\n" +
              Unparser.unparse(equ.getRHS()) + "\n" +
              ind(2) + "}\n";
          }
          else { // Expr
            s += " {\n" +
                  ind(3) + "int " + childIndex + " = this.getIndexOfChild(caller);\n" +
                  ind(3) + "return " + Unparser.unparse(equ.getRHS()) + ";\n" +
                  ind(2) + "}\n";
          }
        }
        else {
          AttrDecl attrDecl = equ.getSonAttrDecl();
          s += "{\n";
          if(attrDecl.getNumParameter() != 0) {
            String childIndex = equ.hasIndex() ? equ.getIndex().getName() : "childIndex";
            s += ind(3) + "int " + childIndex + " = caller.getIndexOfChild(child);\n";
          }
          if(equ.getRHS() instanceof ASTBlock) { // Block
            s += Unparser.unparse(equ.getRHS()) + "\n";
            s += ind(2) + "}\n";
          }
          else { // Expr
            s += ind(3) + "return " + Unparser.unparse(equ.getRHS()) + ";\n" +
                    ind(2) + "}\n";
          }
        }
        out.print(s);

        if(iter.hasNext()) {
          equ = (InhEq)iter.next();
        }
        else {
          equ = null;
        }
      } while(equ != null);

      if (!hasGetChildEq) {
        s = ind(2);
        if (hasComponentEq) {
          s += "else {";
        }
        if(superClass() != null && superClass().hasInhEq(decl.name())) {
          s += ind(3) + "return super.Define_#TYPEINSIGNATURE#_#METHODNAME#(#INTERFACEPARM#);\n" +
              ind(2) + "}\n";
        }
        else {
          // TODO: INH
          s += decl.inhDebugString() +
            ind(3) +   "return getParent().Define_#TYPEINSIGNATURE#_#METHODNAME#(" + decl.interfaceParametersContinue() + ");\n" +
            ind(2) + "}\n";
        }
        s = s.replaceAll("#NAME#", decl.attributeSignature());
        s = s.replaceAll("#METHODNAME#", decl.attributeName());
        s = s.replaceAll("#TYPE#", decl.type());
        s = s.replaceAll("#TYPEINSIGNATURE#", decl.getTypeInSignature());
        s = s.replaceAll("#PARM#", decl.parameters());
        s = s.replaceAll("#INTERFACEPARM#", decl.interfaceParameters());
        out.print(s);
      }
      out.println(ind + "}");
    }
  }

  public Iterator Grammar.inhAttrSet() {
    return inhEqMap().keySet().iterator();
  }

  syn lazy HashMap Grammar.inhEqMap() {
    HashMap map = new LinkedHashMap();
    for(int i = 0; i < getNumTypeDecl(); i++) {
      if(getTypeDecl(i) instanceof ASTDecl) {
        map.putAll(((ASTDecl)getTypeDecl(i)).inhEqMap());
      }
    }
    return map;
  }

  syn lazy String Rewrite.aspectName() =
    getAspectName();

  public void Grammar.genResetDuringCounters(PrintWriter out) {
    for(Iterator iter = rewriteAspects().iterator(); iter.hasNext(); ) {
      String name = (String)iter.next();
      String s =
                 ind(2) + "if(during" + name + " != 0) {\n" +
                 ind(3) + "System.out.println(\"Warning: resetting during" + name + "\");\n" +
                 ind(3) + "during" + name + " = 0;\n" +
                 ind(2) + "}\n";
      out.print(s);
    }

  }

  syn String AttrEq.inhDebugString() = decl().inhDebugString();

  public void AttrEq.emitInhEqSignature(PrintStream out) {
    templateContext().expand("AttrEq.emitInhEqSignature", out);
  }

  //  TODO: INH
  public void ASTDecl.emitInhEqSignatures(PrintStream out) {
    if(name().equals("ASTNode")) {
      for(Iterator iter = env().inhEqMap().entrySet().iterator(); iter.hasNext(); ) {
        java.util.Map.Entry entry = (java.util.Map.Entry)iter.next();
        String attrId = (String)entry.getKey();
        AttrEq attr = (AttrEq)((LinkedList)entry.getValue()).get(0);
        if(!hasInhEq(attr.decl().name())) {
          attr.emitInhEqSignature(out);
        }
      }
    }
  }

  syn String AttrDecl.tracePrintReturnPreviousValue(String varName) = "";
  syn String AttrDecl.tracePrintReturnNewValue(String varName) = "";
  syn String AttrDecl.tracePrintBeginComputingValue() = "";
  syn String AttrDecl.tracePrintCycleBeginString() = "";
  syn String AttrDecl.tracePrintCycleEndString() = "";
  syn String AttrDecl.tracePrintStartingCycle() = "";
  syn String AttrDecl.traceComputeContext() = "";

  syn String AttrDecl.traceSignature() {
    StringBuilder b = new StringBuilder();
    b.append(getAspectName());
    b.append(": ");
    if(this instanceof SynDecl)
      b.append("syn ");
    if(this instanceof InhDecl)
      b.append("inh ");
    if (this instanceof CollDecl)
      b.append("coll ");
    if(getLazy())
      b.append("lazy ");
    if(isCircular())
      b.append(" circular");

    b.append(getType());
    b.append(" ");
    b.append(hostClass().name());
    b.append(".");
    b.append(name());
    b.append("(");
    for(int i = 0; i < getNumParameter(); i++) {
      if(i != 0)
        b.append(", ");
      b.append(getParameter(i).getType());
      b.append(" ");
      b.append(getParameter(i).getName());
    }
    b.append(")");
    b.append(", ");
    b.append("this = \" + this.getClass().getName() + \"@\"+ Integer.toHexString(this.hashCode()) + \"");
    for(int i = 0; i < getNumParameter(); i++) {
      String name = getParameter(i).getName();
      String type = getParameter(i).getType();
      b.append(", ");
      b.append(name);
      b.append(" = ");
      if(isPrimitive(type) || type.equals("String") || type.equals("java.lang.String"))
        b.append("\" + " + name + " + \"");
      else
        b.append("\" + " + name + ".getClass().getName() + \"@\" + Integer.toHexString(" + name + ".hashCode()) + \"");
    }
    return b.toString();
  }

  protected String AttrDecl.trace(String s) {
    if(!grammar().tracing)
      return "";
    StringBuilder b = new StringBuilder();
    b.append("System.out.println(\"");
    b.append(s);
    b.append("\");\n");
    return b.toString();
  }

  syn String AttrDecl.traceBeginAttr() =
    trace("begin " + traceSignature());
  syn String AttrDecl.traceEndAttr() =
    trace("end " + traceSignature());
  syn String AttrDecl.traceEndCachedAttr() =
    trace("end cached " + traceSignature());

}
