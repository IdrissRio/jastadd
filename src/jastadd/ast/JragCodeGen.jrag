/* Copyright (c) 2005-2013, The JastAdd Team
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Lund University nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
import java.util.*;
import java.io.*;

import org.jastadd.ast.AST.*;
import org.jastadd.jrag.*;

import org.jastadd.jrag.AST.ASTCompilationUnit;
import org.jastadd.jrag.AST.ASTBlock;

import org.jastadd.JastAdd;

aspect AttributeKind {
  syn String AttrDecl.attributeKind();
  eq SynDecl.attributeKind() = isNTA() ? "syn nta" : "syn";
  eq InhDecl.attributeKind() = "inh";
  eq CollDecl.attributeKind() = "coll";
}

aspect JragCodeGen {

  /**
   * Generate the declaredat documentation tag. If no file name is available
   * then no tag is generated.
   *
   * @param fileName the name of the source file containing the declaration
   * @param line the line number in the source file where the declaration occurs
   * @return the declaredat tag
   */
  public static String ASTNode.declaredat(String fileName, int line) {
    fileName = fileName.trim();
    if (fileName.length() == 0) {
      return "";
    } else {
      // replace backslashes in the file path with slashes in order to avoid
      // unintentional (and possibly illegal) unicode escape sequences
      return "@declaredat " + escapedFileName(fileName) + ":" + line;
    }
  }

  syn String AttrDecl.declaredat() =
    ASTNode.declaredat(getFileName(), getStartLine());

  syn String AttrEq.declaredat() =
    ASTNode.declaredat(getFileName(), getStartLine());

  syn String Rewrite.declaredat() =
    ASTNode.declaredat(getFileName(), getStartLine());

  syn String RewriteList.declaredat() =
    ASTNode.declaredat(getFileName(), getStartLine());

  syn boolean AttrDecl.isLazy() {
    return config().cacheAll() ||
      declaredNTA() ||
      (!config().cacheNone() && getLazy());
  }

  eq SynDecl.isLazy() {
    return config().cacheAll() ||
      declaredNTA() ||
      (!config().cacheNone() && getLazy());
  }

  eq InhDecl.isLazy() {
    return config().cacheAll() ||
      declaredNTA() ||
      (!config().cacheNone() && getLazy());
  }

  eq CollDecl.isLazy() {
    return config().cacheAll() ||
      !config().cacheNone() &&
      (declaredNTA() || getLazy());
  }

  public String Grammar.genImportsList() {
    Set imports = new LinkedHashSet();
    for (Iterator iter = getCompUnits(); iter.hasNext(); ) {
        org.jastadd.jrag.AST.ASTCompilationUnit u =
          (org.jastadd.jrag.AST.ASTCompilationUnit) iter.next();
        imports.addAll(Unparser.getImports(u));
    }
    StringBuilder buf = new StringBuilder();
    for (Iterator iter = imports.iterator(); iter.hasNext(); ) {
      buf.append(iter.next());
      buf.append('\n');
    }
    return buf.toString();
  }

  public void InterfaceDecl.emitMembers(PrintStream out) {
    for (Iterator iter = getClassBodyDeclsItr(); iter.hasNext(); ) {
      ClassBodyObject obj = (ClassBodyObject)iter.next();
      org.jastadd.jrag.AST.SimpleNode n = obj.node;
      //out.println(ind + "// Declared in " + obj.fileName + " at line " + obj.line);
      if (n instanceof org.jastadd.jrag.AST.ASTAspectMethodDeclaration) {
        try {
          StringBuffer buf = new StringBuffer();
          org.jastadd.jrag.AST.ASTAspectMethodDeclaration decl = (org.jastadd.jrag.AST.ASTAspectMethodDeclaration)n;
          ClassBodyDeclUnparser.unparseAbstract(decl, buf);
          out.print(buf);
        } catch (Exception e) {
          System.err.println("Error generating " + obj.signature() + " in " + name());
          e.printStackTrace();
        }
      }
      else if (n instanceof org.jastadd.jrag.AST.ASTAspectRefineMethodDeclaration) {
        try {
          StringBuffer buf = new StringBuffer();
          org.jastadd.jrag.AST.ASTAspectRefineMethodDeclaration decl = (org.jastadd.jrag.AST.ASTAspectRefineMethodDeclaration)n;
          ClassBodyDeclUnparser.unparseAbstract(decl, buf);
          out.print(buf);
        } catch (Exception e) {
          System.err.println("Error generating " + obj.signature() + " in " + name());
          e.printStackTrace();
        }
      }
      else if (n instanceof org.jastadd.jrag.AST.ASTBlock) {
        // do not emit refined implementations
      }
      else {
        if (!obj.comments.equals("")) {
          out.print(obj.comments + " ");
        }
        out.print(obj.modifiers());
        StringBuffer buf = new StringBuffer();
        n.jjtAccept(new ClassBodyDeclUnparser(), buf);
        out.print(buf.toString());
      }
      out.println();
    }
  }

  public void TypeDecl.emitMembers(PrintStream out) { }

  public void ASTDecl.emitMembers(PrintStream out) {
    for (Iterator iter = getClassBodyDeclsItr(); iter.hasNext(); ) {
      ClassBodyObject obj = (ClassBodyObject)iter.next();
      org.jastadd.jrag.AST.SimpleNode node = obj.node;
      out.print(obj.modifiers());
      out.println(docComment(obj));
      out.print(config().indent);
      StringBuffer buf = new StringBuffer();
      node.jjtAccept(new ClassBodyDeclUnparser(), buf);
      out.print(buf.toString());
      out.println();
    }
  }

  public void TypeDecl.emitAbstractSyns(PrintStream out) {
    for (int i = 0; i < getNumSynDecl(); i++) {
      AttrDecl attr = getSynDecl(i);
      out.println(attr.docComment());
      attr.emitSynDecl(out);
    }
  }

  public void AttrDecl.emitSynDecl(PrintStream out) {
    templateContext().expand("AttrDecl.synDecl", out);
  }

  public void AttrDecl.emitAbstractSynDecl(PrintStream out) {
    templateContext().expand("AttrDecl.abstractSynDecl", out);
  }

  /**
   * Generate abstract method declarations for synthesized attributes
   * that lack an equation.
   */
  public void ASTDecl.emitAbstractSyns(PrintStream out) {
    for (int i = 0; i < getNumSynDecl(); i++) {
      AttrDecl attr = getSynDecl(i);
      boolean equ = false;
      for (int j = 0; j < getNumSynEq(); j++) {
        if (getSynEq(j).signature().equals(attr.signature())) {
          equ = true;
        }
      }
      if (!equ) {
        attr.emitAbstractSynDecl(out);
      }
    }
  }

  syn String AttrEq.attributeKind() = decl().attributeKind();

  public String AttrDecl.initLazyMaps() {
    StringBuilder sb = new StringBuilder();
    if (config().lazyMaps()) {
      if (!isCircular()) {
        if (getNumParameter() != 0 && config().visitCheckEnabled() && config().rewriteEnabled()) {
          sb.append("if (" + signature() + "_visited == null) " + signature() + "_visited = " + config().createDefaultMap() + ";\n");
        }
        else if (getNumParameter() != 0 && config().visitCheckEnabled()) {
          sb.append("if (" + signature() + "_visited == null) " + signature() + "_visited = " + config().createDefaultSet() + ";\n");
        }
      }
      if (getNumParameter() != 0 && (isLazy() || isCircular())) {
        sb.append("if (" + signature() + "_values == null) " + signature() + "_values = " + config().createDefaultMap() + ";\n");
      }
    }
    return sb.toString();
  }

  public void AttrDecl.emitVisitedDeclarations(PrintStream out) {
    if ( !config().visitCheckEnabled() && !isCircular()) {
      return;
    }

    String type;
    String init;
    if (isCircular()) {
      if (getNumParameter() == 0) {
        type = "int";
        init = " = -1";
      } else {
        // the visited flag is part of the State$Value object
        return;
      }
    } else if (config().rewriteEnabled()) {
      if (getNumParameter() == 0) {
        type = "int";
        init = " = -1";
      } else {
        type = config().typeDefaultMap();
        if (config().lazyMaps()) {
          init = "";
        } else {
          init = " = " + config().createDefaultMap();
        }
      }
    } else if (getNumParameter() == 0) {
      type = "boolean";
      init = " = false";
    } else {
      type = config().typeDefaultSet();
      if (config().lazyMaps()) {
          init = "";
      } else {
          init = " = " + config().createDefaultSet();
      }
    }

    TemplateContext tt = templateContext();
    tt.bind("Type", type);
    tt.bind("Init", init);
    tt.expand("AttrDecl.emitVisitedDeclarations", out);
  }

  public String AttrDecl.visitedException() {
    TemplateContext tt = templateContext();
    tt.bind("ClassName", getClass().getName());
    return tt.expand("AttrDecl.visitedException");
  }


  public String AttrDecl.visitedCheck() {
    return templateContext().expand("AttrDecl.visitedCheck");
  }

  public String AttrDecl.setVisited() {
    if (!config().visitCheckEnabled() && !isCircular()) {
      return "";
    }
    return templateContext().expand("AttrDecl.setVisited");
  }

  public String AttrDecl.clearVisited() {
    if (!config().visitCheckEnabled() && !isCircular()) {
      return "";
    } else if (config().rewriteEnabled()) {
      if (getNumParameter() == 0)
        return signature() + "_visited = -1;\n";
      else
        return signature() + "_visited.remove(_parameters);\n";
    } else if (getNumParameter() == 0) {
      return signature() + "_visited = false;\n";
    } else {
      return signature() + "_visited.remove(_parameters);\n";
    }
  }

  public void AttrDecl.emitCacheDeclarations(PrintStream out) {
    if (isLazy()) {
      templateContext().expand("AttrDecl.cacheDeclarations", out);
    }
  }

  /**
   * @return {@code true} if the attribute is declared as NTA in the aspect file
   */
  syn boolean AttrDecl.declaredNTA() = false;
  eq SynDecl.declaredNTA() = getNTA();
  eq InhDecl.declaredNTA() = getNTA();

  public String Parameter.toReferenceType() {
    return toReferenceType(getName(), getType());
  }

  public String ASTNode.toReferenceType(String value, String type) {
    if (type.equals("int")) {
      return "Integer.valueOf(" + value + ")";
    } else if (type.equals("short")) {
      return "Short.valueOf(" + value + ")";
    } else if (type.equals("long")) {
      return "Long.valueOf(" + value + ")";
    } else if (type.equals("float")) {
      return "Float.valueOf(" + value + ")";
    } else if (type.equals("double")) {
      return "Double.valueOf(" + value + ")";
    } else if (type.equals("boolean")) {
      return "Boolean.valueOf(" + value + ")";
    } else if (type.equals("char")) {
      return "Character.valueOf(" + value + ")";
    } else {
      return value;
    }
  }

  public String ASTNode.fromReferenceType(String value, String type) {
    if (type.equals("int"))
      return "((Integer)" + value + ").intValue()";
    else if (type.equals("short"))
      return "((Short)" + value + ").shortValue()";
    else if (type.equals("long"))
      return "((Long)" + value + ").longValue()";
    else if (type.equals("float"))
      return "((Float)" + value + ").floatValue()";
    else if (type.equals("double"))
      return "((Double)" + value + ").doubleValue()";
    else if (type.equals("boolean"))
      return "((Boolean)" + value + ").booleanValue()";
    else if (type.equals("char"))
      return "((Character)" + value + ").charValue()";
    else
      return "(" + type + ")" + value;
  }

  public boolean AttrDecl.isPrimitive() {
    String type = getType();
    return type.equals("int") || type.equals("short") || type.equals("long") ||
      type.equals("float") || type.equals("double") || type.equals("boolean") ||
      type.equals("char") || type.equals("byte");
  }

  public boolean AttrDecl.isPrimitive(String type) {
    return type.equals("int") || type.equals("short") || type.equals("long") ||
      type.equals("float") || type.equals("double") || type.equals("boolean") ||
      type.equals("char") || type.equals("byte");
  }

  public boolean TokenComponent.isPrimitive() {
    String type = getTokenId().getTYPE();
    return type.equals("int") || type.equals("short") || type.equals("long") ||
      type.equals("float") || type.equals("double") || type.equals("boolean") ||
      type.equals("char") || type.equals("byte");
  }

  public String AttrDecl.parameterStructure() {
    if (getNumParameter() == 0 || (!isLazy() && !isCircular() && !config().visitCheckEnabled())) {
      return "";
    } else if (getNumParameter() == 1) {
      return "Object _parameters = " + getParameter(0).toReferenceType() + ";\n";
    } else {
      StringBuilder sb = new StringBuilder();
      sb.append("java.util.List _parameters = new java.util.ArrayList(" + getNumParameter() + ");\n");
      for (int i = 0; i < getNumParameter(); i++) {
        sb.append("_parameters.add(" + getParameter(i).toReferenceType() + ");\n");
      }
      return sb.toString();
    }
  }

  public String AttrDecl.cacheInit() {
    if (isLazy()) {
      return cacheInitCircular() + cacheInitRewrite();
    } else {
      return "";
    }
  }

  public String AttrDecl.cacheInitCircular() {
    return "boolean intermediate = state.INTERMEDIATE_VALUE;\n" +
           "state.INTERMEDIATE_VALUE = false;\n";
  }

  public String AttrDecl.cacheInitRewrite() {
    if (!config().rewriteEnabled()) {
      return "";
    } else {
      return "int num = state.boundariesCrossed;\n" +
             "boolean isFinal = this.is$Final();";
    }
  }

  public String AttrDecl.cacheStoreCondition() {
    /* BEGIN INCORRECT legacy cache store condition */
    /* TODO remove this */
    if (!config().rewriteEnabled() || getFinal()) {
      return "true";
    } else {
      return "isFinal && num == state().boundariesCrossed";
    }
    /* END INCORRECT legacy cache store condition */

    /* BEGIN CORRECT cache store condition.
     * TODO use this instead of above condition in 2.2.0!!
    StringBuilder cacheCond = new StringBuilder();
    cacheCond.append(cacheStoreRewrite());
    String circularCond = (!isCircular() ? cacheStoreCircular() : "");
    if (cacheCond.length() != 0 && !circularCond.isEmpty()) {
      cacheCond.append(" && ");
    }
    cacheCond.append(circularCond);
    if (cacheCond.length() == 0) {
      cacheCond.append("true");
    }
    return cacheCond;
    END CORRECT cache store condition
    */
  }

  public String AttrDecl.cacheStoreCircular() {
    if (config().cacheCycle()) {
      return "(!state.IN_CIRCLE || (state.IN_CIRCLE && (!state.INTERMEDIATE_VALUE || state.LAST_CYCLE)))";
    }
    return "!state.INTERMEDIATE_VALUE";
  }

  public String AttrDecl.cacheStoreRewrite() {
    if (config().rewriteEnabled() && !config().rewriteCircularNTA()) {
      // TODO: Should final on attributes be allowed?
      if (getFinal()) {
        return "(num == state().boundariesCrossed)";
      }
      return "(isFinal && num == state().boundariesCrossed)";
    } else {
      return "";
    }
  }

  public String AttrDecl.cacheRestore() {
    return "state.INTERMEDIATE_VALUE |= intermediate;\n";
  }

  syn String AttrDecl.attributeValueReference() =
        toReferenceType(signature() + "_value", getType());

  syn boolean AttrEq.hasComputeBlock() = true;
  eq SynEq.hasComputeBlock() = getRHS() instanceof ASTBlock;

  /**
   * @return Compute method without "_compute" suffix
   */
  public void AttrDecl.emitInlineComputeWithTry(PrintStream out, AttrEq equ) {
    TemplateContext tt = templateContext();
    tt.bind("ParamDecl", equ.parametersDecl());
    tt.bind("ComputeBody", equ.computeCode());
    tt.bind("FromRefTypeParam", fromReferenceType(signature() + "_values.get(_parameters)", getType()));
    tt.expand("AttrDecl.emitInlineComputeWithTry", out);
  }

  syn String AttrEq.computeCode() = "";

  eq SynEq.computeCode() = Unparser.unparse(getRHS());

  /**
   * Generate code for the method to compute this attribute
   */
  public void AttrEq.emitComputeMethod(PrintStream out) {
  }

  public void SynEq.emitComputeMethod(PrintStream out) {
    templateContext().expand("SynEq.emitComputeMethod", out);
  }

  syn String AttrDecl.inhDebugString() {
    if (!config().debugMode()) {
      return "";
    } else {
      return config().ind(2) + "if (getParent() == null) throw new RuntimeException(\"Trying to evaluate attribute in subtree not attached to main tree\");\n";
    }
  }

  public boolean TypeDecl.hasLazySynEqFor(AttrDecl attr) {
    if (attr instanceof SynDecl) {
      SynEq synEq = lookupSynEq(attr.signature());
      return synEq != null && (synEq.decl().isLazy() || synEq.decl().isCircular()) ;
    }
    return false;
  }

  syn String AttrDecl.cycleLimitCheck() = "";
   // TODO: fixme cycleLimit > 0 ?
   //    "if (state().CIRCLE_INDEX > " + cycleLimit + ") throw new java.lang.RuntimeException(\"Iteration limit " + cycleLimit + " exceeded\");\n" : "";

  public void AttrDecl.emitEquation(PrintStream out, String paramDecl) {
    TemplateContext tt = templateContext();
    tt.bind("ParamDecl", paramDecl);
    tt.bind("FromRefTypeParam", fromReferenceType(signature() + "_values.get(_parameters)", getType()));
    tt.expand("AttrDecl.emitEquation", out);
  }

  public void AttrDecl.emitCircularEquationNoParams(PrintStream out) {
    TemplateContext tt = templateContext();
    tt.bind("Cond1", differs("new_" + signature() + "_value", signature() + "_value"));
    tt.bind("Cond2", differs("new_" + signature() + "_value", signature() + "_value"));
    tt.bind("BottomValue", Unparser.unparse(getBottomValue()));
    tt.bind("TracePrintReturnNewValue", tracePrintReturnNewValue(signature() + "_value"));
    tt.bind("TracePrintReturnPreviousValue", tracePrintReturnPreviousValue(signature() + "_value"));
    tt.expand("ASTDecl.genCircularEquationNoParams", out);
  }

  public void AttrDecl.emitCircularEquationWithParams(PrintStream out, String paramDecl) {
    TemplateContext tt = templateContext();
    tt.bind("BottomValue", toReferenceType(Unparser.unparse(getBottomValue()), getType()));
    tt.bind("Cond1", differs("new_" + signature() + "_value", fromReferenceType("_value.value", getType())));
    tt.bind("ToRefType", toReferenceType("new_" + signature() + "_value", getType()));
    tt.bind("FromRefType", fromReferenceType("_value.value", getType()));
    tt.bind("FromRefTypeParamCircular", fromReferenceType("_o", getType()));
    tt.bind("FromRefTypeParam", fromReferenceType(signature() + "_values.get(_parameters)", getType()));
    tt.bind("ParamDecl", paramDecl);
    tt.bind("TracePrintReturnNewValue", tracePrintReturnNewValue("new_" + signature() + "_value"));
    tt.bind("TracePrintReturnPreviousValue", tracePrintReturnPreviousValue(fromReferenceType(signature() + "_values.get(_parameters)" , getType())));
    tt.expand("ASTDecl.genCircularEquationWithParams", out);
  }

  /**
   * @return {@code true} if this attribute equation can be inlined in the
   * attribute method
   */
  syn boolean AttrEq.canInlineCompute(AttrDecl decl) = false;
  eq SynEq.canInlineCompute(AttrDecl decl) = !hasComputeBlock();

  /**
   * @return {@code true} if this attribute equation can be inlined in the
   * attribute method with a try statement
   */
  syn boolean AttrEq.canInlineComputeWithTry(AttrDecl decl) = false;
  eq SynEq.canInlineComputeWithTry(AttrDecl decl) =
    hasComputeBlock() && !decl.isLazy() && !decl.isNTA() && !decl.isCircular();

  /**
   * Generates the method to compute an attribute with a specific equation
   * @param out
   * @param equ the equation to generate code for
   */
  public void AttrDecl.emitAttrEquation(PrintStream out, AttrEq equ) {
    if (equ.canInlineCompute(this)) {
      if (isCircular()) {
        templateContext().bind("CircularComputeRHS", equ.computeCode());
      } else {
        templateContext().bind("ComputeStmt",
            computeLHS() + " = " + equ.computeCode() + ";");
      }
      emitAttrEquation(out, equ.parametersDecl());
    } else if (equ.canInlineComputeWithTry(this)) {
      emitInlineComputeWithTry(out, equ);
    } else {
      if (isCircular()) {
        templateContext().bind("CircularComputeRHS", circularComputeRHS());
      } else {
        templateContext().bind("ComputeStmt",
            computeLHS() + " = " + computeRHS() + ";");
      }
      emitAttrEquation(out, equ.parametersDecl());
      equ.emitComputeMethod(out);
    }
  }

  /**
   * Generates the method to compute an attribute
   * @param out
   * @param paramDecl
   */
  public void AttrDecl.emitAttrEquation(PrintStream out) {
    if (isCircular()) {
      templateContext().bind("CircularComputeRHS", circularComputeRHS());
    } else {
      templateContext().bind("ComputeStmt",
          computeLHS() + " = " + computeRHS() + ";");
    }
    emitAttrEquation(out, parametersDecl());
  }

  /**
   * Generates the method to compute an attribute
   * @param out
   * @param paramDecl
   */
  public void AttrDecl.emitAttrEquation(PrintStream out, String paramDecl) {
    if (isCircular()) {
      TemplateContext tt = templateContext();
      String rhs = "" + tt.evalVariable("CircularComputeRHS");
      tt.bind("CircularComputeStmt", circularComputeLHS() + " = " + rhs + ";");
      if (getNumParameter() == 0) {
        emitCircularEquationNoParams(out);
      } else {
        emitCircularEquationWithParams(out, paramDecl);
      }
    } else {
      emitEquation(out, paramDecl);
    }
  }

  syn boolean AttrDecl.isParameterized() =
    getNumParameter() != 0;

  public String AttrDecl.cacheCycleCheck() {
    templateContext().bind("CachedValue",
        toReferenceType("new_" + signature() + "_value", getType()));
    return templateContext().expand("AttrDecl.cacheCycleCheck");
  }

  public String AttrDecl.addComponentCheck() {
    if (!config().componentCheck() || !config().visitCheckEnabled()) return "";
    String arg = getNumParameter() == 0 ? "null" : "_parameters";
    String ind = config().indent;
    if (getNumParameter() == 0) {
      if (config().rewriteEnabled())
        return
          "if (" + signature() + "_visited == state.boundariesCrossed && !state.containsEvalEntry(this, \"" + signature() + "\", null))\n" +
          ind + "throw new java.lang.RuntimeException(\"XXX\");\n";
      else
        return
          "if (" + signature() + "_visited != -1 && !state.containsEvalEntry(this, \"" + signature() + "\", null))\n" +
          ind + "throw new java.lang.RuntimeException(\"XXX\");\n";
    }
    else {
      if (config().rewriteEnabled()) {
        return
          "if (new Integer(state.boundariesCrossed).equals(_value.visited) && !state.containsEvalEntry(this, \"" + signature() + "\", _parameters))\n" +
          ind + "throw new java.lang.RuntimeException(\"XXX\");\n";
      } else
        return
          "if (_value.visited != -1 && !state.containsEvalEntry(this, \"" + signature() + "\", _parameters))\n" +
          ind + "throw new java.lang.RuntimeException(\"XXX\");\n";
    }
  }

  public String AttrDecl.addAddToComponent() {
    if (!config().componentCheck() || !config().visitCheckEnabled()) return "";
    if (getNumParameter() == 0) {
      return
        "state.addEvalEntry(this, \"" + signature() + "\", null);\n";
    } else {
      return
        "state.addEvalEntry(this, \"" + signature() + "\", _parameters);\n";
    }
  }

  public String AttrDecl.differs(String s1, String s2) {
    if (isPrimitive()) {
      return s1 + " != " + s2;
    } else if (declaredNTA() && isCircular()) {
      if (isRewriteCircularNtaAttr()) {
        return "rewriteState != ASTNode$State.REWRITE_NOCHANGE";
      }
      return "!is$Equal(" + s1 + "," + s2 + ")";
    } else {
      return "(" + s1 + "==null && " + s2 + "!=null) || (" + s1 + "!=null && !" + s1 + ".equals(" + s2 + "))";
    }
  }

  public void ASTDecl.emitCacheDeclarations(PrintStream out, AttrDecl attr) {
    boolean needsCacheDeclaration = true;
    if (attr instanceof SynDecl) {
      // EMMA_2011-09-13: Setting this to true to get declarations for each
      // equation of an attribute. If an equation lacks its own visited declaration
      // and calls an overriden equation it can cause a circularity exception.
      needsCacheDeclaration = true; // superClass() == null || !superClass().hasLazySynEqFor(attr);
    }
    String ind = config().indent;
    if (!attr.isCircular()) {
      if (needsCacheDeclaration) {
        attr.emitVisitedDeclarations(out);
        attr.emitCacheDeclarations(out);
        attr.emitResetMethod(out);
      }
    } else {
      if (attr.getNumParameter() == 0) {
        if (!needsCacheDeclaration && attr instanceof SynDecl &&
            superClass() != null && superClass().lookupSynEq(attr.signature()) != null
            && !superClass().lookupSynEq(attr.signature()).decl().isCircular()) {

          needsCacheDeclaration = true;
        }
        if (needsCacheDeclaration) {
          attr.emitVisitedDeclarations(out);
          attr.emitResetMethod(out);
          out.println(ind + "/**");
          out.println(ind + " * @apilevel internal");
          out.println(ind + " */");
          out.println(ind + "protected boolean " + attr.signature() + "_computed = false;");
          out.println(ind + "/**");
          out.println(ind + " * @apilevel internal");
          out.println(ind + " */");
          out.println(ind + "protected boolean " + attr.signature() + "_initialized = false;");
          out.println(ind + "/**");
          out.println(ind + " * @apilevel internal");
          out.println(ind + " */");
          out.println(ind + "protected " + attr.getType() + " " + attr.signature() + "_value;");
          return;
        }
      }
      else {
        if (needsCacheDeclaration) {
          attr.emitVisitedDeclarations(out);
          attr.emitResetMethod(out);
          if (attr.declaredNTA()) {
            attr.emitCacheDeclarations(out);
          } else {
            if (config().lazyMaps()) {
              out.println(ind + "protected " + config().typeDefaultMap() + " " + attr.signature() + "_values;");
              return;
            } else {
              out.println(ind + "protected " + config().typeDefaultMap() + " " + attr.signature() + "_values = " + config().createDefaultMap() + ";");
              return;
            }
          }
        }
      }
    }
  }

  syn String AttrEq.getType() = decl().getType();

  public void ASTDecl.emitSynEquations(PrintStream out) {
    for (int i = 0; i < getNumSynEq(); i++) {
       AttrEq equ = getSynEq(i);
       AttrDecl attr = equ.decl();
       emitCacheDeclarations(out, attr);
       attr.emitAttrEquation(out, equ);
    }
  }

  /**
   * @return {@code true} if this attribute matches an NTA component declared
   * in the grammar
   */
  public boolean AttrDecl.isNTA() {
    return false;
  }

  public boolean SynDecl.isNTA() {
    return findCorrespondingNTA() != null;
  }

  /**
   * @return the index of the NTA in the child array
   */
  public int AttrDecl.indexNTAchild() {
    Components comp = findCorrespondingNTA();
    TypeDecl c = hostClass();
    while (c != null) {
      int index = 0;
      for (Iterator iter = c.getComponents(); iter.hasNext(); ) {
        Components next = (Components)iter.next();
        if (next == comp)
          return index;
        if (!(next instanceof TokenComponent))
          index++;
      }
      c = c instanceof ASTDecl ? ((ASTDecl)c).superClass() : null;
    }
    return -1;
  }

  public Components AttrDecl.findCorrespondingNTA() {
    if (!getName().startsWith("get"))
      return null;
    String attrName = getName().substring(3);
    TypeDecl c = hostClass();
    while (c != null) {
      for (Iterator iter = c.getComponents(); iter.hasNext(); ) {
        Components comp = (Components)iter.next();
        if (comp.name().equals(attrName) && (
            comp instanceof OptionalComponentNTA
            || comp instanceof TokenComponentNTA
            || comp instanceof AggregateComponentsNTA )) {
          return comp;
        }
        if (attrName.equals(comp.name() + "Opt") && comp instanceof OptionalComponentNTA) {
          return comp;
        }
        if (attrName.equals(comp.name() + "List") && comp instanceof ListComponentsNTA) {
          return comp;
        }
      }
      c = c instanceof ASTDecl ? ((ASTDecl)c).superClass() : null;
    }
    return null;
  }

  public String AttrDecl.higherOrderAttributeCode() {
    return "";
  }

  public String SynDecl.higherOrderAttributeCode() {
    Components comp = findCorrespondingNTA();
    if (comp != null) {// check for component NTA
      if (declaredNTA()) {
        System.err.println("Warning: the NTA equation " + name() + " was affected by a bug causing the equation value to be discarded! (fixed since version 2.1.11)");
      }
      String attrName = getName().substring(3); // remove get
      if (comp.name().equals(attrName) && comp instanceof AggregateComponentsNTA
          || attrName.equals(comp.name() + "Opt") && comp instanceof OptionalComponentNTA
          || attrName.equals(comp.name() + "List") && comp instanceof ListComponentsNTA) {
        return "setChild(" + signature() + "_value, get" + attrName + "ChildPosition());\n";
      }
      // token components are not stored in child vector
      return "";
    } else if (declaredNTA()) {// check if attribute equation declared NTA
      if (config().rewriteEnabled()) {
        if (config().stagedRewrites()) {
          return templateContext().expand("SynDecl.higherOrderAttributeCode:stagedrewrites");
        } else {
          return templateContext().expand("SynDecl.higherOrderAttributeCode:nostagedrewrites");
        }
      } else {
        return templateContext().expand("SynDecl.higherOrderAttributeCode:norewrite");
      }
    }
    return "";
  }

  public void TypeDecl.emitInhDeclarations(PrintStream out) {
    for (int i = 0; i < getNumInhDecl(); i++) {
       AttrDecl attr = getInhDecl(i);
       out.println(attr.docComment());
       attr.emitInhDecl(out);
    }
  }

  public void AttrDecl.emitInhDecl(PrintStream out) {
    templateContext().expand("AttrDecl.inhDecl", out);
  }

  public void ASTDecl.emitInhDeclarations(PrintStream out) {
    for (int i = 0; i < getNumInhDecl(); i++) {
       AttrDecl attr = getInhDecl(i);
       out.println(attr.docComment());
       attr.emitAttrEquation(out);
       emitCacheDeclarations(out, attr);
    }
  }

  syn boolean TypeDecl.hasInhEq(String attrName) {
    for (int i = 0; i < getNumInhEq(); i++) {
      InhEq equ = getInhEq(i);
      if (equ.getName().equals(attrName)) {
        return true;
      }
    }
    return false;
  }
  eq ASTDecl.hasInhEq(String attrName) =
    super.hasInhEq(attrName) || superClass() != null && superClass().hasInhEq(attrName);

  syn Components InhEq.getComponents() {
    TypeDecl c = hostClass();
    if (c != null)
      return c.components(childName());
    return  null;
  }
  syn String InhEq.childName() = getChildName().startsWith("get") ? getChildName().substring(3) : getChildName();

  /**
   * Lookup NTA child corresponding to this inherited equation.
   */
  syn AttrDecl InhEq.getChildAttrDecl() {
    AttrDecl decl = hostClass().lookupSynDeclPrefix(childName());
    if (decl == null) decl = hostClass().lookupInhDeclPrefix(childName());
    return decl;
  }

  syn SynDecl TypeDecl.lookupSynDeclPrefix(String signature) {
    for (int i = 0; i < getNumSynDecl(); i++)
      if (getSynDecl(i).signature().equals(signature) || getSynDecl(i).signature().startsWith(signature + "_"))
        return getSynDecl(i);
    return null;
  }

  eq ASTDecl.lookupSynDeclPrefix(String signature) {
    SynDecl decl = super.lookupSynDeclPrefix(signature);
    if (decl != null || superClass() == null)
      return decl;
    return superClass().lookupSynDeclPrefix(signature);
  }

  syn InhDecl TypeDecl.lookupInhDeclPrefix(String signature) {
    for (int i = 0; i < getNumInhDecl(); i++)
      if (getInhDecl(i).signature().equals(signature) || getInhDecl(i).signature().startsWith(signature + "_"))
        return getInhDecl(i);
    return null;
  }

  syn InhDecl ASTDecl.lookupInhDeclPrefix(String signature) {
    InhDecl decl = super.lookupInhDeclPrefix(signature);
    if (decl != null || superClass() == null)
      return decl;
    return superClass().lookupInhDeclPrefix(signature);
  }

  public Iterator Grammar.inhAttrSet() {
    return inhEqMap().keySet().iterator();
  }

  syn lazy HashMap Grammar.inhEqMap() {
    HashMap map = new LinkedHashMap();
    for (int i = 0; i < getNumTypeDecl(); i++) {
      if (getTypeDecl(i) instanceof ASTDecl) {
        map.putAll(((ASTDecl)getTypeDecl(i)).inhEqMap());
      }
    }
    return map;
  }

  syn lazy String Rewrite.aspectName() =
    getAspectName();

  public String Grammar.genResetDuringCounters() {
    StringBuffer sb = new StringBuffer();
    TemplateContext tt = templateContext();
    for (Iterator iter = rewriteAspects().iterator(); iter.hasNext(); ) {
      String name = (String)iter.next();
      tt.bind("Name", name);
      tt.expand("Grammar.genResetDuringCounters", sb);
    }
    return sb.toString();
  }

  syn String AttrEq.inhDebugString() = decl().inhDebugString();

  public void AttrEq.emitInhEqSignature(PrintStream out) {
    templateContext().expand("AttrEq.emitInhEqSignature", out);
  }

  //  TODO: INH
  public void ASTDecl.emitInhEqSignatures(PrintStream out) {
    if (name().equals(config().astNodeType())) {
      for (Iterator iter = grammar().inhEqMap().entrySet().iterator(); iter.hasNext(); ) {
        java.util.Map.Entry entry = (java.util.Map.Entry)iter.next();
        String attrId = (String)entry.getKey();
        AttrEq attr = (AttrEq)((LinkedList)entry.getValue()).get(0);
        if (!hasInhEq(attr.decl().name())) {
          attr.emitInhEqSignature(out);
        }
      }
    }
  }

  syn boolean AttrDecl.hasCache() = isLazy() || isCircular();

  /**
   * @return {@code true} if the attribute declaration corresponds to a
   * non-token NTA component
   */
  syn boolean AttrDecl.isAttrNTA() = isNTA() && !(findCorrespondingNTA() instanceof TokenComponent);

}

aspect Compute {
  syn String AttrDecl.computeRHS() = name() + "_compute(" + parameters() + ")";

  eq InhDecl.computeRHS() =
    "getParent().Define_" + name() + "(" + interfaceParametersStart() + ")";

  syn String AttrDecl.computeLHS() {
    if (isLazy() && getNumParameter() == 0) {
      return signature() + "_value";
    } else {
      return getType() + " " + signature() + "_value";
    }
  }

  eq InhDecl.computeLHS() {
    if (isLazy() && getNumParameter() == 0) {
      return inhDebugString() + signature() + "_value";
    } else {
      return inhDebugString() + getType() + " " + signature() + "_value";
    }
  }

  syn String AttrDecl.circularComputeRHS() = computeRHS();

  eq CollDecl.circularComputeRHS() {
    if (separateEvaluation()) {
      return Unparser.unparse(getBottomValue()) + ";\n" +
             "root." + name() + "_" + signature() + "_nextIteration(this)";
    } else {
      return "combine_" + signature() + "_contributions(" + Unparser.unparse(getBottomValue()) + ")";
    }
  }

  syn String AttrDecl.circularComputeLHS() = "new_" + signature() + "_value";

  eq CollDecl.circularComputeLHS() {
    if (separateEvaluation()) {
      return "new_" + signature() + "_value";
    } else {
      return signature() + "_value";
    }
  }

}
