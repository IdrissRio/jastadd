/* Copyright (c) 2005-2013, The JastAdd Team
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Lund University nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
import java.util.*;
import java.io.*;

import ast.AST.*;
import jrag.*;

import jrag.AST.ASTCompilationUnit;
import jrag.AST.ASTBlock;

import jastadd.JastAdd;

aspect AttributeKind {
  syn String AttrDecl.attributeKind();
  eq SynDecl.attributeKind() = isNTA() ? "syn nta" : "syn";
  eq InhDecl.attributeKind() = "inh";
  eq CollDecl.attributeKind() = "coll";
}

aspect JragCodeGen {

  public static String ASTNode.ind = "  ";
  public static java.util.List<String> ASTNode.indList = new ArrayList<String>(32);

  /**
   * Generate the declaredat documentation tag. If no file name is available
   * then no tag is generated.
   *
   * @param fileName the name of the source file containing the declaration
   * @param line the line number in the source file where the declaration occurs
   * @return the declaredat tag
   */
  public static String ASTNode.declaredat(String fileName, int line) {
    fileName = fileName.trim();
    if (fileName.length() == 0) {
      return "";
    } else {
      // replace backslashes in the file path with slashes in order to avoid
      // unintentional (and possibly illegal) unicode escape sequences
      return "@declaredat " + escapedFileName(fileName) + ":" + line;
    }
  }

  syn String AttrDecl.declaredat() =
    ASTNode.declaredat(getFileName(), getStartLine());

  syn String AttrEq.declaredat() =
    ASTNode.declaredat(getFileName(), getStartLine());

  syn String Rewrite.declaredat() =
    ASTNode.declaredat(getFileName(), getStartLine());

  syn String RewriteList.declaredat() =
    ASTNode.declaredat(getFileName(), getStartLine());

  /**
   * Builds an indentation string equal to a certain level of
   * indentation.
   *
   * @param level the required indentation level
   * @return the indentation string
   */
  public static final String ASTNode.ind(int level) {
    while (indList.size() <= level) {
      if (indList.size() == 0) {
        indList.add("");
      } else {
        indList.add(indList.get(indList.size()-1) + ind);
      }
    }
    return indList.get(level);
  }

  // EMMA_2009-11-16: Modifying cache conditions, using cacheNone instead of noCaching
  refine  public boolean AttrDecl.getLazy() {
    if (grammar().cacheAll)
      return true;
    else if (grammar().cacheNone)
      return declaredNTA();
    else
      return declaredNTA() || refined(); //Ast.AttrDecl.getLazy(); 
//    return (Ast.AttrDecl.getLazy() || grammar().cacheAll) && (!noCaching || declaredNTA());
  }
  refine  public boolean SynDecl.getLazy() {
    if (grammar().cacheAll)
      return true;
    else if (grammar().cacheNone)
      return declaredNTA();
    else
      return declaredNTA() || refined(); //Ast.SynDecl.getLazy();
//    return (Ast.SynDecl.getLazy() || grammar().cacheAll) && (!noCaching || declaredNTA());
  }
  refine  public boolean InhDecl.getLazy() {
    if (grammar().cacheAll)
      return true;
    else if (grammar().cacheNone)
      return declaredNTA();
    else
      return declaredNTA() || refined(); //Ast.InhDecl.getLazy(); 
//    return (Ast.InhDecl.getLazy() || grammar().cacheAll) && (!noCaching || declaredNTA());
  }
  refine  public boolean CollDecl.getLazy() {
    if (grammar().cacheAll)
      return true;
    else if (grammar().cacheNone)
      return false;
    else
      return declaredNTA() || refined(); //Ast.CollDecl.getLazy();
//    return (Ast.CollDecl.getLazy() || grammar().cacheAll) && !noCaching;
  }

  public String Grammar.genImportsList() {
    Set imports = new LinkedHashSet();
    for(Iterator iter = getCompUnits(); iter.hasNext(); ) {
        jrag.AST.ASTCompilationUnit u =
          (jrag.AST.ASTCompilationUnit) iter.next();
        imports.addAll(Unparser.getImports(u));
    }
    StringBuffer buf = new StringBuffer();
    for(Iterator iter = imports.iterator(); iter.hasNext(); ) {
      buf.append(iter.next());
      buf.append('\n');
    }
    return buf.toString();
  }

  public void InterfaceDecl.emitMembers(PrintStream out) {
    for(Iterator iter = getClassBodyDeclsItr(); iter.hasNext(); ) {
      ClassBodyObject o = (ClassBodyObject)iter.next();
      jrag.AST.SimpleNode n = o.node;
      //out.println(ind + "// Declared in " + o.fileName + " at line " + o.line);
      if(n instanceof jrag.AST.ASTAspectMethodDeclaration) {
        try {
          StringBuffer buf = new StringBuffer();
          jrag.AST.ASTAspectMethodDeclaration decl = (jrag.AST.ASTAspectMethodDeclaration)n;
          ClassBodyDeclUnparser.unparseAbstract(decl, buf);
          out.print(buf);
        } catch (Exception e) {
          System.err.println("Error generating " + o.signature() + " in " + name());
          e.printStackTrace();
        }
      }
      else if(n instanceof jrag.AST.ASTAspectRefineMethodDeclaration) {
        try {
          StringBuffer buf = new StringBuffer();
          jrag.AST.ASTAspectRefineMethodDeclaration decl = (jrag.AST.ASTAspectRefineMethodDeclaration)n;
          ClassBodyDeclUnparser.unparseAbstract(decl, buf);
          out.print(buf);
        } catch (Exception e) {
          System.err.println("Error generating " + o.signature() + " in " + name());
          e.printStackTrace();
        }
      }
      else if(n instanceof jrag.AST.ASTBlock) {
        // do not emit refined implementations
      }
      else {
        if(!o.comments.equals("")) {
          out.print(o.comments + " ");
        }
        out.print(o.modifiers);
        StringBuffer buf = new StringBuffer();
        n.jjtAccept(new ClassBodyDeclUnparser(), buf);
        out.print(buf.toString());
      }
      out.println();
    }
  }

  public void TypeDecl.emitMembers(PrintStream out) { }

  /**
   * Returns a string with the JavaDoc comment taken from the
   * original Class body object.
   */
  public String ASTDecl.javadocComment(ClassBodyObject obj) {
    String comment = obj.comments;
    String hostComment;
    if (comment == null) {
      hostComment = "";
    } else {
      comment = comment.trim();
      if (comment.length() < 5) {
        hostComment = "";
      } else {
        int end = comment.lastIndexOf("*/");
        int start = end == -1 ? -1 : comment.lastIndexOf("/**", end);

        if (start == -1) {
          hostComment = "";
        } else {
          hostComment = comment.substring(start+3, end);
        }
      }
    }
    TemplateContext tt = templateContext();
    tt.bind("HasAspect", obj.aspectName() != null && obj.aspectName().length() > 0);
    tt.bind("AspectName", obj.aspectName());
    tt.bind("HostComment", hostComment);
    tt.bind("DeclaredAt", ASTNode.declaredat(obj.getFileName(), obj.getStartLine()));
    return tt.expand("ASTDecl.javadocComment");
  }

  public void ASTDecl.emitMembers(PrintStream out) {
    for (Iterator iter = getClassBodyDeclsItr(); iter.hasNext(); ) {
      ClassBodyObject obj = (ClassBodyObject)iter.next();
      jrag.AST.SimpleNode node = obj.node;
      out.print(obj.modifiers);
      out.print(javadocComment(obj));
      out.print(ind);
      StringBuffer buf = new StringBuffer();
      node.jjtAccept(new ClassBodyDeclUnparser(), buf);
      out.print(buf.toString());
      out.println();
    }
  }

  syn String ASTDecl.annotations() = suppressWarnings();
  syn String AttrDecl.annotations() = suppressWarnings();

  public void TypeDecl.emitAbstractSyns(PrintStream out) {
    for(int i = 0; i < getNumSynDecl(); i++) {
      AttrDecl attr = getSynDecl(i);
      out.print(attr.hostFileComment());
      attr.emitSynDecl(out);
    }
  }

  public void AttrDecl.emitSynDecl(PrintStream out) {
    templateContext().expand("AttrDecl.synDecl", out);
  }

  public void ASTDecl.emitAbstractSyns(PrintStream out) {
    for(int i = 0; i < getNumSynDecl(); i++) {
      AttrDecl attr = getSynDecl(i);
      boolean equ = false;
      for(int j = 0; j < getNumSynEq(); j++) {
        if(getSynEq(j).signature().equals(attr.signature())) {
          equ = true;
        }
      }
      if(!equ) {
        out.print(attr.hostFileComment());
        out.print(suppressWarnings());
        out.println(ind + "public abstract " + attr.getType() + " " + attr.attributeName() + "(" + attr.parametersDecl() + ");");
      }
    }
  }

  public String AttrDecl.attributeSignature() {
    if(getNumParameter() == 0) {
      return getName();
    }
    StringBuffer s = new StringBuffer();
    s.append(getName());
    for(int i = 0; i < getNumParameter(); i++) {
      s.append("_" + getParameter(i).getTypeInSignature());
    }
    return s.toString();
  }

  public String AttrDecl.attributeName() {
    return getName();
  }

  public String AttrEq.attributeSignature() {
    if(getNumParameter() == 0) {
      return getName();
    }
    StringBuffer s = new StringBuffer();
    s.append(getName());
    for(int i = 0; i < getNumParameter(); i++) {
      s.append("_" + getParameter(i).getTypeInSignature());
    }
    return s.toString();
  }

  public String AttrEq.attributeName() {
    return getName();
  }

  public String AttrDecl.hostFileComment() {
    TemplateContext tt = templateContext();
    String comment = getComment().trim();
    if (comment.length() >= 5 && comment.startsWith("/**")) {
      tt.bind("SourceComment", comment.substring(3, comment.indexOf("*/")));
    } else {
      tt.bind("SourceComment", "");
    }
    return tt.expand("AttrDecl.hostFileComment");
  }

  syn String AttrEq.attributeKind() = decl().attributeKind();

  public String AttrEq.hostFileComment() {
    TemplateContext tt = templateContext();
    String comment = getComment().trim();

    if (comment.isEmpty()) {
      comment = decl().getComment().trim();
    }

    if (comment.length() >= 5 && comment.startsWith("/**")) {
      tt.bind("SourceComment", comment.substring(3, comment.indexOf("*/")));
    } else {
      tt.bind("SourceComment", "");
    }
    return tt.expand("AttrEq.hostFileComment");
  }

  public String AttrDecl.initLazyMaps() {
    StringBuffer s = new StringBuffer();
    if(grammar().lazyMaps) {
      if(!isCircular()) {
        if(getNumParameter() != 0 && grammar().visitCheckEnabled && grammar().rewriteEnabled) {
          s.append("if(" + attributeSignature() + "_visited == null) " + attributeSignature() + "_visited = " + grammar().createDefaultMap + ";\n");
        }
        else if(getNumParameter() != 0 && grammar().visitCheckEnabled) {
          s.append("if(" + attributeSignature() + "_visited == null) " + attributeSignature() + "_visited = " + grammar().createDefaultSet + ";\n");
        }
      }
      if(getNumParameter() != 0 && (getLazy() || isCircular())) {
        s.append("if(" + attributeSignature() + "_values == null) " + attributeSignature() + "_values = " + grammar().createDefaultMap + ";\n");
      }
    }
    return s.toString();
  }

  public void AttrDecl.emitVisitedDeclarations(PrintStream out) {
    if(!grammar().visitCheckEnabled && !isCircular()) {
      return;
    }

    String type;
    String init;
    if(isCircular()) {
      if(getNumParameter() == 0) {
        type = "int";
        init = " = -1";
      } else {
        // the visited flag is part of the State$Value object
        return;
      }
    } else if(grammar().rewriteEnabled) {
      if(getNumParameter() == 0) {
        type = "int";
        init = " = -1";
      } else {
        type = grammar().typeDefaultMap;
        if(grammar().lazyMaps) {
          init = "";
        } else {
          init = " = " + grammar().createDefaultMap;
        }
      }
    } else if(getNumParameter() == 0) {
      type = "boolean";
      init = " = false";
    } else {
      type = grammar().typeDefaultSet;
      if(grammar().lazyMaps) {
          init = "";
      } else {
          init = " = " + grammar().createDefaultSet;
      }
    }

    TemplateContext tt = templateContext();
    tt.bind("Type", type);
    tt.bind("Init", init);
    tt.expand("AttrDecl.emitVisitedDeclarations", out);
  }

  public String AttrDecl.visitedException() {
    TemplateContext tt = templateContext();
    tt.bind("ClassName", getClass().getName());
    return tt.expand("AttrDecl.visitedException");
  }

  syn String AttrDecl.resetVisit() = resetVisit("");

  public String AttrDecl.resetVisit(String prefix) {
    String signature = prefix + attributeSignature();
    if(isCircular()) {
      if(getNumParameter() == 0)
        return ind(2) + signature + "_visited = -1;\n";
      else {
        // visited is handled in value object
        return "";
      }
    }
    if(!grammar().visitCheckEnabled) return "";
    else if(grammar().rewriteEnabled) {
      if(getNumParameter() == 0)
        return ind(2) + signature + "_visited = -1;\n";
      else {
        if(grammar().lazyMaps)
          return ind(2) + signature + "_visited = null;\n";
        else
          return ind(2) + signature + "_visited = " + grammar().createDefaultMap + ";\n";
      }
    }
    if(getNumParameter() == 0)
      return ind(2) + signature + "_visited = false;\n";
    else {
      if(grammar().lazyMaps)
        return ind(2) + signature + "_visited = null;\n";
      else
        return ind(2) + signature + "_visited = " + grammar().createDefaultSet + ";\n";
    }
  }

  public String AttrDecl.visitedCheck() {
    TemplateContext tt = templateContext();
    tt.bind("NonParameterized", getNumParameter() == 0);
    return tt.expand("AttrDecl.visitedCheck");
  }

  public String AttrDecl.setVisited() {
    if(!grammar().visitCheckEnabled && !isCircular()) {
      return "";
    }

    TemplateContext tt = templateContext();
    tt.bind("NonParameterized", getNumParameter() == 0);
    return tt.expand("AttrDecl.setVisited");
  }

  public String AttrDecl.clearVisited() {
    if(!grammar().visitCheckEnabled && !isCircular()) {
      return "";
    } else if(grammar().rewriteEnabled) {
      if(getNumParameter() == 0)
        return attributeSignature() + "_visited = -1;\n";
      else
        return attributeSignature() + "_visited.remove(_parameters);\n";
    } else if(getNumParameter() == 0) {
      return attributeSignature() + "_visited = false;\n";
    } else {
      return attributeSignature() + "_visited.remove(_parameters);\n";
    }
  }

  public void AttrDecl.emitCacheDeclarations(PrintStream out) {
    if(!getLazy())
      return;
    if(getNumParameter() == 0) {
      out.println(ind + "/**");
      out.println(ind + " * @apilevel internal");
      out.println(ind + " */");
      out.println(ind + "protected boolean " + attributeSignature() + "_computed = false;");
      out.println(ind + "/**");
      out.println(ind + " * @apilevel internal");
      out.println(ind + " */");
      out.println(ind + "protected " + getType() + " " + attributeSignature() + "_value;");
      return;
    } else if(declaredNTA()) {
      if(grammar().lazyMaps) {
        out.println(ind + "/**");
        out.println(ind + " * @apilevel internal");
        out.println(ind + " */");
        out.println(ind + "protected " + grammar().typeDefaultMap + " " + attributeSignature() + "_values;");
        out.println(ind + "/**");
        out.println(ind + " * @apilevel internal");
        out.println(ind + " */");
        out.println(ind + "protected List " + attributeSignature() + "_list;");
        return;
      } else {
        out.println(ind + "/**");
        out.println(ind + " * @apilevel internal");
        out.println(ind + " */");
        out.println(ind + "protected " + grammar().typeDefaultMap + " " + attributeSignature() + "_values = " + grammar().createDefaultMap + ";");
        out.println(ind + "/**");
        out.println(ind + " * @apilevel internal");
        out.println(ind + " */");
        out.println(ind + "protected List " + attributeSignature() + "_list;");
        return;
      }
    }
    else {
      if (grammar().lazyMaps) {
        out.println(ind + "protected " + grammar().typeDefaultMap + " " + attributeSignature() + "_values;");
        return;
      } else {
        out.println(ind + "protected " + grammar().typeDefaultMap + " " + attributeSignature() + "_values = " + grammar().createDefaultMap + ";");
        return;
      }
    }
  }

  syn boolean AttrDecl.declaredNTA() = false;
  eq SynDecl.declaredNTA() = getNTA();
  eq InhDecl.declaredNTA() = getNTA();

  public String Parameter.toReferenceType() {
    return toReferenceType(getName(), getType());
  }

  public String ASTNode.toReferenceType(String value, String type) {
    if(type.equals("int"))
      return grammar().java5 ? "Integer.valueOf(" + value + ")" : "new Integer(" + value + ")";
    else if(type.equals("short"))
      return grammar().java5 ? "Short.valueOf(" + value + ")" : "new Short(" + value + ")";
    else if(type.equals("long"))
      return grammar().java5 ? "Long.valueOf(" + value + ")" : "new Long(" + value + ")";
    else if(type.equals("float"))
      return grammar().java5 ? "Float.valueOf(" + value + ")" : "new Float(" + value + ")";
    else if(type.equals("double"))
      return grammar().java5 ? "Double.valueOf(" + value + ")" : "new Double(" + value + ")";
    else if(type.equals("boolean"))
      return "Boolean.valueOf(" + value + ")";
    else if(type.equals("char"))
      return grammar().java5 ? "Character.valueOf(" + value + ")" : "new Character(" + value + ")";
    else return value;
  }

  public String ASTNode.fromReferenceType(String value, String type) {
    if(type.equals("int"))
      return "((Integer)" + value + ").intValue()";
    else if(type.equals("short"))
      return "((Short)" + value + ").shortValue()";
    else if(type.equals("long"))
      return "((Long)" + value + ").longValue()";
    else if(type.equals("float"))
      return "((Float)" + value + ").floatValue()";
    else if(type.equals("double"))
      return "((Double)" + value + ").doubleValue()";
    else if(type.equals("boolean"))
      return "((Boolean)" + value + ").booleanValue()";
    else if(type.equals("char"))
      return "((Character)" + value + ").charValue()";
    else
      return "(" + type + ")" + value;
  }

  public boolean AttrDecl.isPrimitive() {
    String type = getType();
    return type.equals("int") || type.equals("short") || type.equals("long") ||
      type.equals("float") || type.equals("double") || type.equals("boolean") ||
      type.equals("char") || type.equals("byte");
  }

  public boolean AttrDecl.isPrimitive(String type) {
    return type.equals("int") || type.equals("short") || type.equals("long") ||
      type.equals("float") || type.equals("double") || type.equals("boolean") ||
      type.equals("char") || type.equals("byte");
  }

  public boolean TokenComponent.isPrimitive() {
    String type = getTokenId().getTYPE();
    return type.equals("int") || type.equals("short") || type.equals("long") ||
      type.equals("float") || type.equals("double") || type.equals("boolean") ||
      type.equals("char") || type.equals("byte");
  }


  public String AttrDecl.cacheCheck() {
    if(!getLazy() && !isCircular())
      return "";
    if(isNTA() && !(findCorrespondingNTA() instanceof TokenComponent)) {
      int index = indexNTAchild();
      if(getNumParameter() == 0)
        return genIncrementalTracking() +
               "if(" + attributeSignature() + "_computed) {\n" +
               traceEndCachedAttr() +
               ind + "return (" + getType() + ") getChild(" + attributeSignature() + "ChildPosition());\n" +
               "}\n";
      else
        return genIncrementalTracking() +
               "if(" + attributeSignature() + "_values.containsKey(_parameters)) {\n" +
               traceEndCachedAttr() +
               ind + "return (" + getType() + ") getChild(" + attributeSignature() + "ChildPosition()));\n" +
               "}\n";
    }
    if(getNumParameter() == 0)
      return genIncrementalTracking() +
             "if(" + attributeSignature() + "_computed) {\n" +
             traceEndCachedAttr() +
             ind + "return " + attributeSignature() + "_value;\n" +
             "}\n";
    else {
      if(isCircular())
        return genIncrementalTracking() +
               "if(" + attributeSignature() + "_values.containsKey(_parameters)) {\n" +
               ind + "Object _o = " + attributeSignature() + "_values.get(_parameters);\n" +
               ind + "if(!(_o instanceof ASTNode$State.CircularValue)) {\n" +
               traceEndCachedAttr() +
               ind(2) + "return " + fromReferenceType("_o", getType()) + ";\n" +
               ind + "}\n" +
               ind + "else\n" +
               ind(2) + "_value = (ASTNode$State.CircularValue)_o;\n" +
               "}\n";
      else
        return genIncrementalTracking() +
               "if(" + attributeSignature() + "_values.containsKey(_parameters)) {\n" +
               traceEndCachedAttr() +
               ind + "return " + fromReferenceType(attributeSignature() + "_values.get(_parameters)", getType()) + ";\n" +
               "}\n";
    }
  }

  public String AttrDecl.parameterStructure() {
    if(getNumParameter() == 0 || (!getLazy() && !isCircular() && !grammar().visitCheckEnabled)) {
      return "";
    } else if(getNumParameter() == 1) {
      return "Object _parameters = " + getParameter(0).toReferenceType() + ";\n";
    } else {
      StringBuffer s = new StringBuffer();
      s.append("java.util.List _parameters = new java.util.ArrayList(" + getNumParameter() + ");\n");
      for(int i = 0; i < getNumParameter(); i++) {
        s.append("_parameters.add(" + getParameter(i).toReferenceType() + ");\n");
      }
      return s.toString();
    }
  }

  public String AttrDecl.cacheInit() {
    if(!getLazy())
      return "";
    return cacheInitRewrite();
  }

  public String AttrDecl.cacheInitRewrite() {
    if(!grammar().rewriteEnabled) {
      return "";
    } else {
      return "int num = state.boundariesCrossed;\n" +
             "boolean isFinal = this.is$Final();";
    }
  }

  public String AttrDecl.callCompute() {
    if(getLazy() && getNumParameter() == 0)
      return ind(2) + attributeSignature() + "_value = " + attributeName() + "_compute(" + parameters() + ");\n";
    else
      return ind(2) + getType() + " " + attributeSignature() + "_value = " + attributeName() + "_compute(" + parameters() + ");\n";
  }

  // TODO: INH
  public String InhDecl.callCompute() {
    if(getLazy() && getNumParameter() == 0) {
      return inhDebugString() +
        ind(2) + attributeSignature() + "_value = getParent().Define_#TYPEINSIGNATURE#_" + attributeName() + "(" + interfaceParametersStart() + ");\n";
    } else {
      return inhDebugString() +
        ind(2) + getType() + " " + attributeSignature() + "_value = getParent().Define_#TYPEINSIGNATURE#_" + attributeName() + "(" + interfaceParametersStart() + ");\n";
    }
  }

  public String AttrDecl.cacheStoreRewrite() {
    if(!grammar().rewriteEnabled || getFinal())
      return ind + "if(true)";
    else
      return ind + "if(isFinal && num == state().boundariesCrossed)";
  }

  public String AttrDecl.cacheStore() {
    if(!getLazy())
      return "";
    if(getNumParameter() == 0) {
      return cacheStoreRewrite() + "{" +
        genIncrementalTrackingStackTransfer() +
        " " + attributeSignature() + "_computed = true; }\n" +
        genIncrementalTrackingStackClear();
    } else {
      return cacheStoreRewrite() + "{" +
        genIncrementalTrackingStackTransfer() +
        " " + attributeSignature() + "_values.put(_parameters, " + toReferenceType(attributeSignature() + "_value", getType()) + "); }\n" +
        genIncrementalTrackingStackClear() + "\n";
    }
  }

  public String AttrDecl.returnStmt() {
    if(isNTA() && !(findCorrespondingNTA() instanceof TokenComponent)) {
      int index = indexNTAchild();
      return getType() + " node = (" + getType() + ") this.getChild(" + attributeSignature() + "ChildPosition());\n" +
          genIncrementalTrackingStackExit() +
          ind(2) + "return node;\n";
    }

    if (isCircular()) {
      return ind(2) + "return " + attributeSignature() + "_value;\n";
    }

    return genIncrementalTrackingStackExit() +
        ind(2) + "return " + attributeSignature() + "_value;\n";
  }

  syn boolean AttrEq.hasComputeBlock() = true;
  eq SynEq.hasComputeBlock() = getRHS() instanceof ASTBlock;

  /**
   * @return Compute method without "_compute" suffix
   */
  public void AttrDecl.emitInlineCompute(AttrEq equ, PrintStream out) {
    TemplateContext tt = templateContext();
    tt.bind("ParamDecl", equ.parametersDecl());
    tt.bind("ComputeBody", equ.computeMethodBody());
    tt.expand("AttrDecl.emitInlineCompute", out);
  }

  public String AttrEq.computeMethodBody() {
    return "{ }";
  }

  public String SynEq.computeMethodBody() {
    if(hasComputeBlock())
      return Unparser.unparse(getRHS());
    else
      return "{  return " + Unparser.unparse(getRHS()) + ";  }";
  }

  /**
   * @return Code for the method to compute this attribute
   */
  public void AttrEq.emitComputeMethod(PrintStream out) {
  }

  public void SynEq.emitComputeMethod(PrintStream out) {
    TemplateContext tt = templateContext();
    tt.bind("ComputeBody", computeMethodBody());
    tt.expand("SynEq.emitComputeMethod", out);
  }

  syn String AttrDecl.inhDebugString() {
    if(!grammar().debugMode) {
      return "";
    } else {
      return ind(2) + "if(getParent() == null) throw new RuntimeException(\"Trying to evaluate attribute in subtree not attached to main tree\");\n";
    }
  }

  public boolean TypeDecl.hasLazySynEqFor(AttrDecl attr) {
    if(attr instanceof SynDecl) {
      SynEq synEq = lookupSynEq(attr.signature());
      return synEq != null && (synEq.decl().getLazy() || synEq.decl().isCircular()) ;
    }
    return false;
  }

  syn String AttrDecl.cycleLimitCheck() = "";
   // TODO: fixme cycleLimit > 0 ?
   //    "if(state().CIRCLE_INDEX > " + cycleLimit + ") throw new java.lang.RuntimeException(\"Iteration limit " + cycleLimit + " exceeded\");\n" : "";

  public String AttrDecl.genEquation(String paramDecl) {
    TemplateContext tt = templateContext();
    tt.bind("ParamDecl", paramDecl);
    return tt.expand("ASTDecl.genEquation");
  }

  public String AttrDecl.genCircularEquationNoParams() {
    TemplateContext tt = templateContext();
    tt.bind("Cond1", differs("new_" + attributeSignature() + "_value", attributeSignature() + "_value"));
    tt.bind("Cond2", differs("new_" + attributeSignature() + "_value", attributeSignature() + "_value"));
    tt.bind("BottomValue", Unparser.unparse(getBottomValue()));
    tt.bind("TracePrintReturnNewValue", tracePrintReturnNewValue(attributeSignature() + "_value"));
    tt.bind("TracePrintReturnPreviousValue", tracePrintReturnPreviousValue(attributeSignature() + "_value"));

    return tt.expand("ASTDecl.genCircularEquationNoParams");
  }

  public String AttrDecl.genCircularEquationWithParams(String paramDecl) {
    TemplateContext tt = templateContext();
    tt.bind("BottomValue", toReferenceType(Unparser.unparse(getBottomValue()), getType()));
    tt.bind("Cond1", differs("new_" + attributeSignature() + "_value", fromReferenceType("_value.value", getType())));
    tt.bind("ToRefType2", toReferenceType("new_" + attributeSignature() + "_value", getType()));
    tt.bind("ToRefType3", toReferenceType("new_" + attributeSignature() + "_value", getType()));
    tt.bind("Cond2", differs("new_" + attributeSignature() + "_value", fromReferenceType("_value.value", getType())));
    tt.bind("FromRefType1", toReferenceType("new_" + attributeSignature() + "_value", getType()));
    tt.bind("FromRefType2", fromReferenceType("_value.value", getType()));
    tt.bind("ParamDecl", paramDecl);
    tt.bind("TracePrintReturnNewValue", tracePrintReturnNewValue("new_" + attributeSignature() + "_value"));
    tt.bind("TracePrintReturnPreviousValue", tracePrintReturnPreviousValue(fromReferenceType(attributeSignature() + "_values.get(_parameters)" , getType())));
    return tt.expand("ASTDecl.genCircularEquationWithParams");
  }

  /**
   * Generates the method to compute an attribute
   * @param attr The attribute we are adding a compute method for
   */
  public String ASTDecl.genEquation(AttrDecl attr, String paramDecl) {
    if (!attr.isCircular()) {
      return attr.genEquation(paramDecl);
    } else {
      if(attr.getNumParameter() == 0) {
        return attr.genCircularEquationNoParams();
      } else {
        return attr.genCircularEquationWithParams(paramDecl);
      }
    }
  }

  public String AttrDecl.circularComputeCall() { return ""; }
  public String SynDecl.circularComputeCall() { return attributeName() + "_compute(" + parameters() + ")"; }
  public String InhDecl.circularComputeCall() {
    return "getParent().Define_#TYPEINSIGNATURE#_" + attributeName() + "(" + interfaceParametersStart() + ")";
  }

  public String AttrDecl.resetCycleInit() {
     return
        ind(3) + "state.RESET_CYCLE = true;\n" +
        inhDebugString() +
        ind(3) + circularComputeCall() + ";\n" +
        ind(3) + "state.RESET_CYCLE = false;\n";
  }

  public String AttrDecl.resetCycleCheck() {
     if(getNumParameter() == 0)
       return
         "if (state.RESET_CYCLE) {\n" +
         ind + attributeSignature() + "_computed = false;\n" +
         ind + attributeSignature() + "_initialized = false;\n" +
         ind + attributeSignature() + "_visited = -1;\n" +
         ind + returnStmt() +
         "}\n";
     else
       return
         "if (state.RESET_CYCLE) {\n" +
         ind + attributeSignature() + "_values.remove(_parameters);\n" +
         "}\n";
  }

  public String AttrDecl.cacheCycleInit() {
     if (!grammar().cacheCycle) return "";
     return
        "state.LAST_CYCLE = true;\n" +
        inhDebugString() +
        circularComputeCall() + ";\n" +
        "state.LAST_CYCLE = false;\n";
  }

  public String AttrDecl.cacheCycleCheck() {
     if (!grammar().cacheCycle) return "";
     if(getNumParameter() == 0)
       return
         "if (state.LAST_CYCLE) {\n" +
         attributeSignature() + "_computed = true;\n" +
         inhDebugString() +
         genIncrementalTrackingStackEnter2() +
         ind + getType() + " new_" + attributeSignature() + "_value = " + circularComputeCall() + ";\n" +
         genIncrementalTrackingStackExit2() +
         ind + "return new_" + attributeSignature() + "_value;\n" +
         "}\n";
     else {
       if (grammar().java5) 
         return
           "if (state.LAST_CYCLE) {\n" +
           inhDebugString() +
           ind + attributeSignature() + "_values.put(_parameters, new_" + attributeSignature() + "_value);\n" +
           "}\n";
       else
         return
           "if (state.LAST_CYCLE) {\n" +
           inhDebugString() +
           ind + attributeSignature() + "_values.put(_parameters, " + toReferenceType("new_" + attributeSignature() + "_value", getType()) + ");\n" +
           "}\n";
     }
  }

  public String AttrDecl.addComponentCheck() {
    if(!grammar().componentCheck || !grammar().visitCheckEnabled) return "";
    String arg = getNumParameter() == 0 ? "null" : "_parameters";
    if(getNumParameter() == 0) {
      if(grammar().rewriteEnabled)
        return
        "if(" + attributeSignature() + "_visited == state.boundariesCrossed && !state.containsEvalEntry(this, \"" + attributeSignature() + "\", null))\n" +
        ind + "throw new java.lang.RuntimeException(\"XXX\");\n";
      else
        return
        "if(" + attributeSignature() + "_visited != -1 && !state.containsEvalEntry(this, \"" + attributeSignature() + "\", null))\n" +
        ind + "throw new java.lang.RuntimeException(\"XXX\");\n";
    }
    else {
      if(grammar().rewriteEnabled) {
        if (grammar().java5) 
          return
          "if(new Integer(state.boundariesCrossed).equals(_value.visited) && !state.containsEvalEntry(this, \"" + attributeSignature() + "\", _parameters))\n" +
          ind + "throw new java.lang.RuntimeException(\"XXX\");\n";
        else 
          return
          "if(new Integer(state.boundariesCrossed).equals(Integer.valueOf(_value.visited)) && !state.containsEvalEntry(this, \"" + attributeSignature() + "\", _parameters))\n" +
          ind + "throw new java.lang.RuntimeException(\"XXX\");\n";
      } else
        return
        "if(_value.visited != -1 && !state.containsEvalEntry(this, \"" + attributeSignature() + "\", _parameters))\n" +
        ind + "throw new java.lang.RuntimeException(\"XXX\");\n";
    }
  }

  public String AttrDecl.addAddToComponent() {
    if(!grammar().componentCheck || !grammar().visitCheckEnabled) return "";
    if(getNumParameter() == 0) {
      return
        "state.addEvalEntry(this, \"" + attributeSignature() + "\", null);\n";
    } else {
      return
        "state.addEvalEntry(this, \"" + attributeSignature() + "\", _parameters);\n";
    }
  }

  public String AttrDecl.addInterruptedCircleDeclaration() {
    if(!grammar().componentCheck) return "";
    return "boolean interruptedCircle = false;\n";
  }

  public String AttrDecl.addCheckInterruptedCircle() {
    if(!grammar().componentCheck) return "";
    return
      "if(state.IN_CIRCLE) {\n" +
      ind + "interruptedCircle = true;\n" +
      ind + "state.IN_CIRCLE = false;\n" +
      ind + "state.pushEvalStack();\n" +
      "}\n";
  }

  public String AttrDecl.addClearInterruptedCircle() {
    if(!grammar().componentCheck) return "";
    return
      "if(interruptedCircle) {\n" +
      ind + "state.IN_CIRCLE = true;\n" +
      ind + "state.popEvalStack();\n" +
      "}\n";
  }

  public String AttrDecl.differs(String s1, String s2) {
    if (isPrimitive())
      return s1 + "!=" + s2;
    else
      return "(" + s1 + "==null && " + s2 + "!=null) || (" + s1 + "!=null && !" + s1 + ".equals(" + s2 + "))";
  }

  public void ASTDecl.emitCacheDeclarations(PrintStream out, AttrDecl attr) {
    boolean needsCacheDeclaration = true;
    if(attr instanceof SynDecl) {
      // EMMA_2011-09-13: Setting this to true to get declarations for each 
      // equation of an attribute. If an equation lacks its own visited declaration
      // and calls an overriden equation it can cause a circularity exception.
      needsCacheDeclaration = true; // superClass() == null || !superClass().hasLazySynEqFor(attr);
    }
    if (!attr.isCircular()) {
      if (needsCacheDeclaration) {
        attr.emitVisitedDeclarations(out);
        attr.emitCacheDeclarations(out);
      }
    } else {
      if (attr.getNumParameter() == 0) {
        if (!needsCacheDeclaration && attr instanceof SynDecl &&
            superClass() != null && superClass().lookupSynEq(attr.signature()) != null
            && !superClass().lookupSynEq(attr.signature()).decl().isCircular()) {

          needsCacheDeclaration = true;
        }
        if (needsCacheDeclaration) {
          attr.emitVisitedDeclarations(out);
          out.println(ind + "/**");
          out.println(ind + " * @apilevel internal");
          out.println(ind + " */");
          out.println(ind + "protected boolean " + attr.attributeSignature() + "_computed = false;");
          out.println(ind + "/**");
          out.println(ind + " * @apilevel internal");
          out.println(ind + " */");
          out.println(ind + "protected boolean " + attr.attributeSignature() + "_initialized = false;");
          out.println(ind + "/**");
          out.println(ind + " * @apilevel internal");
          out.println(ind + " */");
          out.println(ind + "protected " + attr.getType() + " " + attr.attributeSignature() + "_value;");
          return;
        }
      }
      else {
        if (needsCacheDeclaration) {
          attr.emitVisitedDeclarations(out);
          if (grammar().lazyMaps) {
            out.println(ind + "protected " + grammar().typeDefaultMap + " " + attr.attributeSignature() + "_values;");
            return;
          } else {
            out.println(ind + "protected " + grammar().typeDefaultMap + " " + attr.attributeSignature() + "_values = " + grammar().createDefaultMap + ";");
            return;
          }
        }
      }
    }
  }

  syn String AttrEq.getType() = decl().getType();

  public void ASTDecl.emitSynEquations(PrintStream out) {
    for(int i = 0; i < getNumSynEq(); i++) {
       AttrEq equ = getSynEq(i);
       AttrDecl attr = equ.decl();
       if (attr.isNTA() || attr.getLazy() || attr.isCircular()) {
         out.print(equ.hostFileComment());
         String s = "";
         s += genEquation(attr, equ.parametersDecl());
         s = s.replaceAll("#TYPE#", attr.getType());
         s = s.replaceAll("#TYPEINSIGNATURE#", attr.getTypeInSignature());
         s = s.replaceAll("#NAME#", attr.attributeSignature());
         s = s.replaceAll("#PARMDECL#", equ.parametersDecl());
         s = s.replaceAll("#PARM#", attr.parameters());
         out.print(s);

         equ.emitComputeMethod(out);
       } else {
         attr.emitInlineCompute(equ, out);
       }

       emitCacheDeclarations(out, attr);
    }
  }


  public boolean AttrDecl.isNTA() {
    return false;
  }

  public boolean SynDecl.isNTA() {
    return findCorrespondingNTA() != null;
  }

  public int AttrDecl.indexNTAchild() {
    Components comp = findCorrespondingNTA();
    TypeDecl c = hostClass();
    while(c != null) {
      int index = 0;
      for(Iterator iter = c.getComponents(); iter.hasNext(); ) {
        Components next = (Components)iter.next();
        if(next == comp)
          return index;
        if(!(next instanceof TokenComponent))
          index++;
      }
      c = c instanceof ASTDecl ? ((ASTDecl)c).superClass() : null;
    }
    return -1;
  }

  public Components AttrDecl.findCorrespondingNTA() {
    if(!getName().startsWith("get"))
      return null;
    String attrName = getName().substring(3);
    TypeDecl c = hostClass();
    while(c != null) {
      for(Iterator iter = c.getComponents(); iter.hasNext(); ) {
        Components comp = (Components)iter.next();
        if(comp.name().equals(attrName) && (
            comp instanceof OptionalComponentNTA
            || comp instanceof TokenComponentNTA
            || comp instanceof AggregateComponentsNTA )) {
          return comp;
        }
        if(attrName.equals(comp.name() + "Opt") && comp instanceof OptionalComponentNTA) {
          return comp;
        }
        if(attrName.equals(comp.name() + "List") && comp instanceof ListComponentsNTA) {
          return comp;
        }
      }
      c = c instanceof ASTDecl ? ((ASTDecl)c).superClass() : null;
    }
    return null;
  }

  public String AttrDecl.higherOrderAttributeCode() {
    return "";
  }

  public String SynDecl.higherOrderAttributeCode() {
    if(getNTA()) {
      TemplateContext tt = templateContext();
      tt.bind("NonParameterized", getNumParameter() == 0);

      if(grammar().rewriteEnabled) {
        if(grammar().stagedRewrites) {
          return tt.expand("SynDecl.higherOrderAttributeCode:stagedrewrites");
        } else {
          return tt.expand("SynDecl.higherOrderAttributeCode:nostagedrewrites");
        }
      } else {
        return tt.expand("SynDecl.higherOrderAttributeCode:norewrite");
      }
    } else {
      // non-NTA
      StringBuffer result = new StringBuffer();
      Components comp = findCorrespondingNTA();
      if(comp != null) {
        String attrName = getName().substring(3); // remove get
        if(comp.name().equals(attrName) && (
              comp instanceof OptionalComponentNTA
              || comp instanceof TokenComponentNTA
              || comp instanceof AggregateComponentsNTA )) {
          result.append(ind + "set" + attrName + "(" + attributeSignature() + "_value);\n");
        }
        if(attrName.equals(comp.name() + "Opt") && comp instanceof OptionalComponentNTA) {
          result.append("set" + attrName + "(" + attributeSignature() + "_value);\n");
        }
        if(attrName.equals(comp.name() + "List") && comp instanceof ListComponentsNTA) {
          result.append("set" + attrName + "(" + attributeSignature() + "_value);\n");
        }
      }
      return result.toString();
    }
  }

  public void TypeDecl.emitInhDeclarations(PrintStream out) {
    for(int i = 0; i < getNumInhDecl(); i++) {
       AttrDecl attr = getInhDecl(i);
       out.print(attr.hostFileComment());
       attr.emitInhDecl(out);
    }
  }

  public void AttrDecl.emitInhDecl(PrintStream out) {
    templateContext().expand("AttrDecl.inhDecl", out);
  }

  public void ASTDecl.emitInhDeclarations(PrintStream out) {
    for(int i = 0; i < getNumInhDecl(); i++) {
       AttrDecl attr = getInhDecl(i);
       out.print(attr.hostFileComment());
       String s;
       s = genEquation(attr, attr.parametersDecl());
       s = s.replaceAll("#TYPE#", attr.getType());
       s = s.replaceAll("#TYPEINSIGNATURE#", attr.getTypeInSignature());
       s = s.replaceAll("#NAME#", attr.attributeSignature());
       s = s.replaceAll("#PARMDECL#", attr.parametersDecl());
       s = s.replaceAll("#PARM#", attr.parameters());
       s = s.replaceAll("#INTERFACEPARM#", attr.interfaceParameters());
       out.print(s);

       emitCacheDeclarations(out, attr);
    }
  }

  syn boolean TypeDecl.hasInhEq(String attrName) {
    for(int i = 0; i < getNumInhEq(); i++) {
      InhEq equ = getInhEq(i);
      if(equ.getName().equals(attrName)) {
        return true;
      }
    }
    return false;
  }
  eq ASTDecl.hasInhEq(String attrName) =
    super.hasInhEq(attrName) || superClass() != null && superClass().hasInhEq(attrName);

  syn Components InhEq.getComponents() {
    TypeDecl c = hostClass();
    if(c != null)
      return c.components(sonName());
    return  null;
  }
  syn String InhEq.sonName() = getSonName().startsWith("get") ? getSonName().substring(3) : getSonName();

  syn AttrDecl InhEq.getSonAttrDecl() {
    AttrDecl decl = hostClass().lookupSynDeclPrefix(sonName());
    if(decl == null) decl = hostClass().lookupInhDeclPrefix(sonName());
    return decl;
  }

  syn SynDecl TypeDecl.lookupSynDeclPrefix(String signature) {
    for(int i = 0; i < getNumSynDecl(); i++)
      if(getSynDecl(i).signature().equals(signature) || getSynDecl(i).signature().startsWith(signature + "_"))
        return getSynDecl(i);
    return null;
  }
  eq ASTDecl.lookupSynDeclPrefix(String signature) {
    SynDecl decl = super.lookupSynDeclPrefix(signature);
    if(decl != null || superClass() == null)
      return decl;
    return superClass().lookupSynDeclPrefix(signature);
  }
  syn InhDecl TypeDecl.lookupInhDeclPrefix(String signature) {
    for(int i = 0; i < getNumInhDecl(); i++)
      if(getInhDecl(i).signature().equals(signature) || getInhDecl(i).signature().startsWith(signature + "_"))
        return getInhDecl(i);
    return null;
  }
  syn InhDecl ASTDecl.lookupInhDeclPrefix(String signature) {
    InhDecl decl = super.lookupInhDeclPrefix(signature);
    if(decl != null || superClass() == null)
      return decl;
    return superClass().lookupInhDeclPrefix(signature);
  }


  public void ASTDecl.emitInhEquations(PrintStream out) {
    for(Iterator idIter = inhAttrSet(); idIter.hasNext(); ) {
      String attrId = (String)idIter.next();
      Iterator iter = inhAttrEqs(attrId);
      InhEq equ = (InhEq)iter.next();
      InhDecl decl = (InhDecl)equ.decl();

      out.println(ind + "/**");
      out.println(ind + " * " + equ.declaredat());
      out.println(ind + " * @apilevel internal");
      out.println(ind + " */");
      out.println(ind + "public " + decl.getType() + " Define_" + decl.getTypeInSignature() + "_" + decl.attributeName() + "(" + decl.interfaceParametersDecl() + ") {");

      // have we already generated a component equation?
      boolean hasComponentEq = false;
      boolean hasGetChildEq = false;

      do {
        out.print(ind(2));
        if (hasComponentEq) {
          out.print("else ");
        }
        hasComponentEq = true;

        Components c = equ.getComponents();
        if(c instanceof ListComponents) {
          out.print("if(caller == get" + equ.sonName() + "ListNoTransform())");
        }
        else if(c instanceof OptionalComponent) {
          out.print("if(caller == get" + equ.sonName() + "OptNoTransform())");
        }
        else if(c != null) {
          out.print("if(caller == get" + equ.sonName() + "NoTransform())");
        }
        else if(equ.getSonName().equals("getChild")) {
          hasGetChildEq = true;
        }
        else {
          AttrDecl attrDecl = equ.getSonAttrDecl();
          if(attrDecl.getNumParameter() == 0)
            out.print("if(caller == " + equ.sonName() + "_value)");
          else
            out.print("if(caller == " + attrDecl.signature() + "_list)");
        }

        if(c instanceof ListComponents) {
          String childIndex = equ.hasIndex() ? equ.getIndex().getName() : "childIndex";
          if(equ.getRHS() instanceof ASTBlock) { // Block
            out.println(ind + "{");
            out.println(ind(2) + "int " + childIndex + " = caller.getIndexOfChild(child);");
            out.println(ind(2) + Unparser.unparse(equ.getRHS()));
            out.println(ind + "}");
          }
          else { // Expr
            out.println(ind + "{");
            out.println(ind(2) + "int " + childIndex + " = caller.getIndexOfChild(child);");
            out.println(ind(2) + "return " + Unparser.unparse(equ.getRHS()) + ";");
            out.println(ind + "}");
          }

        }
        else if(c != null) {
          if(equ.getRHS() instanceof ASTBlock) { // Block
            out.println(Unparser.unparse(equ.getRHS()));
          }
          else { // Expr
            out.println(" {");
            out.println(ind(3) + "return " + Unparser.unparse(equ.getRHS()) + ";");
            out.println(ind(2) + "}");
          }
        }
        else if(equ.getSonName().equals("getChild")) {
          String childIndex = equ.hasIndex() ? equ.getIndex().getName() : "childIndex";
          if(equ.getRHS() instanceof ASTBlock) { // Block
            out.println(" {");
            out.println(ind(3) + "int " + childIndex + " = this.getIndexOfChild(caller);");
            out.println(Unparser.unparse(equ.getRHS()));
            out.println(ind(2) + "}");
          }
          else { // Expr
            out.println(" {");
            out.println(ind(3) + "int " + childIndex + " = this.getIndexOfChild(caller);");
            out.println(ind(3) + "return " + Unparser.unparse(equ.getRHS()) + ";");
            out.println(ind(2) + "}");
          }
        }
        else {
          AttrDecl attrDecl = equ.getSonAttrDecl();
          out.println("{");
          if(attrDecl.getNumParameter() != 0) {
            String childIndex = equ.hasIndex() ? equ.getIndex().getName() : "childIndex";
            out.println(ind(3) + "int " + childIndex + " = caller.getIndexOfChild(child);");
          }
          if(equ.getRHS() instanceof ASTBlock) { // Block
            out.println(Unparser.unparse(equ.getRHS()));
            out.println(ind(2) + "}");
          }
          else { // Expr
            out.println(ind(3) + "return " + Unparser.unparse(equ.getRHS()) + ";");
            out.println(ind(2) + "}");
          }
        }

        if(iter.hasNext()) {
          equ = (InhEq)iter.next();
        }
        else {
          equ = null;
        }
      } while(equ != null);

      if (!hasGetChildEq) {
        out.print(ind(2));
        if (hasComponentEq) {
          out.print("else {");
        }
        if(superClass() != null && superClass().hasInhEq(decl.name())) {
          out.println(ind(3) + "return super.Define_" + decl.getTypeInSignature() + "_" + decl.attributeName() + "(" + decl.interfaceParameters() + ");");
          out.println(ind(2) + "}");
        }
        else {
          // TODO: INH
          out.print(decl.inhDebugString());
          out.println(ind(3) +   "return getParent().Define_" + decl.getTypeInSignature() + "_" + decl.attributeName() + "(" + decl.interfaceParametersContinue() + ");");
          out.println(ind(2) + "}");
        }
      }
      out.println(ind + "}");
    }
  }

  public Iterator Grammar.inhAttrSet() {
    return inhEqMap().keySet().iterator();
  }

  syn lazy HashMap Grammar.inhEqMap() {
    HashMap map = new LinkedHashMap();
    for(int i = 0; i < getNumTypeDecl(); i++) {
      if(getTypeDecl(i) instanceof ASTDecl) {
        map.putAll(((ASTDecl)getTypeDecl(i)).inhEqMap());
      }
    }
    return map;
  }

  syn lazy String Rewrite.aspectName() =
    getAspectName();

  public void Grammar.genResetDuringCounters(PrintWriter out) {
    for(Iterator iter = rewriteAspects().iterator(); iter.hasNext(); ) {
      String name = (String)iter.next();
      String s =
                 ind(2) + "if(during" + name + " != 0) {\n" +
                 ind(3) + "System.out.println(\"Warning: resetting during" + name + "\");\n" +
                 ind(3) + "during" + name + " = 0;\n" +
                 ind(2) + "}\n";
      out.print(s);
    }

  }

  syn String AttrEq.inhDebugString() = decl().inhDebugString();

  public void AttrEq.emitInhEqSignature(PrintStream out) {
    templateContext().expand("AttrEq.emitInhEqSignature", out);
  }

  //  TODO: INH
  public void ASTDecl.emitInhEqSignatures(PrintStream out) {
    if(name().equals("ASTNode")) {
      for(Iterator iter = env().inhEqMap().entrySet().iterator(); iter.hasNext(); ) {
        java.util.Map.Entry entry = (java.util.Map.Entry)iter.next();
        String attrId = (String)entry.getKey();
        AttrEq attr = (AttrEq)((LinkedList)entry.getValue()).get(0);
        if(!hasInhEq(attr.decl().name())) {
          attr.emitInhEqSignature(out);
        }
      }
    }
  }
}
