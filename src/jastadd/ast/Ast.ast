Grammar ::= TypeDecl*  RegionDecl*;

/** Region declarations for coarse incremental dependency tracking, e.g., "region A;" */
RegionDecl ::= IdUse;

abstract TypeDecl ::= IdDecl ClassBodyDecl* SynDecl* SynEq* InhDecl* InhEq*
    Component* CollDecl* <FileName> <StartLine:int> <EndLine:int>
    <Comment:String> <AspectName:String>;

ClassDecl : TypeDecl;

InterfaceDecl : TypeDecl;

EnumDecl : TypeDecl;

ASTDecl : TypeDecl ::= [Abstract] IdDecl [SuperClass:IdUse] Component*
    SynDecl* SynEq* InhDecl* InhEq* ClassBodyDecl* Rewrite* CollDecl* CollEq*
    <FileName> <StartLine:int> <EndLine:int> <Comment:String>
    SynthesizedNta*;

Abstract;

Annotation ::= <Annotation:String>;

abstract AttrDecl ::= Parameter* <Name> <Type> <Lazy:boolean> <FileName> <StartLine:int>
    <EndLine:int> <Final:boolean> <NTA:boolean> <Comment:String> <AspectName:String> Annotation*;

SynDecl : AttrDecl;

InhDecl : AttrDecl;

CollDecl : AttrDecl ::= <Target>;

Parameter ::= <Type:String> <Name:String>;

abstract AttrEq ::= Parameter* <Name> <FileName> <StartLine:int> <EndLine:int> <Comment:String>
    <AspectName:String> Annotation*;

SynEq : AttrEq ::= Parameter* <Name> <FileName> <StartLine:int> <EndLine:int> <Comment:String>
    <AspectName:String>;

InhEq : AttrEq ::= Parameter* <Name> <FileName> <StartLine:int> <EndLine:int> <Comment:String>
    <AspectName:String> <ChildName> [Index:Parameter];

CollEq : AttrEq ::= Parameter* <Name> <FileName> <StartLine:int> <EndLine:int> <Comment:String>
    <AspectName:String> Contribution* <TargetName:String> <TargetAttributeName:String>
    <RefSet:boolean> <Reference:String>;

Contribution ::= <Value:String> <Condition:String>;

ClassBodyDecl ::= <Name> <FileName> <StartLine:int> <EndLine:int> <AspectName:String>;

Rewrite ::= <FileName> <StartLine:int> <EndLine:int> <AspectName>;

RewriteList : Rewrite;

/** A component of an AST node type declaration. */
abstract Component;

ListComponent : Component ::= Id;

ListComponentNTA : ListComponent;

OptionalComponent : Component ::= Id;

OptionalComponentNTA : OptionalComponent;

TokenComponent : Component ::= TokenId;

TokenComponentNTA : TokenComponent;

AggregateComponent : Component ::= Id;

AggregateComponentNTA : AggregateComponent;

Id ::= [NameNode] IdUse;

NameNode ::= <ID:String>;

IdUse ::= <ID:String>;

IdDecl ::= <ID:String>;

TokenId ::= <ID:String> <TYPE:String>;

/**
 * Used to represent synthesized NTA components.
 *
 * <p>Synthesized NTAs are mostly not treated as components, but we need to know
 * about them when checking for missing inherited equations.
 */
SynthesizedNta ::= <Name:String> <Type:String>;
