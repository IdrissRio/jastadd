/* Copyright (c) 2005-2015, The JastAdd Team
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Lund University nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
import java.util.Set;
import java.util.HashSet;
import java.util.Collection;
import java.util.LinkedList;

aspect CollectionAttributes {

  syn boolean AttrDecl.isCollection() = false;

  eq CollDecl.isCollection() = true;

  syn String CollDecl.rootType() = root().name();

  /**
   * Find interface collection attribute declarations.
   */
  public Collection<CollDecl> TypeDecl.interfaceCollDecls() {
    LinkedList<CollDecl> list = new LinkedList<CollDecl>();
    for (InterfaceDecl type : implementedInterfaces()) {
      for (CollDecl decl : type.getCollDeclList()) {
        list.add(decl);
      }
      list.addAll(type.interfaceCollDecls());
    }
    return list;
  }

  public void ASTDecl.emitCollDecls(PrintStream out) {
    for (CollDecl decl : interfaceCollDecls()) {
      emitCollDecl(out, decl);
    }
    for (CollDecl decl : getCollDeclList()) {
      emitCollDecl(out, decl);
    }
  }

  public void ASTDecl.emitCollDecl(PrintStream out, CollDecl attr) {
    if (attr.circularCollection()) {
      attr.emitVisitedDeclarations(out);
      attr.emitCircularCollectionEval(out);
      attr.emitComputeMethod(out);
      attr.emitCacheDeclarations(out);
    } else {
      attr.emitVisitedDeclarations(out);
      attr.emitAttrEquation(out);
      attr.emitComputeMethod(out);
      attr.emitCacheDeclarations(out);
    }
  }

  syn TypeDecl AttrDecl.root() = grammar().root();
  eq CollDecl.root() = root != null ? grammar().lookup(root) : super.root();

  // Only used by circular collection attributes.
  public void AttrDecl.emitCircularCollectionEval(PrintStream out) {
    TemplateContext tt = templateContext();
    tt.bind("BottomValue", Unparser.unparse(getBottomValue()));
    tt.bind("ChangeCondition", valueComparisonExpr("new_" + signature() + "_value", signature() + "_value"));
    tt.bind("CircularComputeRhs", signature() + "_value = " + name() + "_compute()");
    tt.bind("TracePrintReturnNewValue", tracePrintReturnNewValue(signature() + "_value"));
    tt.bind("TracePrintReturnPreviousValue", tracePrintReturnPreviousValue(signature() + "_value"));
    tt.expand("AttrDecl.circularEquation:unparameterized", out);
  }

  // Only used by non-circular collection attributes.
  public void CollDecl.emitComputeMethod(PrintStream out) {
    String rootType = root().name();
    TemplateContext tt = templateContext();
    tt.bind("BottomValue", Unparser.unparse(getBottomValue()));
    if (onePhase()) {
      tt.expand("CollDecl.computeMethod:onePhase", out);
    } else {
      tt.expand("CollDecl.computeMethod:twoPhase", out);
    }
  }

  syn boolean TypeDecl.hasCollEq(CollDecl decl) = false;

  eq ASTDecl.hasCollEq(CollDecl decl) {
    for (int i = 0; i < getNumCollEq(); i++) {
      if (getCollEq(i).decl() == decl) {
        return true;
      }
    }
    return false;
  }

  syn lazy String CollEq.contributionSignature() =
      ((CollDecl) decl()).getTarget() + "_" + signature();

  /**
   * Lazy condition means that the condition is evaluated during the
   * combination phase in two-phase collection evaluation, as opposed to
   * eagerly evaluating the condition during the survey phase.
   *
   * <p>This corresponds to "late condition evaluation" in the collection
   * attribute paper, as opposed to "early condition evaluation".
   *
   * <p>Defaults to {@code true}.
   */
  syn boolean AttrDecl.lazyCondition() = hasAnnotation("@LazyCondition");
  syn boolean AttrEq.lazyCondition() = decl().lazyCondition();

  /**
   * One phase evaluation combines the survey and combination phases.
   *
   * <p>Defaults to {@code false}.
   */
  syn boolean AttrDecl.onePhase() = hasAnnotation("@OnePhase");
  syn boolean AttrEq.onePhase() = decl().onePhase();

  /**
   * In naive evaluation the tree is traversed once per collection attribute,
   * and there is only one phase.
   *
   * <p>Defaults to {@code false}.
   */
  syn boolean AttrDecl.naive() = hasAnnotation("@Naive");
  syn boolean AttrEq.naive() = decl().naive();

  public void ASTDecl.emitCollContributions(PrintStream out) {
    // Find all collection equations in this node and group them according to either
    // the collection declaration or group name.
    collectContributors(out);
    contributeTo(out);
  }

  syn boolean Contribution.hasCondition() =
    getCondition() != null && !getCondition().trim().isEmpty();


  private void ASTDecl.collectContributors(PrintStream out) {
    // Mapping collection declaration to collection equations.
    HashMap<CollDecl, Collection<CollEq>> map = new LinkedHashMap<CollDecl, Collection<CollEq>>();

    for (int i = 0; i < getNumCollEq(); i++) {
      CollEq attr = getCollEq(i);
      CollDecl decl = (CollDecl) attr.decl();
      Collection<CollEq> equations = map.get(decl);
      if (equations == null) {
        equations = new ArrayList<CollEq>();
        map.put(decl, equations);
      }
      equations.add(attr);
    }

    for (Map.Entry<CollDecl, Collection<CollEq>> entry : map.entrySet()) {
      CollDecl decl = entry.getKey();
      Collection<CollEq> equations = entry.getValue();

      decl.templateContext().expand("CollDecl.collectContributors:header", out);

      String bottomValue = Unparser.unparse(decl.getBottomValue());

      for (CollEq attr : equations) {
        TemplateContext tt = attr.templateContext();
        tt.bind("BottomValue", bottomValue);
        tt.bind("CombOp", decl.getCombOp());

        for (int j = 0; j < attr.getNumContribution(); j++) {
          Contribution c = attr.getContribution(j);
          tt.bind("Condition", c.getCondition().trim());
          if (decl.onePhase()) {
            tt.bind("HasCondition", c.hasCondition());
            tt.bind("Value", c.getValue().trim());
            tt.expand("CollEq.collectContributors:onePhase", out);
          } else {
            tt.bind("HasCondition", c.hasCondition() && !decl.lazyCondition());
            tt.expand("CollEq.collectContributors:twoPhase", out);
          }
        }
      }
      decl.templateContext().expand("CollDecl.collectContributors:end", out);
    }
  }

  private void ASTDecl.contributeTo(PrintStream out) {
    HashMap<CollDecl, ArrayList<CollEq>> map = new LinkedHashMap<CollDecl, ArrayList<CollEq>>();
    for (int i = 0; i < getNumCollEq(); i++) {
      CollEq attr = getCollEq(i);
      if (!attr.onePhase()) {
        CollDecl decl = (CollDecl) attr.decl();
        ArrayList<CollEq> equations = map.get(decl);
        if (equations == null) {
          equations = new ArrayList<CollEq>();
          map.put(decl, equations);
        }
        equations.add(attr);
      }
    }

    for (Map.Entry<CollDecl, ArrayList<CollEq>> entry : map.entrySet()) {
      CollDecl decl = entry.getKey();
      ArrayList<CollEq> equations = entry.getValue();

      decl.templateContext().expand("CollDecl.contributeTo:header", out);
      for (CollEq attr : equations) {
        for (Contribution c : attr.getContributionList()) {
          TemplateContext tt = c.templateContext();
          tt.bind("CombOp", decl.getCombOp());
          tt.expand("Contribution.statement", out);
        }
      }
      out.println(config().indent + "}");
    }
  }

  syn String CollEq.collectionId() = decl().collectionId();

  syn lazy String AttrDecl.collectionId() = signature();

  eq CollDecl.collectionId() {
    String value = getAnnotationValue("@CollectionGroup");
    if (value != null) {
      return "CollectionGroup_" + value;
    }
    return signature();
  }

  syn String CollEq.signature() = decl().signature();

  syn lazy String CollDecl.signature() {
    StringBuffer s = new StringBuffer();
    s.append(getTarget());
    s.append("_");
    s.append(name());
    for (int i = 0; i < getNumParameter(); i++) {
      s.append("_" + getParameter(i).getType());
    }
    return s.toString();
  }

  syn lazy Collection<ASTDecl> Grammar.roots() {
    Collection<ASTDecl> roots = new HashSet<ASTDecl>();
    for (TypeDecl decl : getTypeDeclList()) {
      if (decl.isRootNode()) {
        roots.add((ASTDecl) decl);
      }
    }
    return roots;
  }

  syn ASTDecl Grammar.root() = roots().isEmpty() ? null : roots().iterator().next();

  eq ASTDecl.getCollDecl().hostClass() = this;

  eq ASTDecl.getCollEq().hostClass() = this;

  public void Grammar.weaveCollectionAttributes() {
    for (int i = 0; i < getNumTypeDecl(); i++) {
      getTypeDecl(i).weaveCollectionAttributes();
    }
  }

  public void TypeDecl.weaveCollectionAttributes() { }

  private Set<String> TypeDecl.processedCollectingSignatures = new HashSet<String>();

  protected boolean TypeDecl.processedCollectingSignature(String signature) {
    if (processedCollectingSignatures.contains(signature)) {
      return true;
    } else {
      processedCollectingSignatures.add(signature);
      return false;
    }
  }

  protected String TypeDecl.collectionReset() {
    StringBuilder res = new StringBuilder();
    for (int k = 0; k < grammar().getNumTypeDecl(); k++) {
      TypeDecl typeDecl = grammar().getTypeDecl(k);
      for (CollDecl decl : typeDecl.interfaceCollDecls()) {
        TemplateContext tt = decl.templateContext();
        if (decl.root() == this) {
          res.append(tt.expand("Collection.flush"));
        }
      }
      for (int i = 0; i < typeDecl.getNumCollDecl(); i++) {
        CollDecl attr = typeDecl.getCollDecl(i);
        TemplateContext tt = attr.templateContext();
        if (attr.root() == this) {
          res.append(tt.expand("Collection.flush"));
        }
      }
    }
    return res.toString();
  }

  public void ASTDecl.weaveCollectionAttributes() {
    for (CollDecl decl : interfaceCollDecls()) {
      decl.weaveCollectionAttribute();
    }
    for (CollDecl decl : getCollDeclList()) {
      decl.weaveCollectionAttribute();
    }
  }

  public void CollDecl.weaveCollectionAttribute() {
    TemplateContext tt = templateContext();

    TypeDecl astNode = grammar().lookup(config().astNodeType());
    TypeDecl rootDecl = root();
    if (astNode != null && rootDecl != null) {
      if (!astNode.processedCollectingSignature(collectionId())) {
        if (!astNode.hasCollEq(this)) {
          String s = "";
          s += tt.expand("CollDecl.collectContributors:header");
          s += tt.expand("CollDecl.collectContributors:end");
          if (isCircular() || !onePhase()) {
            s += tt.expand("CollDecl.contributeTo:default");
          }
          astNode.addClassDeclaration(s, getFileName(), getStartLine());
        }
        String surveyMethod = tt.expand("CollDecl.surveyMethod");
        rootDecl.addClassDeclaration(surveyMethod, getFileName(), getStartLine());
      }
    }
  }

  /**
   * Finds the declaration node of a collection equation.
   *
   * @return the collection attribute declaration, or {@code null} if no
   * declaration was found.
   */
  eq CollEq.decl() {
    TypeDecl typeDecl = grammar().lookup(getTargetName());
    if (typeDecl != null) {
      TypeDecl astDecl = (TypeDecl) typeDecl;
      for (int i = 0; i < astDecl.getNumCollDecl(); i++) {
        if (astDecl.getCollDecl(i).getName().equals(getTargetAttributeName())) {
          return astDecl.getCollDecl(i);
        }
      }
    }
    return null;
  }

  coll HashSet CollDecl.uses() [new LinkedHashSet()] with add;

  CollEq contributes this when decl() != null to CollDecl.uses() for decl();

  public void Grammar.addCollDecl(String name, String type, String className,
      String fileName, int startLine, int endLine, ASTExpression startValue,
      String combOp, boolean isCircular, ArrayList<String> annotations,
      org.jastadd.jrag.AST.SimpleNode node, String root, String aspectName) {
    TypeDecl c = lookup(className);
    if (c != null) {
      CollDecl decl = new CollDecl();
      decl.setName(name);
      decl.setType(type);
      decl.setLazy(true);
      decl.setFileName(fileName);
      decl.setStartLine(startLine);
      decl.setEndLine(endLine);
      decl.setParameterList(new List());
      decl.setStartValue(startValue);
      decl.setCombOp(combOp);
      for (String annotation : annotations) {
        decl.addAnnotation(new Annotation(annotation));
      }
      decl.setCircularCollection(isCircular || annotations.contains("@Circular"));
      decl.setComment(Unparser.unparseComment(node));
      decl.setTarget(className);
      decl.root = root;
      decl.setAspectName(aspectName);
      ((TypeDecl) c).addCollDecl(decl);
    } else {
      errorf("Can not add collection attribute %s %s to unknown class %s in %s at line %d",
          type, name, className, fileName, startLine);
    }
  }

  public String CollDecl.root = null;

  syn boolean AttrDecl.hasAnnotation(String name) {
    for (int i = 0; i < getNumAnnotation(); ++i) {
      if (getAnnotation(i).isAnnotation(name)) {
        return true;
      }
    }
    return false;
  }

  syn String AttrDecl.getAnnotationValue(String name) {
    for (int i = 0; i < getNumAnnotation(); ++i) {
      if (getAnnotation(i).isAnnotation(name)) {
        return getAnnotation(i).value();
      }
    }
    // TODO(jesper): don't return null here, use a null object.
    return null;
  }

  public void Grammar.addCollEq(String targetName, String targetAttributeName,
      String attributeType, String reference,
      org.jastadd.ast.AST.List contributionList, String fileName,
      int startLine, int endLine, boolean refSet,
      org.jastadd.jrag.AST.SimpleNode node, String aspectName,
      ArrayList<String> annotations) {
    TypeDecl c = lookup(attributeType);
    if (c != null && c instanceof ASTDecl) {
      CollEq equ = new CollEq(
          new List(),
          new List(),
          targetName,
          fileName,
          startLine,
          endLine,
          Unparser.unparseComment(node),
          aspectName,
          contributionList,
          targetName,
          targetAttributeName,
          refSet,
          reference);
      for (String annotation : annotations) {
        equ.addAnnotation(new Annotation(annotation));
      }
      ((ASTDecl) c).addCollEq(equ);
    } else {
      errorf("Can not add collection contribution to unknown class %s in %s at line %d",
          attributeType, fileName, startLine);
    }
  }

  private ASTExpression CollDecl.startValue;

  public void CollDecl.setStartValue(ASTExpression e) {
    startValue = e;
  }

  public ASTExpression CollDecl.getBottomValue() {
    return startValue;
  }

  /** The combining method used to update the collection. */
  private String CollDecl.combOp;

  public void CollDecl.setCombOp(String s) {
    combOp = s;
  }

  public String CollDecl.getCombOp() {
    return combOp;
  }

  private boolean CollDecl.circularCollection;

  public void CollDecl.setCircularCollection(boolean b) {
    circularCollection = b;
  }

  public boolean CollDecl.circularCollection() {
    return circularCollection;
  }

  public boolean CollDecl.isCircular() {
    return circularCollection();
  }

  private static boolean CollDecl.isValidIdentifierPart(String s) {
    for (int i = 0; i < s.length(); i++) {
      if (!Character.isJavaIdentifierPart(s.charAt(i))) {
        return false;
      }
    }
    return true;
  }
}
