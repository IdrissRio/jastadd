/* Copyright (c) 2005-2015, The JastAdd Team
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Lund University nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
import java.util.Set;
import java.util.HashSet;
import java.util.Collection;
import java.util.LinkedList;

aspect CollectionAttributes {

  /**
   * Find interface collection attribute declarations.
   */
  public Collection<CollDecl> TypeDecl.interfaceCollDecls() {
    LinkedList<CollDecl> list = new LinkedList<CollDecl>();
    for (InterfaceDecl type : implementedInterfaces()) {
      for (CollDecl decl : type.getCollDeclList()) {
        list.add(decl);
      }
      list.addAll(type.interfaceCollDecls());
    }
    return list;
  }

  public void ASTDecl.emitCollDecls(PrintStream out) {
    for (CollDecl decl : interfaceCollDecls()) {
      emitCollDecl(out, decl);
    }
    for (CollDecl decl : getCollDeclList()) {
      emitCollDecl(out, decl);
    }
  }

  public void ASTDecl.emitCollDecl(PrintStream out, CollDecl attr) {
    if (attr.circularCollection()) {
      attr.emitVisitedDeclarations(out);
      attr.emitCircularCollectionEval(out);
      attr.emitCombineMethod(out);
    } else {
      out.println(attr.docComment());
      attr.emitAttrEquation(out);
      attr.emitComputeMethod(out);
      emitCacheDeclarations(out, attr);
    }
  }

  public void InterfaceDecl.emitInterfaceCollections(PrintStream out) {
    for (int i = 0; i < getNumCollDecl(); i++) {
      CollDecl attr = getCollDecl(i);
      if (!attr.separateEvaluation() && (attr.isCircular() || !attr.onePhase())) {
        TemplateContext tt = attr.templateContext();
        tt.expand("CollDecl.interfaceDeclaration", out);
      }
    }
  }

  syn TypeDecl AttrDecl.root() = grammar().root();
  eq CollDecl.root() = root != null ? grammar().lookup(root) : super.root();

  // Only used by circular collection attributes.
  public void AttrDecl.emitCircularCollectionEval(PrintStream out) {
    TemplateContext tt = templateContext();
    tt.bind("BottomValue", Unparser.unparse(getBottomValue()));
    tt.bind("RootType", root().name());
    tt.bind("SeparateEvaluation", separateEvaluation());
    tt.bind("Cond1", valueComparisonExpr("new_" + signature() + "_value", signature() + "_value"));
    tt.bind("Cond2", valueComparisonExpr("new_" + signature() + "_value",
            fromReferenceType(signature() + "_values.get(_parameters)", getType())));

    String rhs;
    if (separateEvaluation()) {
      rhs = Unparser.unparse(getBottomValue()) + ";\n" + "root." + name() + "_"
          + signature() + "_nextIteration(this)";
    } else {
      rhs = signature() + "_value = combine_"
          + signature() + "_contributions(" + Unparser.unparse(getBottomValue()) + ")";
    }
    tt.bind("CircularComputeRHS", rhs);
    tt.bind("CircularComputeStmt",
        String.format("%s new_%s_value = %s;", getType(), signature(), rhs));

    tt.expand("AttrDecl.circularCollectionEval", out);
  }

  public String CollDecl.cacheCycleCheck() {
    if (separateEvaluation()) {
      return templateContext().expand("CollDecl.cacheCycleCheck");
    } else {
      return super.cacheCycleCheck();
    }
  }

  // Only used by non-circular collection attributes.
  public void CollDecl.emitComputeMethod(PrintStream out) {
    String rootType = root().name();
    TemplateContext tt = templateContext();
    tt.bind("RootType", rootType);
    tt.bind("BottomValue", Unparser.unparse(getBottomValue()));
    if (separateEvaluation()) {
      tt.expand("CollDecl.computeMethod:separateEvaluation", out);
    } else if (onePhase()) {
      tt.expand("CollDecl.computeMethod:onePhase", out);
    } else {
      tt.expand("CollDecl.computeMethod", out);
    }
  }

  // Only used by circular collection attributes.
  public void CollDecl.emitCombineMethod(PrintStream out) {
    if (!separateEvaluation()) {
      templateContext().expand("CollDecl.combineMethod", out);
    }
  }

  syn boolean TypeDecl.hasCollEq(CollDecl decl) = false;

  eq ASTDecl.hasCollEq(CollDecl decl) {
    for (int i = 0; i < getNumCollEq(); i++) {
      if (getCollEq(i).decl() == decl) {
        return true;
      }
    }
    return false;
  }

  syn lazy String CollEq.contributionSignature() =
      ((CollDecl) decl()).getTarget() + "_" + signature();

  /**
   * Separate evaluation means that the instances of a collection attribute are
   * evaluated separately from each other, as opposed to joint evaluation where
   * all instances of an attribute are evaluated during a single traversal.
   *
   * <p>Defaults to {@code false}.
   */
  syn boolean AttrDecl.separateEvaluation() = hasAnnotation("@SeparateEvaluation") || naive();
  syn boolean AttrEq.separateEvaluation() = decl().separateEvaluation();

  /**
   * Lazy condition means that the condition is evaluated during the
   * combination phase in two-phase collection evaluation, as opposed to
   * eagerly evaluating the condition during the survey phase.
   *
   * <p>This corresponds to "late condition evaluation" in the collection
   * attribute paper, as opposed to "early condition evaluation".
   *
   * <p>Defaults to {@code true}.
   */
  syn boolean AttrDecl.lazyCondition() = hasAnnotation("@LazyCondition");
  syn boolean AttrEq.lazyCondition() = decl().lazyCondition();

  /**
   * One phase evaluation combines the survey and combination phases.
   *
   * <p>Defaults to {@code false}.
   */
  syn boolean AttrDecl.onePhase() = hasAnnotation("@OnePhase");
  syn boolean AttrEq.onePhase() = decl().onePhase();

  /**
   * In naive evaluation the tree is traversed once per collection attribute,
   * and there is only one phase.
   *
   * <p>Defaults to {@code false}.
   */
  syn boolean AttrDecl.naive() = hasAnnotation("@Naive");
  syn boolean AttrEq.naive() = decl().naive();

  public void ASTDecl.emitCollContributions(PrintStream out) {
    // Find all collection equations in this node and group them according to either
    // the collection declaration or group name.
    collectContributors(out);
    contributeTo(out);
    nextIteration(out); // Similar code for separate evaluation.
  }

  syn boolean Contribution.hasCondition() =
    getCondition() != null && !getCondition().trim().isEmpty();


  private void ASTDecl.collectContributors(PrintStream out) {
    // Mapping collection declaration -> collection equations (excluding separate eval eqs)
    HashMap<CollDecl, Collection<CollEq>> map = new LinkedHashMap<CollDecl, Collection<CollEq>>();
    for (int i = 0; i < getNumCollEq(); i++) {
      CollEq attr = getCollEq(i);
      if (!attr.separateEvaluation()) {
        CollDecl decl = (CollDecl) attr.decl();
        Collection<CollEq> equations = map.get(decl);
        if (equations == null) {
          equations = new ArrayList<CollEq>();
          map.put(decl, equations);
        }
        equations.add(attr);
      }
    }

    for (Map.Entry<CollDecl, Collection<CollEq>> entry : map.entrySet()) {
      CollDecl decl = entry.getKey();
      Collection<CollEq> equations = entry.getValue();

      out.println(config().indent + "protected void collect_contributors_"
          + decl.collectingSignature() + "() {"); // Once per group.

      if (isRootNode()) {
        out.println(config().ind(2) + "if (collect_contributors_"
            + decl.collectingSignature() + ") return;");
      }

      String bottomValue = Unparser.unparse(decl.getBottomValue());

      for (CollEq attr : equations) {
        TemplateContext tt = attr.templateContext();
        tt.bind("BottomValue", bottomValue);
        tt.bind("CombOp", decl.getCombOp());

        for (int j = 0; j < attr.getNumContribution(); j++) {
          Contribution c = attr.getContribution(j);
          tt.bind("Condition", c.getCondition().trim());
          if (decl.onePhase() || decl.separateEvaluation()) {
            tt.bind("HasCondition", c.hasCondition());
            tt.bind("Value", c.getValue().trim());
            tt.expand("ASTDecl.collectContributors:onePhase", out);
          } else {
            tt.bind("HasCondition", c.hasCondition() && !decl.lazyCondition());
            tt.expand("ASTDecl.collectContributors:twoPhase", out);
          }
        }
      }
      if (isASTNodeDecl()) {
        out.println(config().ind(2) + "for (int i = 0; i < getNumChild(); i++)");
        out.println(config().ind(3) + "getChild(i).collect_contributors_"
            + decl.collectingSignature() + "();"); // Once per group.
      } else {
        out.println(config().ind(2) + "super.collect_contributors_"
            + decl.collectingSignature() + "();");
        if (isRootNode()) {
          out.println(config().ind(2) + "collect_contributors_"
              + decl.collectingSignature() + " = true;");
        }
      }
      out.println(config().indent + "}");
    }
  }

  private void ASTDecl.contributeTo(PrintStream out) {
    HashMap<CollDecl, ArrayList<CollEq>> map = new LinkedHashMap<CollDecl, ArrayList<CollEq>>();
    for (int i = 0; i < getNumCollEq(); i++) {
      CollEq attr = getCollEq(i);
      if (!attr.separateEvaluation() && !attr.onePhase()) {
        CollDecl decl = (CollDecl) attr.decl();
        ArrayList<CollEq> equations = map.get(decl);
        if (equations == null) {
          equations = new ArrayList<CollEq>();
          map.put(decl, equations);
        }
        equations.add(attr);
      }
    }

    for (Map.Entry<CollDecl, ArrayList<CollEq>> entry : map.entrySet()) {
      CollDecl decl = entry.getKey();
      ArrayList<CollEq> equations = entry.getValue();

      out.println(config().indent + "protected void contributeTo_" + decl.getTarget()
          + "_" + decl.signature() + "(" + decl.getType() + " collection) {");
      out.println(config().ind(2) + "super.contributeTo_" + decl.getTarget()
          + "_" + decl.signature() + "(collection);");
      for (CollEq attr : equations) {
        for (int j = 0; j < attr.getNumContribution(); j++) {
          Contribution c = attr.getContribution(j);
          if (c.hasCondition()) {
            out.println(config().ind(2) + "if (" + c.getCondition().trim() + ")");
            out.println(config().ind(3) + "collection." + decl.getCombOp()
                + "(" + c.getValue().trim() + ");");
          } else {
            out.println(config().ind(2) + "collection." + decl.getCombOp()
                + "(" + c.getValue().trim() + ");");
          }
        }
      }
      out.println(config().indent + "}\n");
    }
  }

  private void ASTDecl.nextIteration(PrintStream out) {
    HashMap<CollDecl, ArrayList<CollEq>> map = new LinkedHashMap<CollDecl, ArrayList<CollEq>>();
    for (int i = 0; i < getNumCollEq(); i++) {
      CollEq attr = getCollEq(i);
      if (attr.separateEvaluation()) {
        CollDecl decl = (CollDecl) attr.decl();
        ArrayList<CollEq> equations = map.get(decl);
        if (equations == null) {
          equations = new ArrayList<CollEq>();
          map.put(decl, equations);
        }
        equations.add(attr);
      }
    }

    for (Map.Entry<CollDecl, ArrayList<CollEq>> entry : map.entrySet()) {
      CollDecl decl = entry.getKey();
      ArrayList<CollEq> equations = entry.getValue();

      CollEq firstEq = equations.get(0);

      String valueAccess;
      if (decl != null && !decl.isCircular()) {
        valueAccess = "n.";
      } else {
        valueAccess = "n.new_";
      }

      out.println(config().indent + "protected void " + decl.getTarget() + "_"
          + firstEq.signature() + "_nextIteration(" + decl.getTarget() + " n) {");
      for (CollEq attr : equations) {
        TemplateContext tt = attr.templateContext();
        tt.bind("CombOp", decl.getCombOp());
        tt.bind("ValueAccess", valueAccess);

        out.println(attr.docComment());
        for (int j = 0; j < attr.getNumContribution(); j++) {
          Contribution c = attr.getContribution(j);
          tt.bind("Value", c.getValue().trim());
          tt.bind("HasCondition", c.hasCondition());
          tt.bind("Condition", c.getCondition().trim());
          tt.expand("ASTDecl.nextIteration", out);
        }
      }
      if (isASTNodeDecl()) {
        out.println(config().ind(2) + "for (int i = 0; i < getNumChild(); i++)");
        out.println(config().ind(3) + "getChild(i)." + decl.getTarget() + "_"
            + firstEq.signature() + "_next_Iteration(n);"); // Once per group.
      } else {
        out.println(config().ind(3) + "r." + decl.getTarget() + "_"
            + firstEq.signature() + "_nextIteration(n);");
      }
      out.println(config().indent + "}");
    }
  }

  syn String CollEq.collectingSignature() = decl().collectingSignature();

  syn lazy String AttrDecl.collectingSignature() = signature();

  eq CollDecl.collectingSignature() {
    String value = getAnnotationValue("@CollectionGroup");
    if (value != null) {
      return "CollectionGroup_" + value;
    }
    return signature();
  }

  syn String CollEq.signature() = decl().signature();

  syn lazy String CollDecl.signature() {
    StringBuffer s = new StringBuffer();
    s.append(getTarget());
    s.append("_");
    s.append(name());
    for (int i = 0; i < getNumParameter(); i++) {
      s.append("_" + getParameter(i).getType());
    }
    return s.toString();
  }

  syn lazy Collection<ASTDecl> Grammar.roots() {
    Collection<ASTDecl> roots = new HashSet<ASTDecl>();
    for (TypeDecl decl : getTypeDeclList()) {
      if (decl.isRootNode()) {
        roots.add((ASTDecl) decl);
      }
    }
    return roots;
  }

  syn ASTDecl Grammar.root() = roots().isEmpty() ? null : roots().iterator().next();

  eq ASTDecl.getCollDecl().hostClass() = this;

  eq ASTDecl.getCollEq().hostClass() = this;

  public void Grammar.weaveCollectionAttributes() {
    for (int i = 0; i < getNumTypeDecl(); i++) {
      getTypeDecl(i).weaveCollectionAttributes();
    }
  }

  public void TypeDecl.weaveCollectionAttributes() { }

  private Set<String> TypeDecl.processedCollectingSignatures = new HashSet<String>();

  protected boolean TypeDecl.processedCollectingSignature(String signature) {
    if (processedCollectingSignatures.contains(signature)) {
      return true;
    } else {
      processedCollectingSignatures.add(signature);
      return false;
    }
  }

  protected String TypeDecl.collectionReset() {
    StringBuilder res = new StringBuilder();
    for (int k = 0; k < grammar().getNumTypeDecl(); k++) {
      TypeDecl typeDecl = grammar().getTypeDecl(k);
      for (CollDecl decl : typeDecl.interfaceCollDecls()) {
        TemplateContext tt = decl.templateContext();
        if (decl.root() == this && !decl.separateEvaluation()) {
          res.append(tt.expand("Collection.flush"));
        }
      }
      for (int i = 0; i < typeDecl.getNumCollDecl(); i++) {
        CollDecl attr = typeDecl.getCollDecl(i);
        TemplateContext tt = attr.templateContext();
        if (attr.root() == this && !attr.separateEvaluation()) {
          res.append(tt.expand("Collection.flush"));
        }
      }
    }
    return res.toString();
  }

  public void ASTDecl.weaveCollectionAttributes() {
    for (CollDecl decl : interfaceCollDecls()) {
      decl.weaveCollectionAttribute();
    }
    for (CollDecl decl : getCollDeclList()) {
      decl.weaveCollectionAttribute();
    }
  }

  public void CollDecl.weaveCollectionAttribute() {
    TemplateContext tt = templateContext();

    boolean separateEvaluation = separateEvaluation();
    TypeDecl astNode = grammar().lookup(config().astNodeType());
    TypeDecl rootDecl = root();
    if (astNode != null && rootDecl != null) {
      if (!astNode.processedCollectingSignature(collectingSignature())) {
        if (!astNode.hasCollEq(this)) {
          String s = "";
          if (separateEvaluation) {
            s = tt.expand("ASTDecl.weaveCollectionAttributes.nextIteration");
          } else {
            s += tt.expand("ASTDecl.weaveCollectionAttributes.collectContributors1");
            if (isCircular() || !onePhase()) {
              s += tt.expand("ASTDecl.weaveCollectionAttributes.contributeTo");
            }
          }
          astNode.classBodyDecls.add(buildClassBodyObject(s, getFileName(), getStartLine()));
        }
        if (!separateEvaluation) {
          String s = "";
          if (circularCollection()) {
            s = tt.expand("ASTDecl.weaveCollectionAttributes.collectContributors2");
          } else {
            if (!rootDecl.hasCollEq(this)) {
              s = tt.expand("ASTDecl.weaveCollectionAttributes.collectContributors3");
            } else {
              s = tt.expand("ASTDecl.weaveCollectionAttributes.collectContributors4");
            }
          }
          rootDecl.classBodyDecls.add(buildClassBodyObject(s, getFileName(), getStartLine()));
        }
      }
    }
  }

  private ClassBodyObject CollDecl.buildClassBodyObject(String data,
      String fileName, int line) {
    org.jastadd.jrag.AST.SimpleNode n = new org.jastadd.jrag.AST.ASTBlock(0);
    n.firstToken = n.lastToken = org.jastadd.jrag.AST.Token.newToken(0);
    n.firstToken.image = data;
    return new ClassBodyObject(n, fileName, line, "<NoAspect>");
  }

  /**
   * Finds the declaration node of a collection equation. Returns {@code null}
   * if no declaration was found.
   */
  eq CollEq.decl() {
    TypeDecl typeDecl = grammar().lookup(getTargetName());
    if (typeDecl != null) {
      TypeDecl astDecl = (TypeDecl)typeDecl;
      for (int i = 0; i < astDecl.getNumCollDecl(); i++)
        if (astDecl.getCollDecl(i).getName().equals(getTargetAttributeName())) {
          return astDecl.getCollDecl(i);
        }
    }
    return null;
  }

  coll HashSet CollDecl.uses() [new LinkedHashSet()] with add;

  CollEq contributes this when decl() != null to CollDecl.uses() for decl();

  public void Grammar.addCollDecl(String name, String type, String className,
      String fileName, int startLine, int endLine, ASTExpression startValue,
      String combOp, boolean isCircular, ArrayList<String> annotations,
      org.jastadd.jrag.AST.SimpleNode node, String root, String aspectName) {
    TypeDecl c = lookup(className);
    if (c != null) {
      CollDecl decl = new CollDecl();
      decl.setName(name);
      decl.setType(type);
      decl.setLazy(true);
      decl.setFileName(fileName);
      decl.setStartLine(startLine);
      decl.setEndLine(endLine);
      decl.setParameterList(new List());
      decl.setStartValue(startValue);
      decl.setCombOp(combOp);
      for (String annotation : annotations) {
        decl.addAnnotation(new Annotation(annotation));
      }
      decl.setCircularCollection(isCircular || annotations.contains("@Circular"));
      decl.setComment(Unparser.unparseComment(node));
      decl.setTarget(className);
      decl.root = root;
      decl.setAspectName(aspectName);
      ((TypeDecl) c).addCollDecl(decl);
    } else {
      errorf("Can not add collection attribute %s %s to unknown class %s in %s at line %d",
          type, name, className, fileName, startLine);
    }
  }

  public String CollDecl.root = null;

  syn boolean AttrDecl.hasAnnotation(String name) {
    for (int i = 0; i < getNumAnnotation(); ++i) {
      if (getAnnotation(i).isAnnotation(name)) {
        return true;
      }
    }
    return false;
  }

  syn String AttrDecl.getAnnotationValue(String name) {
    for (int i = 0; i < getNumAnnotation(); ++i) {
      if (getAnnotation(i).isAnnotation(name)) {
        return getAnnotation(i).value();
      }
    }
    // TODO(jesper): don't return null here, use a null object.
    return null;
  }

  public void Grammar.addCollEq(String targetName, String targetAttributeName,
      String attributeType, String reference,
      org.jastadd.ast.AST.List contributionList, String fileName,
      int startLine, int endLine, boolean refSet,
      org.jastadd.jrag.AST.SimpleNode node, String aspectName,
      ArrayList<String> annotations) {
    TypeDecl c = lookup(attributeType);
    if (c != null && c instanceof ASTDecl) {
      CollEq equ = new CollEq(
          new List(),
          new List(),
          targetName,
          fileName,
          startLine,
          endLine,
          Unparser.unparseComment(node),
          aspectName,
          contributionList,
          targetName,
          targetAttributeName,
          refSet,
          reference);
      for (String annotation : annotations) {
        equ.addAnnotation(new Annotation(annotation));
      }
      ((ASTDecl) c).addCollEq(equ);
    } else {
      errorf("Can not add collection contribution to unknown class %s in %s at line %d",
          attributeType, fileName, startLine);
    }
  }

  private ASTExpression CollDecl.startValue;

  public void CollDecl.setStartValue(ASTExpression e) {
    startValue = e;
  }

  public ASTExpression CollDecl.getBottomValue() {
    return startValue;
  }

  /** The combining method used to update the collection. */
  private String CollDecl.combOp;

  public void CollDecl.setCombOp(String s) {
    combOp = s;
  }

  public String CollDecl.getCombOp() {
    return combOp;
  }

  private boolean CollDecl.circularCollection;

  public void CollDecl.setCircularCollection(boolean b) {
    circularCollection = b;
  }

  public boolean CollDecl.circularCollection() {
    return circularCollection;
  }

  public boolean CollDecl.isCircular() {
    return circularCollection();
  }

  private static boolean CollDecl.isValidIdentifierPart(String s) {
    for (int i = 0; i < s.length(); i++) {
      if (!Character.isJavaIdentifierPart(s.charAt(i))) {
        return false;
      }
    }
    return true;
  }
}
