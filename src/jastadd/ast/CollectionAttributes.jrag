/* Copyright (c) 2005-2013, The JastAdd Team
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Lund University nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
aspect CollectionAttributes {

  public void ASTDecl.emitCollDecls(PrintStream out) {
    for(int i = 0; i < getNumCollDecl(); i++) {
      CollDecl attr = getCollDecl(i);
      if(attr.circularCollection()) {
        attr.emitVisitedDeclarations(out);
        attr.emitCircular(out);
        attr.emitCombineMethod(out);
      } else {
        out.println(attr.hostFileComment());
        emitEquation(attr, attr.parametersDecl(), out);
        attr.emitComputeMethod(out);
        emitCacheDeclarations(out, attr);
      }
    }
  }

  public void InterfaceDecl.emitInterfaceCollections(PrintStream out) {
    for(int i = 0; i < getNumCollDecl(); i++) {
      CollDecl attr = getCollDecl(i);
      if(!attr.separateEvaluation() && (attr.isCircular() || !attr.onePhase())) {
        out.println(ind + "/**");
        out.println(ind + " * @apilevel internal");
        out.println(ind + " */");
        out.println(ind + "public " + grammar().typeDefaultSet + " " + attr.attributeSignature() + "_contributors();");
      }
    }
  }

  syn TypeDecl AttrDecl.root() = hostClass().env().root();
  eq CollDecl.root() = root != null ? hostClass().env().lookup(root) : super.root();

  syn String AttrDecl.collDebugString() {
    if(!grammar().debugMode)
      return "";
    else
      return "if(node == null) throw new RuntimeException(\"Trying to evaluate collection attribute in subtree not attached to main tree\");";
  }

  // only used by circular collection attributes
  public void AttrDecl.emitCircular(PrintStream out) {
    TemplateContext tt = templateContext();
    tt.bind("BottomValue", Unparser.unparse(getBottomValue()));
    tt.bind("RootType", root().name());
    tt.bind("SeparateEvaluation", "" + separateEvaluation());
    tt.bind("Cond1", differs("new_" + attributeSignature() + "_value", attributeSignature() + "_value"));
    tt.bind("Cond2", differs("new_" + attributeSignature() + "_value", fromReferenceType(attributeSignature() + "_values.get(_parameters)", getType())));
    tt.bind("RefType1", toReferenceType(Unparser.unparse(getBottomValue()), getType()));
    tt.bind("RefType2", toReferenceType("new_" + attributeSignature() + "_value", getType()));
    tt.bind("FromRefType", fromReferenceType("" + attributeSignature() + "_values.get(_parameters)" , getType()));
    tt.bind("FromRefTypeParamCircular", fromReferenceType("_o", getType()));
    tt.bind("FromRefTypeParam", fromReferenceType(attributeSignature() + "_values.get(_parameters)", getType()));
    tt.expand("AttrDecl.circularCollectionEval", out);
  }

  public String CollDecl.cacheCycleCheck() {
    if(!separateEvaluation())
      return super.cacheCycleCheck();
    if (!grammar().cacheCycle) return "";
    if(getNumParameter() == 0) {
      return
        "if (state().LAST_CYCLE) {\n" +
        setVisited() +
        circularComputeCall() + ";\n" +
        clearVisited() +
        ind + attributeSignature() + "_computed = true;\n" +
        ind + "return " + attributeSignature() + "_value;\n" +
        "}\n";
    } else {
      return
        "if (state().LAST_CYCLE) {\n" +
        setVisited() +
        circularComputeCall() + ";\n" +
        clearVisited() +
        ind + attributeSignature() + "_computed.add(_parameters);\n" +
        ind + "return " + fromReferenceType(attributeSignature() + "_values.get(_parameters)" , getType()) + ";\n" +
        "}\n";
    }
  }

  // only used by circular collection attributes
  public String CollDecl.circularComputeCall() {
    if(separateEvaluation()) {
      return "new_" + attributeSignature() + "_value = " + Unparser.unparse(getBottomValue()) + ";\n" +
             "root." + name() + "_" + attributeSignature() + "_nextIteration(this)";
    } else {
      return attributeSignature() + "_value = combine_" + attributeSignature() + "_contributions(" + Unparser.unparse(getBottomValue()) + ")";
    }
  }

  // only used by non-circular collection attributes
  public void CollDecl.emitComputeMethod(PrintStream out) {
    String rootType = root().name();
    TemplateContext tt = templateContext();
    tt.bind("RootType", rootType);
    tt.bind("BottomValue", Unparser.unparse(getBottomValue()));
    if(separateEvaluation()) {
      tt.expand("CollDecl.computeMethod:separateEvaluation", out);
    } else if(onePhase()) {
      tt.expand("CollDecl.computeMethod:onePhase", out);
    } else {
      tt.expand("CollDecl.computeMethod", out);
    }
  }
  // only used by circular collection attributes
  public void CollDecl.emitCombineMethod(PrintStream out) {
    if (!separateEvaluation()) {
      templateContext().expand("CollDecl.combineMethod", out);
    }
  }

  syn boolean ASTDecl.isASTNode() = name().equals("ASTNode");
  syn boolean TypeDecl.hasCollEq(CollDecl decl) = false;
  eq ASTDecl.hasCollEq(CollDecl decl) {
    for(int i = 0; i < getNumCollEq(); i++)
      if(getCollEq(i).decl() == decl)
        return true;
    return false;
  }

  syn lazy String CollEq.contributionSignature() = ((CollDecl)decl()).getTarget() + "_" + attributeSignature();

  syn boolean AttrDecl.separateEvaluation() = hasAnnotation("@SeparateEvaluation") || naive();
  syn boolean AttrEq.separateEvaluation() = decl().separateEvaluation();
  syn boolean AttrDecl.lazyCondition() = hasAnnotation("@LazyCondition");
  syn boolean AttrEq.lazyCondition() = decl().lazyCondition();

  syn boolean AttrDecl.onePhase() = hasAnnotation("@OnePhase") /*|| naive()*/;
  syn boolean AttrEq.onePhase() = decl().onePhase();

  syn boolean AttrDecl.naive() = hasAnnotation("@Naive");
  syn boolean AttrEq.naive() = decl().naive();

  public void ASTDecl.emitCollContributions(PrintStream out) {
    // find all coll eq in this node and group them according to either the coll decl or group name
    collectContributors(out);
    contributeTo(out);
    // and similar code for separate evaluation
    nextIteration(out);
  }

  syn boolean Contribution.hasCondition() =
    getCondition() != null && !getCondition().trim().isEmpty();


  private void ASTDecl.collectContributors(PrintStream out) {
    HashMap<CollDecl,ArrayList<CollEq>> map = new LinkedHashMap<CollDecl,ArrayList<CollEq>>();
    for(int i = 0; i < getNumCollEq(); i++) {
      CollEq attr = getCollEq(i);
      if(!attr.separateEvaluation()) {
        CollDecl decl = (CollDecl) attr.decl();
        ArrayList<CollEq> equations = map.get(decl);
        if (equations == null) {
          equations = new ArrayList<CollEq>();
          map.put(decl, equations);
        }
        equations.add(attr);
      }
    }

    for (Map.Entry<CollDecl,ArrayList<CollEq>> entry: map.entrySet()) {
      CollDecl decl = entry.getKey();
      ArrayList<CollEq> equations = entry.getValue();

      CollEq firstEq = equations.get(0);

      out.println(ind + "protected void collect_contributors_" + decl.collectingSignature() + "() {"); // once per group

      if (isRootNode()) {
        out.println(ind(2) + "if(collect_contributors_" + decl.collectingSignature() + ") return;");
      }

      String bottomValue = Unparser.unparse(decl.getBottomValue());

      for (CollEq attr: equations) {
        TemplateContext tt = attr.templateContext();
        tt.bind("BottomValue", bottomValue);
        tt.bind("CombOp", decl.getCombOp());

        out.println(attr.hostFileComment());
        for (int j = 0; j < attr.getNumContribution(); j++) {
          Contribution c = attr.getContribution(j);
          tt.bind("Condition", c.getCondition().trim());
          if (decl.onePhase() || decl.separateEvaluation()) {
            tt.bind("HasCondition", c.hasCondition());
            tt.bind("Value", c.getValue().trim());
            tt.expand("ASTDecl.collectContributors:alt1", out);
          } else {
            tt.bind("HasCondition", c.hasCondition() && !decl.lazyCondition());
            tt.expand("ASTDecl.collectContributors:alt2", out);
          }
        }
      }
      if (isASTNode()) {
        out.println(ind(2) + "for(int i = 0; i < getNumChild(); i++)");
        out.println(ind(3) + "getChild(i).collect_contributors_" + decl.collectingSignature() + "();"); // once per group
      } else {
        out.println(ind(2) + "super.collect_contributors_" + decl.collectingSignature() + "();");
        if (isRootNode()) {
          out.println(ind(2) + "collect_contributors_" + decl.collectingSignature() + " = true;");
        }
      }
      out.println(ind + "}");
    }
  }

  private void ASTDecl.contributeTo(PrintStream out) {
    HashMap<CollDecl,ArrayList<CollEq>> map = new LinkedHashMap<CollDecl,ArrayList<CollEq>>();
    for(int i = 0; i < getNumCollEq(); i++) {
      CollEq attr = getCollEq(i);
      if(!attr.separateEvaluation() && !attr.onePhase()) {
        CollDecl decl = (CollDecl) attr.decl();
        ArrayList<CollEq> equations = map.get(decl);
        if (equations == null) {
          equations = new ArrayList<CollEq>();
          map.put(decl, equations);
        }
        equations.add(attr);
      }
    }

    for (Map.Entry<CollDecl,ArrayList<CollEq>> entry: map.entrySet()) {
      CollDecl decl = entry.getKey();
      ArrayList<CollEq> equations = entry.getValue();

      out.println(ind + "protected void contributeTo_" + decl.getTarget() + "_" + decl.attributeSignature() + "(" + decl.getType() + " collection) {");
      out.println(ind(2) + "super.contributeTo_" + decl.getTarget() + "_" + decl.attributeSignature() + "(collection);");
      for (CollEq attr: equations) {
        for (int j = 0; j < attr.getNumContribution(); j++) {
          Contribution c = attr.getContribution(j);
          if (c.hasCondition() /* && attr.getNumContribution() > 1*/) {
            out.println(ind(2) + "if(" + c.getCondition().trim() + ")");
            out.println(ind(3) + "collection." + decl.getCombOp() + "(" + c.getValue().trim() + ");");
          } else {
            out.println(ind(2) + "collection." + decl.getCombOp() + "(" + c.getValue().trim() + ");");
          }
        }
      }
      out.println(ind + "}\n");
    }
  }

  private void ASTDecl.nextIteration(PrintStream out) {
    HashMap<CollDecl,ArrayList<CollEq>> map = new LinkedHashMap<CollDecl,ArrayList<CollEq>>();
    for(int i = 0; i < getNumCollEq(); i++) {
      CollEq attr = getCollEq(i);
      if(attr.separateEvaluation()) {
        CollDecl decl = (CollDecl) attr.decl();
        ArrayList<CollEq> equations = map.get(decl);
        if (equations == null) {
          equations = new ArrayList<CollEq>();
          map.put(decl, equations);
        }
        equations.add(attr);
      }
    }

    for(Map.Entry<CollDecl,ArrayList<CollEq>> entry : map.entrySet()) {
      CollDecl decl = entry.getKey();
      ArrayList<CollEq> equations = entry.getValue();

      CollEq firstEq = equations.get(0);

      String valueAccess;
      if(decl != null && !decl.isCircular()) {
        valueAccess = "n.";
      } else {
        valueAccess = "n.new_";
      }

      out.println(ind + "protected void " + decl.getTarget() + "_" + firstEq.attributeSignature() + "_nextIteration(" + decl.getTarget() + " n) {");
      for (CollEq attr: equations) {
        TemplateContext tt = attr.templateContext();
        tt.bind("CombOp", decl.getCombOp());
        tt.bind("ValueAccess", valueAccess);

        out.println(attr.hostFileComment());
        for (int j = 0; j < attr.getNumContribution(); j++) {
          Contribution c = attr.getContribution(j);
          tt.bind("Value", c.getValue().trim());
          tt.bind("HasCondition", c.hasCondition());
          tt.bind("Condition", c.getCondition().trim());
          tt.expand("ASTDecl.nextIteration", out);
        }
      }
      if(isASTNode()) {
        out.println(ind(2) + "for(int i = 0; i < getNumChild(); i++)");
        out.println(ind(3) + "getChild(i)." + decl.getTarget() + "_" + firstEq.attributeSignature() + "_next_Iteration(n);"); // once per group
      } else {
        out.println(ind(3) + "r." + decl.getTarget() + "_" + firstEq.attributeSignature() + "_nextIteration(n);");
      }
      out.println(ind + "}");
    }
  }


  syn String CollEq.collectingSignature() = decl().collectingSignature();
  syn lazy String AttrDecl.collectingSignature() = attributeSignature();
  eq CollDecl.collectingSignature() {
    String value = getAnnotationValue("@CollectionGroup");
    if(value != null)
      return "CollectionGroup_" + value;
    return attributeSignature();
  }

  syn String CollEq.attributeSignature() = decl().attributeSignature();
  syn lazy String CollDecl.attributeSignature() {
    StringBuffer s = new StringBuffer();
    s.append(getTarget());
    s.append("_");
    s.append(name());
    for(int i = 0; i < getNumParameter(); i++) {
      s.append("_" + getParameter(i).getType());
    }
    return s.toString();
  }

  syn ASTDecl Grammar.root() = (ASTDecl)roots().iterator().next();
  eq ASTDecl.getCollDecl().hostClass() = this;
  eq ASTDecl.getCollEq().hostClass() = this;

  public void Grammar.weaveCollectionAttributes() {
    for(int i = 0; i < getNumTypeDecl(); i++)
      getTypeDecl(i).weaveCollectionAttributes();
  }
  public void TypeDecl.weaveCollectionAttributes() { }

  private HashSet TypeDecl.processedCollectingSignatures = null;
  protected boolean TypeDecl.processedCollectingSignature(String signature) {
    if(processedCollectingSignatures == null)
      processedCollectingSignatures = new LinkedHashSet();
    if(processedCollectingSignatures.contains(signature))
      return true;
    processedCollectingSignatures.add(signature);
    return false;
  }
  protected String TypeDecl.collectionReset = "";

  public void ASTDecl.weaveCollectionAttributes() {
    for(int i = 0; i < getNumCollDecl(); i++) {
      CollDecl attr = getCollDecl(i);
      boolean separateEvaluation = attr.separateEvaluation();
      TypeDecl astDecl = env().lookup("ASTNode");
      TypeDecl rootDecl = attr.root();
      if(astDecl != null && rootDecl != null) {
        boolean process = !astDecl.processedCollectingSignature(attr.collectingSignature());
        if(!astDecl.hasCollEq(attr) && process) {
          String s = "";
          if(separateEvaluation) {
            s =
              ind + "protected void " + attr.getTarget() + "_" + attr.attributeSignature() + "_nextIteration(" + attr.getTarget() + " n) {\n" +
              ind(2) + "for(int i = 0; i < getNumChild(); i++)\n" +
              ind(3) + "getChild(i)." + attr.getTarget() + "_" + attr.attributeSignature() + "_nextIteration(n);\n" +
              ind + "}\n\n";
          }

          if(process && !separateEvaluation/*&& attr.isCircular() && !separateEvaluation*/) {
            // TODO: replace !attr.naive() with !(!attr.isCircular() && separateEvaluation)
            s = s +
              ind + "protected void collect_contributors_" + attr.collectingSignature() + "() {\n" +
              ind(2) + "for(int i = 0; i < getNumChild(); i++)\n" +
              ind(3) + "getChild(i).collect_contributors_" + attr.collectingSignature() + "();\n" +
              ind + "}\n\n";
          }

          if(!separateEvaluation && (attr.isCircular() || !attr.onePhase())) {
            s = s +
              ind + "protected void contributeTo_" + attr.getTarget() + "_" + attr.attributeSignature() + "(" + attr.getType() + " collection) {\n" +
              ind + "}\n";
          }

          astDecl.classBodyDecls.add(buildClassBodyObject(s, attr.getFileName(), attr.getStartLine()));
        }
        if(process) {
          String s = "";
          String flush = "";
          if(attr.circularCollection() && !separateEvaluation) {
            s =
              ind + "private boolean collect_contributors_" + attr.collectingSignature() + " = false;\n" +
              ind + "public boolean collecting_contributors_" + attr.collectingSignature() + " = false;\n" +
              ind + "protected void collect_contributors_" + attr.collectingSignature() + "() {\n" +
              ind(2) + "if(collect_contributors_" + attr.collectingSignature() + ") return;\n" +
              ind(2) + "collecting_contributors_" + attr.collectingSignature() + " = true;\n" +
              ind(2) + "super.collect_contributors_" + attr.collectingSignature() + "();\n" +
              ind(2) + "collecting_contributors_" + attr.collectingSignature() + " = false;\n" +
              ind(2) + "collect_contributors_" + attr.collectingSignature() + " = true;\n" +
              ind + "}\n\n";
            flush =
              ind(2) + "collect_contributors_" + attr.collectingSignature() + " = false;\n" +
              ind(2) + "collecting_contributors_" + attr.collectingSignature() + " = false;\n";
          } else if(!attr.circularCollection() && !attr.separateEvaluation()) {
            if(!rootDecl.hasCollEq(attr)) {
              s =
              ind + "private boolean collect_contributors_" + attr.collectingSignature() + " = false;\n" +
              ind + "protected void collect_contributors_" + attr.collectingSignature() + "() {\n" +
              ind(2) + "if(collect_contributors_" + attr.collectingSignature() + ") return;\n" +
              ind(2) + "super.collect_contributors_" + attr.collectingSignature() + "();\n" +
              ind(2) + "collect_contributors_" + attr.collectingSignature() + " = true;\n" +
              ind + "}\n\n";
            }
            else {
              s =
              ind + "private boolean collect_contributors_" + attr.collectingSignature() + " = false;\n";
            }
            flush =
              ind(2) + "collect_contributors_" + attr.collectingSignature() + " = false;\n";
          }
          rootDecl.classBodyDecls.add(buildClassBodyObject(s, attr.getFileName(), attr.getStartLine()));
          rootDecl.collectionReset += flush;
        }
      }
    }
  }

  private ClassBodyObject ASTDecl.buildClassBodyObject(String data, String fileName, int line) {
    jrag.AST.SimpleNode n = new jrag.AST.ASTBlock(0);
    n.firstToken = n.lastToken = jrag.AST.Token.newToken(0);
    n.firstToken.image = data;
    return new ClassBodyObject(n, fileName, line, "<NoAspect>");
  }



  // name binding
  eq CollEq.decl() {
    TypeDecl typeDecl = hostClass().env().lookup(getTargetName());
    if(typeDecl != null /*&& typeDecl instanceof ASTDecl*/) {
      TypeDecl astDecl = (TypeDecl)typeDecl;
      for(int i = 0; i < astDecl.getNumCollDecl(); i++)
        if(astDecl.getCollDecl(i).getName().equals(getTargetAttributeName()))
          return astDecl.getCollDecl(i);
    }
    return null;
  }

  coll HashSet CollDecl.uses() [new LinkedHashSet()] with add;
  CollEq contributes this when decl() != null to CollDecl.uses() for decl();

  // build AST from parser
  // EMMA_2009-11-27: Adding enclosing aspect as parameter
  public void Grammar.addCollDecl(String name, String type, String className, String fileName, int startLine, int endLine, ASTExpression startValue, String combOp, boolean isCircular, ArrayList annotations, jrag.AST.SimpleNode node, String root, String aspectName) {
    TypeDecl c = lookup(className);
    if(c != null/* && c instanceof ASTDecl*/) {
      CollDecl decl = new CollDecl();
      decl.setName(name);
      decl.setType(type);
      decl.setLazy(true);
      decl.setFileName(fileName);
      decl.setStartLine(startLine);
      decl.setEndLine(endLine);
      decl.setParameterList(new List());
      decl.setStartValue(startValue);
      decl.setCombOp(combOp);
      decl.setAnnotations(annotations);
      decl.setCircularCollection(isCircular || annotations.contains("@Circular"));
      decl.setComment(Unparser.unparseComment(node));
      decl.setTarget(className);
      decl.root = root;
      decl.setAspectName(aspectName);
      ((TypeDecl)c).addCollDecl(decl);
    }
    else
      error("Can not add collection attribute " + type + " " + name + " to unknown class " + className + " in " + fileName + " at line " + startLine);
  }

  public String CollDecl.root = null;

  public boolean AttrDecl.hasAnnotation(String s) { return false; }
  public boolean CollDecl.hasAnnotation(String s) {
    if(annotations == null) return false;
    for(Iterator iter = annotations.iterator(); iter.hasNext(); ) {
      String a = (String)iter.next();
      if(a.equals(s) || a.startsWith(s + "("))
        return true;
    }
    return false;
  }
  public String CollDecl.getAnnotationValue(String s) {
    for(Iterator iter = annotations.iterator(); iter.hasNext(); ) {
      String key = (String)iter.next();
      key = key.replace('(', ',');
      key = key.replace(')', ',');
      if(key.startsWith(s + ",")) {
        String[] strs = key.split(",");
        if(strs.length > 1) {
          return strs[1].substring(1,strs[1].length()-1); // remove quotes
        }
      }
    }
    return null;
  }
  private ArrayList CollDecl.annotations;
  public void CollDecl.setAnnotations(ArrayList list) {
    annotations = list;
  }


  public void Grammar.addCollEq(String targetName, String targetAttributeName, String attributeType, String reference, ast.AST.List contributionList, String fileName, int startLine, int endLine, boolean refSet, jrag.AST.SimpleNode node, String aspectName) {
    TypeDecl c = lookup(attributeType);
    if(c != null && c instanceof ASTDecl) {
      CollEq collEq = new CollEq(
          new List(),
          targetName,
          fileName,
          startLine,
          endLine,
          Unparser.unparseComment(node),
          aspectName,
          contributionList,
          targetName,
          targetAttributeName,
          refSet,
          reference);
      ((ASTDecl)c).addCollEq(collEq);
    }
    else
      error("Can not add collection contribution to unknown class " + attributeType + " in " + fileName + " at line " + startLine);
  }

  private ASTExpression CollDecl.startValue;
  public void CollDecl.setStartValue(ASTExpression e) { startValue = e; }
  public ASTExpression CollDecl.getBottomValue() { return startValue; }
  private String CollDecl.combOp;
  public void CollDecl.setCombOp(String s) { combOp = s; }
  public String CollDecl.getCombOp() { return combOp; }
  private boolean CollDecl.circularCollection;
  public void CollDecl.setCircularCollection(boolean b) { circularCollection = b; }
  public boolean CollDecl.circularCollection() { return circularCollection; }
  public boolean CollDecl.isCircular() { return circularCollection(); }


  eq CollDecl.error() {
    StringBuffer result = new StringBuffer();
    for(Iterator iter = annotations.iterator(); iter.hasNext(); ) {
      String annotation = (String)iter.next();
      if(!knownAnnotation(annotation)) {
        result.append(getFileName() + ":" + getStartLine() + " ");
        result.append("Unknown annotation: " + annotation + "\n");
      }
    }
    if(hasAnnotation("@CollectionGroup")) {
      String value = getAnnotationValue("@CollectionGroup");
      if(value == null)
        result.append(getFileName() + ":" + getStartLine() + " Missing CollectionGroup argument\n");
      else if(value.equals(""))
        result.append(getFileName() + ":" + getStartLine() + " CollectionGroup argument can not be empty\n");
      else if(!isValidIdentifierPart(value))
        result.append(getFileName() + ":" + getStartLine() + " CollectionGroup argument must be a valid identifier part\n");
    }
    if(root == null && hostClass().env().roots().size() != 1) {
      result.append(getFileName() + ":" + getStartLine() + " Multiple tree roots to search for contributions. Please explicitly select one of");
      for(Iterator iter = hostClass().env().roots().iterator(); iter.hasNext(); ) {
        ASTDecl decl = (ASTDecl)iter.next();
        result.append(" " + decl.name());
      }
      result.append("\n");
    }
    if(uses().isEmpty())
      result.append(getFileName() + ":" + getStartLine() + " No contributions for this collection attribute\n");
    return result.toString();
  }

  private static boolean CollDecl.isValidIdentifierPart(String s) {
    for(int i = 0; i < s.length(); i++)
      if(!Character.isJavaIdentifierPart(s.charAt(i)))
        return false;
    return true;
  }

  syn boolean CollDecl.knownAnnotation(String s) {
    if(s.equals("@OnePhase"))
      return true;
    if(s.equals("@SeparateEvaluation"))
      return true;
    if(s.equals("@LazyCondition"))
      return true;
    if(s.equals("@Circular"))
      return true;
    if(s.equals("@CollectionGroup") || s.startsWith("@CollectionGroup("))
      return true;
    if(s.equals("@Naive"))
      return true;
    return false;
  }

  eq CollEq.error() {
    StringBuffer result = new StringBuffer();
  if(decl() == null) {
      result.append(getFileName() + ":" + getStartLine() + " ");
      result.append("Undeclared collection attribute " + "\n");
  }
    return result.toString();
  }

}
