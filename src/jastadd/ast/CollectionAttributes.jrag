/* Copyright (c) 2005-2013, The JastAdd Team
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Lund University nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
aspect CollectionAttributes {

  /**
   * Find interface coll decl introductions.
   */
  public Collection<CollDecl> TypeDecl.interfaceCollDecls() {
    LinkedList<CollDecl> list = new LinkedList<CollDecl>();
    for (Iterator iter = implementsList.iterator(); iter.hasNext(); ) {
      String typename = Unparser.unparse((org.jastadd.jrag.AST.SimpleNode) iter.next());
      int index = typename.indexOf('<');
      if (index != -1) {
        typename = typename.substring(0, index);
      }
      TypeDecl type = grammar().lookup(typename);
      if (type instanceof InterfaceDecl) {
        for (CollDecl decl: type.getCollDeclList()) {
          list.add(decl);
        }
        list.addAll(type.interfaceCollDecls());
      }
    }
    return list;
  }

  public void ASTDecl.emitCollDecls(PrintStream out) {
    for (CollDecl decl: interfaceCollDecls()) {
      emitCollDecl(out, decl);
    }
    for (CollDecl decl: getCollDeclList()) {
      emitCollDecl(out, decl);
    }
  }

  public void ASTDecl.emitCollDecl(PrintStream out, CollDecl attr) {
    if (attr.circularCollection()) {
      attr.emitVisitedDeclarations(out);
      attr.emitCircularCollectionEval(out);
      attr.emitCombineMethod(out);
    } else {
      out.println(attr.docComment());
      attr.emitAttrEquation(out);
      attr.emitComputeMethod(out);
      emitCacheDeclarations(out, attr);
    }
  }

  public void InterfaceDecl.emitInterfaceCollections(PrintStream out) {
    for (int i = 0; i < getNumCollDecl(); i++) {
      CollDecl attr = getCollDecl(i);
      if (!attr.separateEvaluation() && (attr.isCircular() || !attr.onePhase())) {
        String ind = config().indent;
        out.println(ind + "/**");
        out.println(ind + " * @apilevel internal");
        out.println(ind + " */");
        out.println(ind + "public " + config().typeDefaultContributorSet() + " " + attr.signature() + "_contributors();");
      }
    }
  }

  syn TypeDecl AttrDecl.root() = grammar().root();
  eq CollDecl.root() = root != null ? grammar().lookup(root) : super.root();

  syn String AttrDecl.collDebugString() {
    if (!config().debugMode()) {
      return "";
    } else {
      return "if (node == null) throw new RuntimeException(\"Trying to evaluate collection attribute in subtree not attached to main tree\");";
    }
  }

  // only used by circular collection attributes
  public void AttrDecl.emitCircularCollectionEval(PrintStream out) {
    TemplateContext tt = templateContext();
    tt.bind("BottomValue", Unparser.unparse(getBottomValue()));
    tt.bind("RootType", root().name());
    tt.bind("SeparateEvaluation", separateEvaluation());
    tt.bind("Cond1", differs("new_" + signature() + "_value", signature() + "_value"));
    tt.bind("Cond2", differs("new_" + signature() + "_value", fromReferenceType(signature() + "_values.get(_parameters)", getType())));

    String rhs;
    if (separateEvaluation()) {
      rhs = Unparser.unparse(getBottomValue()) + ";\n" + "root." + name() + "_" +
        signature() + "_nextIteration(this)";
    } else {
      rhs = signature() + "_value = combine_" +
        signature()+"_contributions("+Unparser.unparse(getBottomValue())+")";
    }
    tt.bind("CircularComputeRHS", rhs);
    tt.bind("CircularComputeStmt", ""+getType() + " new_" + signature() + "_value = " + rhs + ";");

    tt.expand("AttrDecl.circularCollectionEval", out);
  }

  public String CollDecl.cacheCycleCheck() {
    if (separateEvaluation()) {
      return templateContext().expand("CollDecl.cacheCycleCheck");
    } else {
      return super.cacheCycleCheck();
    }
  }

  // only used by non-circular collection attributes
  public void CollDecl.emitComputeMethod(PrintStream out) {
    String rootType = root().name();
    TemplateContext tt = templateContext();
    tt.bind("RootType", rootType);
    tt.bind("BottomValue", Unparser.unparse(getBottomValue()));
    if (separateEvaluation()) {
      tt.expand("CollDecl.computeMethod:separateEvaluation", out);
    } else if (onePhase()) {
      tt.expand("CollDecl.computeMethod:onePhase", out);
    } else {
      tt.expand("CollDecl.computeMethod", out);
    }
  }
  // only used by circular collection attributes
  public void CollDecl.emitCombineMethod(PrintStream out) {
    if (!separateEvaluation()) {
      templateContext().expand("CollDecl.combineMethod", out);
    }
  }

  syn boolean TypeDecl.hasCollEq(CollDecl decl) = false;
  eq ASTDecl.hasCollEq(CollDecl decl) {
    for (int i = 0; i < getNumCollEq(); i++) {
      if (getCollEq(i).decl() == decl) {
        return true;
      }
    }
    return false;
  }

  syn lazy String CollEq.contributionSignature() = ((CollDecl)decl()).getTarget() + "_" + signature();

  syn boolean AttrDecl.separateEvaluation() = hasAnnotation("@SeparateEvaluation") || naive();
  syn boolean AttrEq.separateEvaluation() = decl().separateEvaluation();
  syn boolean AttrDecl.lazyCondition() = hasAnnotation("@LazyCondition");
  syn boolean AttrEq.lazyCondition() = decl().lazyCondition();

  syn boolean AttrDecl.onePhase() = hasAnnotation("@OnePhase") /*|| naive()*/;
  syn boolean AttrEq.onePhase() = decl().onePhase();

  syn boolean AttrDecl.naive() = hasAnnotation("@Naive");
  syn boolean AttrEq.naive() = decl().naive();

  public void ASTDecl.emitCollContributions(PrintStream out) {
    // find all coll eq in this node and group them according to either the coll decl or group name
    collectContributors(out);
    contributeTo(out);
    // and similar code for separate evaluation
    nextIteration(out);
  }

  syn boolean Contribution.hasCondition() =
    getCondition() != null && !getCondition().trim().isEmpty();


  private void ASTDecl.collectContributors(PrintStream out) {
    HashMap<CollDecl,ArrayList<CollEq>> map = new LinkedHashMap<CollDecl,ArrayList<CollEq>>();
    for (int i = 0; i < getNumCollEq(); i++) {
      CollEq attr = getCollEq(i);
      if (!attr.separateEvaluation()) {
        CollDecl decl = (CollDecl) attr.decl();
        ArrayList<CollEq> equations = map.get(decl);
        if (equations == null) {
          equations = new ArrayList<CollEq>();
          map.put(decl, equations);
        }
        equations.add(attr);
      }
    }

    for (Map.Entry<CollDecl,ArrayList<CollEq>> entry: map.entrySet()) {
      CollDecl decl = entry.getKey();
      ArrayList<CollEq> equations = entry.getValue();

      CollEq firstEq = equations.get(0);

      out.println(config().indent + "protected void collect_contributors_" + decl.collectingSignature() + "() {"); // once per group

      if (isRootNode()) {
        out.println(config().ind(2) + "if (collect_contributors_" + decl.collectingSignature() + ") return;");
      }

      String bottomValue = Unparser.unparse(decl.getBottomValue());

      for (CollEq attr: equations) {
        TemplateContext tt = attr.templateContext();
        tt.bind("BottomValue", bottomValue);
        tt.bind("CombOp", decl.getCombOp());

        out.println(attr.docComment());
        for (int j = 0; j < attr.getNumContribution(); j++) {
          Contribution c = attr.getContribution(j);
          tt.bind("Condition", c.getCondition().trim());
          if (decl.onePhase() || decl.separateEvaluation()) {
            tt.bind("HasCondition", c.hasCondition());
            tt.bind("Value", c.getValue().trim());
            tt.expand("ASTDecl.collectContributors:alt1", out);
          } else {
            tt.bind("HasCondition", c.hasCondition() && !decl.lazyCondition());
            tt.expand("ASTDecl.collectContributors:alt2", out);
          }
        }
      }
      if (isASTNodeDecl()) {
        out.println(config().ind(2) + "for (int i = 0; i < getNumChild(); i++)");
        out.println(config().ind(3) + "getChild(i).collect_contributors_" + decl.collectingSignature() + "();"); // once per group
      } else {
        out.println(config().ind(2) + "super.collect_contributors_" + decl.collectingSignature() + "();");
        if (isRootNode()) {
          out.println(config().ind(2) + "collect_contributors_" + decl.collectingSignature() + " = true;");
        }
      }
      out.println(config().indent + "}");
    }
  }

  private void ASTDecl.contributeTo(PrintStream out) {
    HashMap<CollDecl,ArrayList<CollEq>> map = new LinkedHashMap<CollDecl,ArrayList<CollEq>>();
    for (int i = 0; i < getNumCollEq(); i++) {
      CollEq attr = getCollEq(i);
      if (!attr.separateEvaluation() && !attr.onePhase()) {
        CollDecl decl = (CollDecl) attr.decl();
        ArrayList<CollEq> equations = map.get(decl);
        if (equations == null) {
          equations = new ArrayList<CollEq>();
          map.put(decl, equations);
        }
        equations.add(attr);
      }
    }

    for (Map.Entry<CollDecl,ArrayList<CollEq>> entry: map.entrySet()) {
      CollDecl decl = entry.getKey();
      ArrayList<CollEq> equations = entry.getValue();

      out.println(config().indent + "protected void contributeTo_" + decl.getTarget() + "_" + decl.signature() + "(" + decl.getType() + " collection) {");
      out.println(config().ind(2) + "super.contributeTo_" + decl.getTarget() + "_" + decl.signature() + "(collection);");
      for (CollEq attr: equations) {
        for (int j = 0; j < attr.getNumContribution(); j++) {
          Contribution c = attr.getContribution(j);
          if (c.hasCondition() /* && attr.getNumContribution() > 1*/) {
            out.println(config().ind(2) + "if (" + c.getCondition().trim() + ")");
            out.println(config().ind(3) + "collection." + decl.getCombOp() + "(" + c.getValue().trim() + ");");
          } else {
            out.println(config().ind(2) + "collection." + decl.getCombOp() + "(" + c.getValue().trim() + ");");
          }
        }
      }
      out.println(config().indent + "}\n");
    }
  }

  private void ASTDecl.nextIteration(PrintStream out) {
    HashMap<CollDecl,ArrayList<CollEq>> map = new LinkedHashMap<CollDecl,ArrayList<CollEq>>();
    for (int i = 0; i < getNumCollEq(); i++) {
      CollEq attr = getCollEq(i);
      if (attr.separateEvaluation()) {
        CollDecl decl = (CollDecl) attr.decl();
        ArrayList<CollEq> equations = map.get(decl);
        if (equations == null) {
          equations = new ArrayList<CollEq>();
          map.put(decl, equations);
        }
        equations.add(attr);
      }
    }

    for (Map.Entry<CollDecl,ArrayList<CollEq>> entry : map.entrySet()) {
      CollDecl decl = entry.getKey();
      ArrayList<CollEq> equations = entry.getValue();

      CollEq firstEq = equations.get(0);

      String valueAccess;
      if (decl != null && !decl.isCircular()) {
        valueAccess = "n.";
      } else {
        valueAccess = "n.new_";
      }

      out.println(config().indent + "protected void " + decl.getTarget() + "_" + firstEq.signature() + "_nextIteration(" + decl.getTarget() + " n) {");
      for (CollEq attr: equations) {
        TemplateContext tt = attr.templateContext();
        tt.bind("CombOp", decl.getCombOp());
        tt.bind("ValueAccess", valueAccess);

        out.println(attr.docComment());
        for (int j = 0; j < attr.getNumContribution(); j++) {
          Contribution c = attr.getContribution(j);
          tt.bind("Value", c.getValue().trim());
          tt.bind("HasCondition", c.hasCondition());
          tt.bind("Condition", c.getCondition().trim());
          tt.expand("ASTDecl.nextIteration", out);
        }
      }
      if (isASTNodeDecl()) {
        out.println(config().ind(2) + "for (int i = 0; i < getNumChild(); i++)");
        out.println(config().ind(3) + "getChild(i)." + decl.getTarget() + "_" + firstEq.signature() + "_next_Iteration(n);"); // once per group
      } else {
        out.println(config().ind(3) + "r." + decl.getTarget() + "_" + firstEq.signature() + "_nextIteration(n);");
      }
      out.println(config().indent + "}");
    }
  }


  syn String CollEq.collectingSignature() = decl().collectingSignature();
  syn lazy String AttrDecl.collectingSignature() = signature();
  eq CollDecl.collectingSignature() {
    String value = getAnnotationValue("@CollectionGroup");
    if (value != null)
      return "CollectionGroup_" + value;
    return signature();
  }

  syn String CollEq.signature() = decl().signature();
  syn lazy String CollDecl.signature() {
    StringBuffer s = new StringBuffer();
    s.append(getTarget());
    s.append("_");
    s.append(name());
    for (int i = 0; i < getNumParameter(); i++) {
      s.append("_" + getParameter(i).getType());
    }
    return s.toString();
  }

  syn ArrayList<ASTDecl> Grammar.roots() {
    ArrayList<ASTDecl> l = new ArrayList<ASTDecl>();
    for (int i = 0; i < getNumTypeDecl(); i++) {
      if (getTypeDecl(i) instanceof ASTDecl) {
        ASTDecl decl = (ASTDecl)getTypeDecl(i);
        if (decl.isRootNode()) {
          l.add(decl);
        }
      }
    }
    return l;
  }

  syn ASTDecl Grammar.root() =
    roots().isEmpty() ? null : (ASTDecl) roots().iterator().next();

  eq ASTDecl.getCollDecl().hostClass() = this;
  eq ASTDecl.getCollEq().hostClass() = this;

  public void Grammar.weaveCollectionAttributes() {
    for (int i = 0; i < getNumTypeDecl(); i++)
      getTypeDecl(i).weaveCollectionAttributes();
  }
  public void TypeDecl.weaveCollectionAttributes() { }

  private HashSet TypeDecl.processedCollectingSignatures = null;
  protected boolean TypeDecl.processedCollectingSignature(String signature) {
    if (processedCollectingSignatures == null)
      processedCollectingSignatures = new LinkedHashSet();
    if (processedCollectingSignatures.contains(signature))
      return true;
    processedCollectingSignatures.add(signature);
    return false;
  }

  protected String TypeDecl.collectionReset() {
    StringBuffer res = new StringBuffer();
    for (int k = 0; k < grammar().getNumTypeDecl(); k++) {
      TypeDecl typeDecl = grammar().getTypeDecl(k);
      for (CollDecl decl: typeDecl.interfaceCollDecls()) {
        TemplateContext tt = decl.templateContext();
        if (decl.root() == this && !decl.separateEvaluation()) {
          if (decl.circularCollection()) {
            res.append(tt.expand("ASTDecl.weaveCollectionAttributes.flush1"));
          } else {
            res.append(tt.expand("ASTDecl.weaveCollectionAttributes.flush2"));
          }
        }
      }
      for (int i = 0; i < typeDecl.getNumCollDecl(); i++) {
        CollDecl attr = typeDecl.getCollDecl(i);
        TemplateContext tt = attr.templateContext();
        if (attr.root() == this && !attr.separateEvaluation()) {
          if (attr.circularCollection()) {
            res.append(tt.expand("ASTDecl.weaveCollectionAttributes.flush1"));
          } else {
            res.append(tt.expand("ASTDecl.weaveCollectionAttributes.flush2"));
          }
        }
      }
    }
    return res.toString();
  }

  public void ASTDecl.weaveCollectionAttributes() {
    for (CollDecl decl: interfaceCollDecls()) {
      weaveCollectionAttribute(decl);
    }
    for (CollDecl decl: getCollDeclList()) {
      weaveCollectionAttribute(decl);
    }
  }

  public void ASTDecl.weaveCollectionAttribute(CollDecl attr) {
    TemplateContext tt = attr.templateContext();

    boolean separateEvaluation = attr.separateEvaluation();
    TypeDecl astDecl = grammar().lookup(config().astNodeType());
    TypeDecl rootDecl = attr.root();
    if (astDecl != null && rootDecl != null) {
      boolean process = !astDecl.processedCollectingSignature(attr.collectingSignature());
      if (!astDecl.hasCollEq(attr) && process) {
        String s = "";
        if (separateEvaluation) {
          s = tt.expand("ASTDecl.weaveCollectionAttributes.nextIteration");
        }

        if (process && !separateEvaluation/*&& attr.isCircular() && !separateEvaluation*/) {
          s += tt.expand("ASTDecl.weaveCollectionAttributes.collectContributors1");
        }

        if (!separateEvaluation && (attr.isCircular() || !attr.onePhase())) {
          s += tt.expand("ASTDecl.weaveCollectionAttributes.contributeTo");
        }

        astDecl.classBodyDecls.add(buildClassBodyObject(s, attr.getFileName(), attr.getStartLine()));
      }
      if (process) {
        String s = "";
        if (attr.circularCollection() && !separateEvaluation) {
          s = tt.expand("ASTDecl.weaveCollectionAttributes.collectContributors2");
        } else if (!attr.circularCollection() && !attr.separateEvaluation()) {
          if (!rootDecl.hasCollEq(attr)) {
            s = tt.expand("ASTDecl.weaveCollectionAttributes.collectContributors3");
          } else {
            s = tt.expand("ASTDecl.weaveCollectionAttributes.collectContributors4");
          }
        }
        rootDecl.classBodyDecls.add(buildClassBodyObject(s, attr.getFileName(), attr.getStartLine()));
      }
    }
  }

  private ClassBodyObject ASTDecl.buildClassBodyObject(String data,
      String fileName, int line) {
    org.jastadd.jrag.AST.SimpleNode n = new org.jastadd.jrag.AST.ASTBlock(0);
    n.firstToken = n.lastToken = org.jastadd.jrag.AST.Token.newToken(0);
    n.firstToken.image = data;
    return new ClassBodyObject(n, fileName, line, "<NoAspect>");
  }



  // name binding
  eq CollEq.decl() {
    TypeDecl typeDecl = grammar().lookup(getTargetName());
    if (typeDecl != null /*&& typeDecl instanceof ASTDecl*/) {
      TypeDecl astDecl = (TypeDecl)typeDecl;
      for (int i = 0; i < astDecl.getNumCollDecl(); i++)
        if (astDecl.getCollDecl(i).getName().equals(getTargetAttributeName()))
          return astDecl.getCollDecl(i);
    }
    return null;
  }

  coll HashSet CollDecl.uses() [new LinkedHashSet()] with add;
  CollEq contributes this when decl() != null to CollDecl.uses() for decl();

  // build AST from parser
  // EMMA_2009-11-27: Adding enclosing aspect as parameter
  public void Grammar.addCollDecl(String name, String type, String className,
      String fileName, int startLine, int endLine, ASTExpression startValue,
      String combOp, boolean isCircular, ArrayList<String> annotations,
      org.jastadd.jrag.AST.SimpleNode node, String root, String aspectName) {
    TypeDecl c = lookup(className);
    if (c != null/* && c instanceof ASTDecl*/) {
      CollDecl decl = new CollDecl();
      decl.setName(name);
      decl.setType(type);
      decl.setLazy(true);
      decl.setFileName(fileName);
      decl.setStartLine(startLine);
      decl.setEndLine(endLine);
      decl.setParameterList(new List());
      decl.setStartValue(startValue);
      decl.setCombOp(combOp);
      for (String annotation: annotations) {
        decl.addAnnotation(new Annotation(annotation));
      }
      decl.setCircularCollection(isCircular || annotations.contains("@Circular"));
      decl.setComment(Unparser.unparseComment(node));
      decl.setTarget(className);
      decl.root = root;
      decl.setAspectName(aspectName);
      ((TypeDecl)c).addCollDecl(decl);
    } else {
      error("Can not add collection attribute " + type + " " + name + " to unknown class " + className + " in " + fileName + " at line " + startLine);
    }
  }

  public String CollDecl.root = null;

  syn boolean AttrDecl.hasAnnotation(String name) {
    for (int i = 0; i < getNumAnnotation(); ++i) {
      if (getAnnotation(i).isAnnotation(name)) {
        return true;
      }
    }
    return false;
  }

  syn String AttrDecl.getAnnotationValue(String name) {
    for (int i = 0; i < getNumAnnotation(); ++i) {
      if (getAnnotation(i).isAnnotation(name)) {
        return getAnnotation(i).value();
      }
    }
    // TODO: don't return null!!
    return null;
  }

  public void Grammar.addCollEq(String targetName, String targetAttributeName,
      String attributeType, String reference,
      org.jastadd.ast.AST.List contributionList, String fileName,
      int startLine, int endLine, boolean refSet,
      org.jastadd.jrag.AST.SimpleNode node, String aspectName,
      ArrayList<String> annotations) {
    TypeDecl c = lookup(attributeType);
    if (c != null && c instanceof ASTDecl) {
      CollEq equ = new CollEq(
          new List(),
          new List(),
          targetName,
          fileName,
          startLine,
          endLine,
          Unparser.unparseComment(node),
          aspectName,
          contributionList,
          targetName,
          targetAttributeName,
          refSet,
          reference);
      for (String annotation: annotations) {
        equ.addAnnotation(new Annotation(annotation));
      }
      ((ASTDecl)c).addCollEq(equ);
    } else {
      error("Can not add collection contribution to unknown class " + attributeType + " in " + fileName + " at line " + startLine);
    }
  }

  private ASTExpression CollDecl.startValue;
  public void CollDecl.setStartValue(ASTExpression e) { startValue = e; }
  public ASTExpression CollDecl.getBottomValue() { return startValue; }
  private String CollDecl.combOp;
  public void CollDecl.setCombOp(String s) { combOp = s; }
  public String CollDecl.getCombOp() { return combOp; }
  private boolean CollDecl.circularCollection;
  public void CollDecl.setCircularCollection(boolean b) { circularCollection = b; }
  public boolean CollDecl.circularCollection() { return circularCollection; }
  public boolean CollDecl.isCircular() { return circularCollection(); }

  private static boolean CollDecl.isValidIdentifierPart(String s) {
    for (int i = 0; i < s.length(); i++) {
      if (!Character.isJavaIdentifierPart(s.charAt(i))) {
        return false;
      }
    }
    return true;
  }

}
