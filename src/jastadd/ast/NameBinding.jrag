/* Copyright (c) 2005-2013, The JastAdd Team
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Lund University nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
import ast.AST.*;
import java.util.*;

aspect AttributeHostClass {
  eq TypeDecl.getChild().hostClass() = this;
  inh TypeDecl AttrDecl.hostClass();
  inh TypeDecl AttrEq.hostClass();
}

aspect AttributeNamesAndTypes {
  syn String AttrDecl.name() = getName();
  syn String AttrDecl.type() = getType();

  syn String AttrDecl.getTypeInSignature() = convTypeNameToSignature(type());
  syn String Parameter.getTypeInSignature() = convTypeNameToSignature(getType());
  public static String ASTNode.convTypeNameToSignature(String s) {
    s = s.replace('.', '_');
    s = s.replace(' ', '_');
    s = s.replace(',', '_');
    s = s.replace('<', '_');
    s = s.replace('>', '_');
    s = s.replace('[', '_');
    s = s.replace(']', 'a');
    return s;
  }
  syn String AttrEq.getTypeInSignature() {
    if(decl() != null) return decl().getTypeInSignature();
    throw new Error(getFileName() + ":" + getStartLine() + " could not find decl for AttrEq " + signature() + " in " + hostClass().name());
  }

  syn String AttrEq.name() = getName();
  syn String AttrEq.type() {
    if(decl() != null) return decl().type();
    throw new Error(getFileName() + ":" + getStartLine() + " could not find decl for AttrEq " + signature() + " in " + hostClass().name());
  }

  syn String AttrDecl.signature() {
    if(getNumParameter() == 0)
      return getName();
    StringBuffer s = new StringBuffer();
    s.append(getName());
    for(int i = 0; i < getNumParameter(); i++) {
      s.append("_" + getParameter(i).getTypeInSignature());
    }
    return s.toString();
  }
  syn String AttrEq.signature() {
    if(getNumParameter() == 0)
      return getName();
    StringBuffer s = new StringBuffer();
    s.append(getName());
    for(int i = 0; i < getNumParameter(); i++) {
      s.append("_" + getParameter(i).getTypeInSignature());
    }
    return s.toString();
  }
}

aspect AllEquations {
  syn lazy Set TypeDecl.synEquations() {
    Set set = new LinkedHashSet();
    for(int i = 0; i < getNumSynEq(); i++) {
      set.add(getSynEq(i));
    }
    return set;
  }
  eq ASTDecl.synEquations() {
    Set set = super.synEquations();
    if(superClass() != null)
      set.addAll(superClass().synEquations());
    return set;
  }
  syn lazy Set TypeDecl.synDeclarations() {
    Set set = new LinkedHashSet();
    for(int i = 0; i < getNumSynDecl(); i++) {
      set.add(getSynDecl(i));
    }
    return set;
  }
  eq ASTDecl.synDeclarations() {
    Set set = super.synDeclarations();
    if(superClass() != null)
      set.addAll(superClass().synDeclarations());
    return set;
  }
  syn lazy Set TypeDecl.inhEquations() {
    Set set = new LinkedHashSet();
    for(int i = 0; i < getNumInhEq(); i++) {
      set.add(getInhEq(i));
    }
    return set;
  }
  eq ASTDecl.inhEquations() {
    Set set = super.inhEquations();
    if(superClass() != null)
      set.addAll(superClass().inhEquations());
    return set;
  }
  syn lazy Set TypeDecl.inhDeclarations() {
    Set set = new LinkedHashSet();
    for(int i = 0; i < getNumInhDecl(); i++) {
      set.add(getInhDecl(i));
    }
    return set;
  }
  eq ASTDecl.inhDeclarations() {
    Set set = super.inhDeclarations();
    if(superClass() != null)
      set.addAll(superClass().inhDeclarations());
    return set;
  }
}

aspect BindSynEquations {
  syn lazy SynDecl TypeDecl.lookupSynDecl(String signature) {
    for(int i = 0; i < getNumSynDecl(); i++)
      if(getSynDecl(i).signature().equals(signature))
        return getSynDecl(i);
    return null;
  }
  eq ASTDecl.lookupSynDecl(String signature) {
    SynDecl decl = super.lookupSynDecl(signature);
    if(decl != null || superClass() == null)
      return decl;
    return superClass().lookupSynDecl(signature);
  }

  syn lazy SynEq TypeDecl.lookupSynEq(String signature) {
    for(int i = 0; i < getNumSynEq(); i++)
      if(getSynEq(i).signature().equals(signature))
        return getSynEq(i);
    return null;
  }
  eq ASTDecl.lookupSynEq(String signature) {
    SynEq equations = super.lookupSynEq(signature);
    if(equations != null || superClass() == null)
      return equations;
    return superClass().lookupSynEq(signature);
  }
  
  syn lazy InhDecl TypeDecl.lookupInhDecl(String signature) {
    for(int i = 0; i < getNumInhDecl(); i++)
      if(getInhDecl(i).signature().equals(signature))
        return getInhDecl(i);
    return null;
  }
  eq ASTDecl.lookupInhDecl(String signature) {
    InhDecl decl = super.lookupInhDecl(signature);
    if(decl != null || superClass() == null)
      return decl;
    return superClass().lookupInhDecl(signature);
  }
  
  syn lazy InhDecl TypeDecl.lookupInhDeclSubclasses(String signature) =
    lookupInhDecl(signature);
  eq ASTDecl.lookupInhDeclSubclasses(String signature) {
    InhDecl decl = lookupInhDecl(signature);
    if(decl != null) return decl;
    for(Iterator iter = subclasses().iterator(); iter.hasNext(); ) {
      ASTDecl subclass = (ASTDecl)iter.next();
      decl = subclass.lookupInhDeclSubclasses(signature);
      if(decl != null) return decl;
    }
    return null;
  }

  syn lazy InhEq TypeDecl.lookupInhEq(String signature, String childName) {
    for(int i = 0; i < getNumInhEq(); i++)
      if(getInhEq(i).signature().equals(signature) && getInhEq(i).sonName().equals(childName))
        return getInhEq(i);
    for(int i = 0; i < getNumInhEq(); i++)
      if(getInhEq(i).signature().equals(signature) && getInhEq(i).sonName().equals("Child"))
        return getInhEq(i);
    return null;
  }
  eq ASTDecl.lookupInhEq(String signature, String childName) {
    InhEq equation = super.lookupInhEq(signature, childName);
    if(equation != null || superClass() == null)
      return equation;
    return superClass().lookupInhEq(signature, childName);
  }
  
}

aspect LookupDecls {
  syn lazy AttrDecl AttrEq.decl();
  eq InhEq.decl() = hostClass().getInhDeclFor(signature(), new LinkedHashSet());
  //eq InhEq.decl() = hostClass().getInhDeclFor(signature());
  eq SynEq.decl() = hostClass().lookupSynDecl(signature());
  


  syn InhDecl TypeDecl.getInhDeclFor(String signature, Collection visited) {
    visited.add(this);
    InhDecl inhDecl = lookupInhDecl(signature);
    if(inhDecl != null) {
      return inhDecl;
    }
    for(Iterator children = getComponents(); children.hasNext(); ) {
      Components c = (Components)children.next();
      if(!(c instanceof TokenComponent)) {
        TypeDecl decl = (ASTDecl)env().lookup(c.type());
        if(decl != null && !visited.contains(decl)) {
          InhDecl d = decl.getInhDeclFor(signature, visited);
          if(d != null) return d;
        }
      }
    }
    return null;
  }

  eq ASTDecl.getInhDeclFor(String signature, Collection visited) {
    visited.add(this);
    InhDecl inhDecl = lookupInhDecl(signature);
    if(inhDecl != null) {
      return inhDecl;
    }
    for(Iterator children = getComponents(); children.hasNext(); ) {
      Components c = (Components)children.next();
      if(!(c instanceof TokenComponent)) {
        TypeDecl decl = (ASTDecl)env().lookup(c.type());
        if(decl != null && !visited.contains(decl)) {
          InhDecl d = decl.getInhDeclFor(signature, visited);
          if(d != null) return d;
        }
      }
    }

  /*
     for(Iterator iter = synDeclarations().iterator(); iter.hasNext(); ) {
      SynDecl synDecl = (SynDecl)iter.next();
      if(synDecl.declaredNTA()) {
        ASTDecl decl = (ASTDecl)env().lookup(synDecl.type());
        if(decl != null && !visited.contains(decl)) {
          InhDecl d = decl.getInhDeclFor(signature, visited);
          if(d != null) return d;
        }
      }
    }*/
    
    for(Iterator iter = subclasses().iterator(); iter.hasNext(); ) {
      ASTDecl subclass = (ASTDecl)iter.next();
      if(!visited.contains(subclass)) {
        InhDecl d = subclass.getInhDeclFor(signature, visited);
        if(d != null) return d;
      }
    }
    return null;
  }
}

aspect ASTDecl {
  syn lazy HashMap TypeDecl.inhEqMap() {
    HashMap map = new LinkedHashMap();
    for(int i = 0; i < getNumInhEq(); i++) {
      InhEq equ = getInhEq(i);
      String id = equ.type() + "_" + equ.attributeSignature();
      LinkedList list = (LinkedList)map.get(id);
      if(list == null) {
        list = new LinkedList();
        map.put(id, list);
      }
      if(equ.getSonName().equals("getChild")) {
        list.add(equ); // insert last
      }
      else if(equ.getComponents() != null && equ.getComponents().isNTA()) {
        list.add(0, equ); // insert first
      }
      else {
        list.add(0, equ); // insert first
      }
    }
    return map;
  }

  public Iterator TypeDecl.inhAttrSet() {
    return inhEqMap().keySet().iterator();
  }

  public Iterator TypeDecl.inhAttrEqs(String id) {
    LinkedList list = (LinkedList)inhEqMap().get(id);
    return list != null ? list.iterator() : null;
  }
}
