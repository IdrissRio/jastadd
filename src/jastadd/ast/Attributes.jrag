/* Copyright (c) 2005-2013, The JastAdd Team
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Lund University nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
package jrag;

import org.jastadd.ast.AST.*;

import java.util.*;

import org.jastadd.jrag.AST.ASTExpression;

import org.jastadd.jrag.Unparser;

import org.jastadd.Problem;

public aspect Attributes {

  public Collection<Problem> Grammar.problems = new LinkedList<Problem>();

  public void Grammar.error(String msg, String file, int line) {
    problems.add(new Problem.Error(msg, file, line));
  }

  public void Grammar.error(String msg) {
    problems.add(new Problem.Error(msg));
  }

  public Collection<Problem> Grammar.weavingProblems() {
    return problems;
  }

  public void ASTNode.refineError(String what, String file, int line) {
    grammar().error("can not find " + what + " to refine\n" +
        "Warning: implicitly generated methods and equations must be refined without an explicit aspect name",
        file, line);
  }

  public HashMap Grammar.aspectMap = new HashMap();

  public void Grammar.registerAspect(String name, String comment) {
    aspectMap.put(name, comment);
  }

  // Add attributes to AST
  public void Grammar.addRewriteList(
      String className,
      org.jastadd.jrag.AST.SimpleNode condition,
      org.jastadd.jrag.AST.SimpleNode result,
      String type,
      String fileName,
      int startLine,
      int endLine,
      String parentName,
      String childName,
      String aspectName) {

    TypeDecl c = lookup(className);
    if(c != null && c instanceof ASTDecl) {
      RewriteList r = new RewriteList();
      r.setFileName(fileName);
      r.setStartLine(startLine);
      r.setEndLine(endLine);
      r.setCondition(condition);
      r.setResult(result);
      r.setReturnType(type);
      r.setParentName(parentName);
      r.setChildName(childName);
      r.setAspectName(aspectName);
      ((ASTDecl)c).addRewrite(r);
    } else if(c != null) {
      error("can not rewrite to non AST class '" + className + "'", fileName, startLine);
    } else {
      error("can not rewrite to unknown class '" + className + "'", fileName, startLine);
    }
  }


  public void Grammar.addRewrite(
      String className,
      org.jastadd.jrag.AST.SimpleNode condition,
      org.jastadd.jrag.AST.SimpleNode result,
      String type,
      String fileName,
      int startLine,
      int endLine,
      String aspectName) {

    TypeDecl c = lookup(className);
    if(c != null && c instanceof ASTDecl) {
      Rewrite r = new Rewrite();
      r.setFileName(fileName);
      r.setStartLine(startLine);
      r.setEndLine(endLine);
      r.setCondition(condition);
      r.setResult(result);
      r.setReturnType(type);
      r.setAspectName(aspectName);
      ((ASTDecl)c).addRewrite(r);
    } else if(c != null) {
      error("can not rewrite to non AST class '" + className + "'", fileName, startLine);
    } else {
      error("can not rewrite to unknown class '" + className + "'", fileName, startLine);
    }
  }

  /**
   * Configures the caching behavior for an attribute.
   * 
   * @param cacheConfig The cache configuration, should be "cache" or "uncache"
   * @param hostName The node type hosting the attribute
   * @param attrName The attribute name
   * @param paramList The list of attribute parameters
   * @param fileName The name of the file with the attribute declaration
   * @param startLine The line of the attribute declaration
   */
  public void Grammar.setAttrDeclLazy(String cacheConfig, String hostName, String attrName, 
      org.jastadd.ast.AST.List paramList, String fileName, int startLine) {
    // Lookup type
    TypeDecl type = lookup(hostName);
    if (type == null) {
      error("can not find attribute " + attrName + " in unknown class " + hostName, fileName, startLine);
      return;
    }
    // Build signature for lookup of inherited attribute
    StringBuilder signBuf = new StringBuilder();
    signBuf.append(attrName);
    for (int i = 0; i < paramList.getNumChild(); i++) {
      signBuf.append("_" + ((Parameter)paramList.getChild(i)).getTypeInSignature());
    }
    // Lookup attribute; first 'syn' then 'inh'
    AttrDecl attr = null; 
    String signature = signBuf.toString();
    if ((attr = type.lookupSynDecl(signature)) == null && 
        (attr = type.lookupInhDecl(signature)) == null) {
      error("can not find attribute " + attrName + " in class " + hostName);
      return;
    }
    // Configure attribute caching
    if (cacheConfig.equals("cache")) {
      attr.setLazy(true);
    } else if (cacheConfig.equals("uncache")) { 
      attr.setLazy(false);
    } else {
      error("unknown configuration " + cacheConfig + " for attribute " + hostName + "." + attrName, fileName, startLine);
    }
  }

  public void Grammar.addSynDecl(
      String name,
      String type,
      String className,
      boolean isLazy,
      String fileName,
      int startLine,
      int endLine,
      org.jastadd.ast.AST.List parameterList,
      ASTExpression bottomValue,
      boolean isFinal,
      boolean isNTA,
      org.jastadd.jrag.AST.SimpleNode node,
      String aspectName,
      ArrayList<String> annotations) {
    TypeDecl c = lookup(className);
    if(c != null) {
      SynDecl decl = new SynDecl(
        parameterList,
        name,
        type,
        isLazy | isNTA,
        fileName,
        startLine,
        endLine,
        isFinal | isNTA,
        isNTA,
        Unparser.unparseComment(node),
        aspectName,
        new List()
      );
      for (String annotation: annotations) {
        decl.addAnnotation(new Annotation(annotation));
      }
      decl.setBottomValue(bottomValue);
      c.addSynDecl(decl);
    } else {
      error("can not add synthesized attribute " + type + " " + name + " to unknown class " + className,
          fileName, startLine);
    }
  }

  public void Grammar.addSynEq(
      String name,
      String className,
      org.jastadd.jrag.AST.SimpleNode rhs,
      String fileName,
      int startLine,
      int endLine,
      org.jastadd.ast.AST.List list,
      org.jastadd.jrag.AST.SimpleNode node,
      String aspectName,
      ArrayList<String> annotations) {
    TypeDecl c = lookup(className);
    if(c != null) {
      SynEq equ = new SynEq();
      equ.setName(name);
      equ.setFileName(fileName);
      equ.setStartLine(startLine);
      equ.setEndLine(endLine);
      equ.setRHS(rhs);
      equ.setParameterList(list);
      equ.setComment(Unparser.unparseComment(node));
      equ.setAspectName(aspectName);
      for (String annotation: annotations) {
        equ.addAnnotation(new Annotation(annotation));
      }
      c.addSynEq(equ);
    } else {
      error("can not add equation for synthesized attribute " + name + " to unknown class " + className, fileName, startLine);
    }
  }

  public void Grammar.addInhDecl(String name, String type, String className,
      boolean isLazy, String fileName, int startLine, int endLine,
      org.jastadd.ast.AST.List parameterList, ASTExpression bottomValue,
      boolean isFinal, boolean isNTA, org.jastadd.jrag.AST.SimpleNode node,
      String aspectName, ArrayList<String> annotations) {
    TypeDecl c = lookup(className);
    if(c != null) {
      InhDecl decl = new InhDecl(
        parameterList,
        name,
        type,
        isLazy | isNTA,
        fileName,
        startLine,
        endLine,
        isFinal | isNTA,
        isNTA,
        Unparser.unparseComment(node),
        aspectName,
        new List()
      );
      for (String annotation: annotations) {
        decl.addAnnotation(new Annotation(annotation));
      }
      decl.setBottomValue(bottomValue);
      c.addInhDecl(decl);
    } else {
      error("can not add inherited attribute " + type + " " + name + " to unknown class " + className,
          fileName, startLine);
    }
  }

  public void Grammar.addInhEq(String childName, String name, String className,
      org.jastadd.jrag.AST.SimpleNode rhs, String fileName, int startLine,
      int endLine, org.jastadd.ast.AST.List list,
      org.jastadd.jrag.AST.SimpleNode node, String aspectName,
      ArrayList<String> annotations) {
    addInhEq(childName, name, className, rhs, fileName, startLine, endLine,
        list, null, node, aspectName, annotations);
  }

  public void Grammar.addInhEq(String childName, String name, String className,
      org.jastadd.jrag.AST.SimpleNode rhs, String fileName, int startLine,
      int endLine, org.jastadd.ast.AST.List list, Parameter p,
      org.jastadd.jrag.AST.SimpleNode node, String aspectName,
      ArrayList<String> annotations) {
    TypeDecl c = lookup(className);
    if(c != null) {
        InhEq equ = new InhEq();
        equ.setName(name);
        equ.setFileName(fileName);
        equ.setStartLine(startLine);
        equ.setEndLine(endLine);
        equ.setRHS(rhs);
        equ.setChildName(childName);
        equ.setParameterList(list);
        equ.setComment(Unparser.unparseComment(node));
        equ.setAspectName(aspectName);
        for (String annotation: annotations) {
          equ.addAnnotation(new Annotation(annotation));
        }
        if(p != null) equ.setIndex(p);
        c.addInhEq(equ); // Sortera i bokstavsordning därefter non NTA först
    } else {
      error("can not add equation for inherited attribute " + name + " to unknown class " + className,
          fileName, startLine);
    }
  }

  public void Grammar.addComponents(String className, org.jastadd.ast.AST.List componentsList) {
    TypeDecl d = lookup(className);
    if(d != null) {
      d.setComponentsList(componentsList);
    }
  }

  syn lazy Components TypeDecl.components(String name) {
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(c.name().equals(name))
        return c;
    }
    return null;
  }

  public void Grammar.addCompUnit(org.jastadd.jrag.AST.ASTCompilationUnit compUnit) {
    compUnits.add(compUnit);
  }

  public Iterator Grammar.getCompUnits() {
    return compUnits.iterator();
  }

  public void Grammar.addClassBodyDecl(org.jastadd.jrag.AST.SimpleNode n, String className, String fileName, String aspectName) {
    TypeDecl c = lookup(className);
    if(c != null) {
      c.classBodyDecls.add(new ClassBodyObject(n, fileName, n.firstToken.beginLine, aspectName));
    } else {
      error("can not add member to unknown class " + className,
          fileName, n.firstToken.beginLine);
    }
  }

  public void Grammar.addMethodDecl(org.jastadd.jrag.AST.SimpleNode n, String className,
      String fileName, String modifiers, String aspectName) {
    TypeDecl c = lookup(className);
    if(c != null) {
      ClassBodyObject obj = new ClassBodyObject(n, fileName, n.firstToken.beginLine, aspectName);
      obj.modifiers = modifiers;
      c.classBodyDecls.add(obj);
    } else {
      error("can not add member to unknown class " + className, fileName, n.firstToken.beginLine);
    }
  }

  public void Grammar.addClassBodyDecl(org.jastadd.jrag.AST.SimpleNode n, String className,
      String fileName, String modifiers, String aspectName) {
    TypeDecl c = lookup(className);
    if(c != null) {
      ClassBodyObject obj = new ClassBodyObject(n, fileName,
          n.firstToken.beginLine, aspectName);
      obj.modifiers = modifiers;
      c.classBodyDecls.add(obj);
    } else {
      error("can not add member to unknown class " + className, fileName, n.firstToken.beginLine);
    }
    //else {
      //TypeDecl t = findTypeDecl(className);
      //t.classBodyDecls.add(new ClassBodyObject(n, fileName, n.firstToken.beginLine));
    //}
  }

  public void Grammar.addInterface(org.jastadd.jrag.AST.SimpleNode nameList, String className, String fileName) {
    if(nameList == null) {
      System.err.println("Panic");
    } else {

      TypeDecl c = lookup(className);
      if(c != null) {
        c.implementsList.add(nameList);
      } else {
        int line = nameList.firstToken.beginLine;
        error("can not add interface to unknown class " + className, fileName, line);
      }
    }
  }

  public void Grammar.extendInterface(org.jastadd.jrag.AST.SimpleNode nameList, String className, String fileName) {
    if(nameList == null) {
      System.err.println("Panic");
    } else {
      TypeDecl c = lookup(className);
      if(c instanceof InterfaceDecl) {
        c.implementsList.add(nameList);
      } else if(c != null) {
        int line = nameList.firstToken.beginLine;
        error(className + " is not an interface and can therefore not be extended", fileName, line);
      } else {
        int line = nameList.firstToken.beginLine;
        error("can not add interface to unknown interface " + className, fileName, line);
      }
    }
  }

  public Iterator TypeDecl.getClassBodyDeclsItr() {
    return classBodyDecls.iterator();
  }

  public Collection TypeDecl.classBodyDecls = new LinkedHashSet();


  public String AttrEq.aspectName() {
    return getAspectName();
  }
  public String AttrEq.legacyAspectName() {
    String name = getFileName();
     if(name.endsWith(".jrag"))
      name = name.substring(0, name.length() - 5);
    else if(name.endsWith(".jadd"))
      name = name.substring(0, name.length() - 5);
    else if(name.endsWith(".ast"))
      name = name.substring(0, name.length() - 4);
    String pattern = File.separator.equals("\\") ? pattern = "\\\\" : File.separator;
    String[] names = name.split(pattern);
    return names[names.length-1];
  }

  public void Grammar.processRefinements() {
    for(int i = 0; i < getNumTypeDecl(); i++) {
      TypeDecl typeDecl = getTypeDecl(i);
      if (!(typeDecl instanceof InterfaceDecl)) {
        typeDecl.processReplacements();
        typeDecl.processRefinedClassBodyDecls();
        typeDecl.processSynEqReplacements();
        typeDecl.processRefinedSynEqs();
        typeDecl.processRefinedInhEqs();
      }
    }
  }

  public void Grammar.processInterfaceRefinements() {
    for(int i = 0; i < getNumTypeDecl(); i++) {
      TypeDecl typeDecl = getTypeDecl(i);
      if (typeDecl instanceof InterfaceDecl) {
        typeDecl.processReplacements();
        typeDecl.processRefinedClassBodyDecls();
        typeDecl.processSynEqReplacements();
        typeDecl.processRefinedSynEqs();
        typeDecl.processRefinedInhEqs();
      }
    }
  }

  public LinkedList TypeDecl.refinedSynEqs = new LinkedList();
  public void Grammar.addRefinedSynEq(String name, String className, org.jastadd.jrag.AST.SimpleNode rhs, String fileName, int startLine, int endLine, org.jastadd.ast.AST.List list, String aspectName, org.jastadd.jrag.AST.SimpleNode node, String declaredAspect) {
    TypeDecl c = lookup(className);
    if(c != null) {
      SynEq equ = new SynEq();
      equ.setName(name);
      equ.setFileName(fileName);
      equ.setStartLine(startLine);
      equ.setEndLine(endLine);
      equ.setRHS(rhs);
      equ.setParameterList(list);
      equ.refinesAspect = aspectName;
      equ.setComment(Unparser.unparseComment(node));
      equ.setAspectName(declaredAspect);
      c.refinedSynEqs.add(equ);
    } else {
      error("can not add equation for synthesized attribute " + name + " to unknown class " + className,
          fileName, startLine);
    }
  }

  public void Grammar.addReplacedSynEq(String name, String className, org.jastadd.jrag.AST.SimpleNode rhs, String fileName, int startLine, int endLine, org.jastadd.ast.AST.List list, String aspectName, String secondAspectName, org.jastadd.jrag.AST.SimpleNode node, String declaredAspect) {
    TypeDecl c = lookup(className);
    if(c != null) {
      SynEq equ = new SynEq();
      equ.setName(name);
      equ.setFileName(fileName);
      equ.setStartLine(startLine);
      equ.setEndLine(endLine);
      equ.setRHS(rhs);
      equ.setParameterList(list);
      equ.refinesAspect = aspectName;
      equ.replacesAspect = secondAspectName;
      equ.setComment(Unparser.unparseComment(node));
      equ.setAspectName(declaredAspect);
      c.replacedSynEqs.add(equ);
    } else {
      error("can not add equation for synthesized attribute " + name + " to unknown class " + className,
          fileName, startLine);
    }
  }
  public String AttrEq.replacesAspect = null;
  public LinkedList TypeDecl.replacedSynEqs = new LinkedList();
  public void TypeDecl.processSynEqReplacements() {
    boolean change = true;
    ArrayList list = new ArrayList();
    while(change && !replacedSynEqs.isEmpty()) {
      change = false;
      for(Iterator iter = refinedSynEqs.iterator(); iter.hasNext(); ) {
        SynEq decl = (SynEq)iter.next();
        SynEq refinedDecl = null;
        for(Iterator outerIter = replacedSynEqs.iterator(); outerIter.hasNext(); ) {
          SynEq refinedCandidate = (SynEq)outerIter.next();
          boolean legacyCondition = grammar().refineLegacy ? decl.legacyAspectName().equals(refinedCandidate.replacesAspect) : false;
          if(decl.signature().equals(refinedCandidate.signature())
             && (decl.aspectName().equals(refinedCandidate.replacesAspect) || legacyCondition)) {
            change = true;
            if(refinedDecl == null) {
              refinedDecl = refinedCandidate;
            } else {
              grammar().error("refinement previously defined at " +
                  refinedCandidate.getFileName() + ":" + refinedCandidate.getStartLine(),
                  refinedDecl.getFileName(), refinedDecl.getStartLine());
            }
            outerIter.remove();
          }
        }
        if(refinedDecl != null) {
          iter.remove();
          refinedDecl.replacesAspect = null;
          list.add(refinedDecl);
        }
      }
      refinedSynEqs.addAll(list);
    }
    for(Iterator iter = replacedSynEqs.iterator(); iter.hasNext(); ) {
      SynEq decl = (SynEq)iter.next();
      refineError("equation", decl.getFileName(), decl.getStartLine());
    }
  }

  public String AttrEq.refinesAspect = null;

  // Multiple refinements done in order specified by the selected aspect name
  // error detection:
  //   detect attempts to refine equation using the wrong aspect name
  //   detect multiple attempts to refine an equation using the same aspect name
  public void TypeDecl.processRefinedSynEqs() {
    boolean change = true;
    while(change && !refinedSynEqs.isEmpty()) {
      change = false;
      for(int i = 0; i < getNumSynEq(); i++) {
        SynEq equ = getSynEq(i);
        SynEq refinedEqu = null;
        for(Iterator outerIter = refinedSynEqs.iterator(); outerIter.hasNext(); ) {
          SynEq refinedCandidate = (SynEq)outerIter.next();
          boolean legacyCondition = grammar().refineLegacy ? equ.legacyAspectName().equals(refinedCandidate.refinesAspect) : false;
          if(equ.signature().equals(refinedCandidate.signature())
             && (equ.aspectName().equals(refinedCandidate.refinesAspect) || legacyCondition)) {
            change = true;
            if(refinedEqu == null) {
              refinedEqu = refinedCandidate;
            } else {
              grammar().error("refinement previously defined at " +
                  refinedCandidate.getFileName() + ":" + refinedCandidate.getStartLine(),
                  refinedEqu.getFileName(), refinedEqu.getStartLine());
            }
            outerIter.remove();
          }
        }
        if(refinedEqu != null)
          refineWith(equ, refinedEqu);
      }
    }
    for(Iterator iter = refinedSynEqs.iterator(); iter.hasNext(); ) {
      SynEq equ = (SynEq)iter.next();
      refineError("syn equation", equ.getFileName(), equ.getStartLine());
    }
  }

  public void TypeDecl.refineWith(SynEq equ, SynEq refinedEqu) {
    StringBuffer s = new StringBuffer();
    String newMethodName = "refined_" + equ.aspectName() + "_" + name() + "_" + equ.signature();
    s.append("private " + equ.decl().getType() + " " + newMethodName + "(" +
      equ.parametersDecl() + ")\n");
    if(equ.getRHS() instanceof ASTBlock)
      s.append(Unparser.unparse(equ.getRHS()));
    else
      s.append("{ return " + Unparser.unparse(equ.getRHS()) + "; }");
    org.jastadd.jrag.AST.SimpleNode n = new org.jastadd.jrag.AST.ASTBlock(0);
    n.firstToken = n.lastToken = org.jastadd.jrag.AST.Token.newToken(0);
    n.firstToken.image = s.toString();
    ClassBodyObject object = new ClassBodyObject(n, equ.getFileName(), equ.getStartLine(), equ.getAspectName());
    // TODO:

    // change references to original equation in refined body
    if(refinedEqu.getRHS() instanceof org.jastadd.jrag.AST.ASTBlock)
      n = new org.jastadd.jrag.AST.ASTBlock(0);
    else
      n = new org.jastadd.jrag.AST.SimpleNode(0);

    n.firstToken = n.lastToken = org.jastadd.jrag.AST.Token.newToken(0);
    s = new StringBuffer();
    refinedEqu.getRHS().jjtAccept(new ClassBodyDeclUnparser(), s);

    String pattern = "\\brefined\\b";
    if(grammar().refineLegacy) {
      StringBuffer buf = new StringBuffer();
      buf.append("(");
      buf.append(pattern);
      buf.append(")|(");
      buf.append("\\b");
      buf.append(equ.legacyAspectName());
      buf.append("\\.[a-zA-Z0-9_$]+\\.");
      buf.append(equ.name());
      buf.append("\\b)");
      pattern = buf.toString();
    }
    java.util.regex.Matcher matcher = java.util.regex.Pattern.compile(pattern).matcher(s.toString());
    if(matcher.find()) {
      n.firstToken.image = matcher.replaceAll(newMethodName);
      classBodyDecls.add(object);
    }
    else {
      n.firstToken.image = s.toString();
    }
    // change body of original equation to the refined body
    equ.setRHS(n);
    equ.setFileName(refinedEqu.getFileName());
    equ.setStartLine(refinedEqu.getStartLine());
    equ.setEndLine(refinedEqu.getEndLine());
    equ.setAspectName(refinedEqu.getAspectName());
  }

  public LinkedList TypeDecl.refinedInhEqs = new LinkedList();
  public void Grammar.addRefinedInhEq(String childName, String name, String className, org.jastadd.jrag.AST.SimpleNode rhs, String fileName, int startLine, int endLine, org.jastadd.ast.AST.List list, String aspectName, org.jastadd.jrag.AST.SimpleNode node, String declaredAspect) {
    addRefinedInhEq(childName, name, className, rhs, fileName, startLine, endLine, list, null, aspectName, node, declaredAspect);
  }

  public void Grammar.addRefinedInhEq(String childName, String name, String className, org.jastadd.jrag.AST.SimpleNode rhs, String fileName, int startLine, int endLine, org.jastadd.ast.AST.List list, Parameter p, String aspectName, org.jastadd.jrag.AST.SimpleNode node, String declaredAspect) {
    TypeDecl c = lookup(className);
    if(c != null) {
        InhEq equ = new InhEq();
        equ.setName(name);
        equ.setFileName(fileName);
        equ.setStartLine(startLine);
        equ.setEndLine(endLine);
        equ.setRHS(rhs);
        equ.setChildName(childName);
        equ.setParameterList(list);
        equ.refinesAspect = aspectName;
        equ.setComment(Unparser.unparseComment(node));
        equ.setAspectName(declaredAspect);
        if(p != null) equ.setIndex(p);
        c.refinedInhEqs.add(equ); // Sortera i bokstavsordning därefter non NTA först
    } else {
      error("can not add equation for inherited attribute " + name + " to unknown class " + className,
          fileName, startLine);
    }
  }

  public void TypeDecl.processRefinedInhEqs() {
    boolean change = true;
    while(change && !refinedInhEqs.isEmpty()) {
      change = false;
      for(int i = 0; i < getNumInhEq(); i++) {
        InhEq equ = getInhEq(i);
        InhEq refinedEqu = null;
        for(Iterator outerIter = refinedInhEqs.iterator(); outerIter.hasNext(); ) {
          InhEq refinedCandidate = (InhEq)outerIter.next();
          boolean legacyCondition = grammar().refineLegacy ? equ.legacyAspectName().equals(refinedCandidate.refinesAspect) : false;
          if(equ.signature().equals(refinedCandidate.signature()) &&
             equ.childName().equals(refinedCandidate.childName()) &&
             (equ.aspectName().equals(refinedCandidate.refinesAspect) || legacyCondition)) {
            change = true;
            if(refinedEqu == null) {
              refinedEqu = refinedCandidate;
            } else {
              grammar().error("refinement previously defined at " +
                  refinedCandidate.getFileName() + ":" + refinedCandidate.getStartLine(),
                  refinedEqu.getFileName(), refinedEqu.getStartLine());
            }
            outerIter.remove();
          }
        }
        if(refinedEqu != null)
          refineWith(equ, refinedEqu);
      }
    }
    for(Iterator iter = refinedInhEqs.iterator(); iter.hasNext(); ) {
      InhEq equ = (InhEq)iter.next();
      refineError("inh equation", equ.getFileName(), equ.getStartLine());
    }
  }

  public void TypeDecl.refineWith(InhEq equ, InhEq refinedEqu) {
    // build a ClassBodyObject from the original equation
    StringBuffer s = new StringBuffer();
    String newMethodName = "refined_" + equ.aspectName() + "_" + name() + "_" + equ.childName()
      + "_" + equ.signature();

    String indexName = "";
    String indexDecl = "";
    boolean isList = equ.getComponents() instanceof ListComponents;
    if(isList) {
      indexName = equ.hasIndex() ? equ.getIndex().getName() : "childIndex";
      indexDecl = "int " + indexName;
      if(equ.getNumParameter() != 0) {
        indexName += ", ";
        indexDecl += ", ";
      }
    }

    s.append("private " + equ.decl().getType() + " " + newMethodName + "(" +
      indexDecl + equ.parametersDecl() + ")\n");
    if(equ.getRHS() instanceof ASTBlock)
      s.append(Unparser.unparse(equ.getRHS()));
    else
      s.append("{ return " + Unparser.unparse(equ.getRHS()) + "; }");
    org.jastadd.jrag.AST.SimpleNode n = new org.jastadd.jrag.AST.ASTBlock(0);
    n.firstToken = n.lastToken = org.jastadd.jrag.AST.Token.newToken(0);
    n.firstToken.image = s.toString();
    ClassBodyObject object = new ClassBodyObject(n, equ.getFileName(), equ.getStartLine(), equ.getAspectName());
    // change references to original equation in refined body
    if(refinedEqu.getRHS() instanceof org.jastadd.jrag.AST.ASTBlock)
      n = new org.jastadd.jrag.AST.ASTBlock(0);
    else
      n = new org.jastadd.jrag.AST.SimpleNode(0);
    n.firstToken = n.lastToken = org.jastadd.jrag.AST.Token.newToken(0);
    s = new StringBuffer();
    refinedEqu.getRHS().jjtAccept(new ClassBodyDeclUnparser(), s);

    String pattern = "refined\\(";
    if(grammar().refineLegacy)
      pattern = "(" + pattern + ")|("
      + equ.legacyAspectName() + "\\." + "[a-zA-Z0-9]+" + "\\.get"
      + equ.childName() + "\\([^\\)]*\\)\\." + equ.name() + "\\("
      + ")";

    java.util.regex.Matcher matcher = java.util.regex.Pattern.compile(pattern).matcher(s.toString());
    if(matcher.find()) {
      n.firstToken.image = matcher.replaceAll(newMethodName + "(" + indexName);
      classBodyDecls.add(object);
    }
    else {
      n.firstToken.image = s.toString();
    }

    // change body of original equation to the refined body
    equ.setRHS(n);
    equ.setFileName(refinedEqu.getFileName());
    equ.setStartLine(refinedEqu.getStartLine());
    equ.setEndLine(refinedEqu.getEndLine());
    equ.setAspectName(refinedEqu.getAspectName());
  }

  public LinkedList TypeDecl.refinedClassBodyDecls = new LinkedList();
  public void Grammar.addRefinedClassBodyDecl(org.jastadd.jrag.AST.SimpleNode n, String className, String fileName, String aspectName, String declaredAspect) {
    TypeDecl c = lookup(className);
    if(c != null) {
      ClassBodyObject o = new ClassBodyObject(n, fileName, n.firstToken.beginLine, declaredAspect);
      o.refinesAspect = aspectName;
      c.refinedClassBodyDecls.add(o);
    } else {
      error("can not add member to unknown class " + className + " in " + fileName);
    }
  }
  public void Grammar.addReplacedClassBodyDecl(org.jastadd.jrag.AST.SimpleNode n, String className, String fileName, String aspectName,
    String replacedAspect, org.jastadd.jrag.AST.SimpleNode replacedSignature, String declaredAspect) {
    TypeDecl c = lookup(className);
    if(c != null) {
      ClassBodyObject o = new ClassBodyObject(n, fileName, n.firstToken.beginLine, declaredAspect);
      o.refinesAspect = aspectName;
      o.replaceAspect = replacedAspect;
      c.replacements.add(o);
    } else {
      error("can not add member to unknown class " + className + " in " + fileName);
    }
  }
  /*
  process all refine - to
    if there are multiple refines to that target the same class body decl then error
    if there is a single refine to then
      remove that target class body decl
      turn the refine into a class body decl
  process all normal refines
    if there are multiple refine that target the same class body decl then error
    if there is a single refine then
      change the name of the target class body decl
      turn the refine into a class body decl
        replace all delegations of refined class body decl
  */
  public void TypeDecl.processRefinedClassBodyDecls() {
    boolean change = true;
    ArrayList list = new ArrayList();

    while(change && !refinedClassBodyDecls.isEmpty()) {
      change = false;
      for(Iterator iter = classBodyDecls.iterator(); iter.hasNext(); ) {
        ClassBodyObject decl = (ClassBodyObject)iter.next();
        ClassBodyObject refinedDecl = null;
        for(Iterator outerIter = refinedClassBodyDecls.iterator(); outerIter.hasNext(); ) {
          ClassBodyObject refinedCandidate = (ClassBodyObject)outerIter.next();

          boolean legacyCondition = grammar().refineLegacy ? decl.legacyAspectName().equals(refinedCandidate.refinesAspect) : false;
          if(decl.signature().equals(refinedCandidate.signature())
             && (decl.aspectName().equals(refinedCandidate.refinesAspect) || legacyCondition)) {
            change = true;
            if(refinedDecl == null) {
              refinedDecl = refinedCandidate;
            } else {
              grammar().error("refinement previously defined at " +
                  refinedCandidate.getFileName() + ":" + refinedCandidate.getStartLine(),
                  refinedDecl.getFileName(), refinedDecl.getStartLine());
            }
            outerIter.remove();
          }
        }
        if(refinedDecl != null) {
          if(!refineWith(decl, refinedDecl))
            iter.remove();
          list.add(refinedDecl);
        }
      }
      classBodyDecls.addAll(list);
    }
    for(Iterator iter = refinedClassBodyDecls.iterator(); iter.hasNext(); ) {
      ClassBodyObject decl = (ClassBodyObject)iter.next();
      refineError("method", decl.getFileName(), decl.getStartLine());
    }
  }
  public LinkedList TypeDecl.replacements = new LinkedList();
  public void TypeDecl.processReplacements() {
    boolean change = true;
    ArrayList list = new ArrayList();
    while(change && !replacements.isEmpty()) {
      change = false;
      for(Iterator iter = refinedClassBodyDecls.iterator(); iter.hasNext(); ) {
        ClassBodyObject decl = (ClassBodyObject)iter.next();
        ClassBodyObject refinedDecl = null;
        for(Iterator outerIter = replacements.iterator(); outerIter.hasNext(); ) {
          ClassBodyObject refinedCandidate = (ClassBodyObject)outerIter.next();
          boolean legacyCondition = grammar().refineLegacy ? decl.legacyAspectName().equals(refinedCandidate.replaceAspect) : false;
          if(decl.signature().equals(refinedCandidate.signature())
             && (decl.aspectName().equals(refinedCandidate.replaceAspect) || legacyCondition)) {
            change = true;
            if(refinedDecl == null) {
              refinedDecl = refinedCandidate;
            } else {
              grammar().error("refinement previously defined at " +
                  refinedCandidate.getFileName() + ":" + refinedCandidate.getStartLine(),
                  refinedDecl.getFileName(), refinedDecl.getStartLine());
            }
            outerIter.remove();
          }
        }
        if(refinedDecl != null) {
          iter.remove();
          replaceWith(refinedDecl);
          list.add(refinedDecl);
        }
      }
      refinedClassBodyDecls.addAll(list);
    }
    for(Iterator iter = replacements.iterator(); iter.hasNext(); ) {
      ClassBodyObject decl = (ClassBodyObject)iter.next();
      refineError("method", decl.getFileName(), decl.getStartLine());
    }
  }
  private void TypeDecl.replaceWith(ClassBodyObject o) {
    o.replaceAspect = null;

    org.jastadd.jrag.AST.SimpleNode node = o.node;
    // the first two children contain the extra signature in the refine to declaration
    node.firstToken = ((org.jastadd.jrag.AST.SimpleNode)node.jjtGetChild(1)).lastToken.next.next.next; // skip tokens "to refine"
    node.jjtAddChild(node.jjtGetChild(2), 0);
    node.jjtAddChild(node.jjtGetChild(3), 1);
    node.jjtAddChild(node.jjtGetChild(4), 2);
    // clear remaining children
    for(int i = 3; i < node.jjtGetNumChildren(); i++)
      node.jjtAddChild(null, i);
/*
    org.jastadd.jrag.AST.SimpleNode node = o.node;
    org.jastadd.jrag.AST.SimpleNode block = (jrag.AST.SimpleNode)node.jjtGetChild(4);
    node.jjtAddChild(block, 2);
    node.lastToken = block.lastToken;
    ((jrag.AST.SimpleNode)node.jjtGetChild(1)).lastToken.next = block.firstToken;
    for(int i = 3; i < node.jjtGetNumChildren(); i++)
      node.jjtAddChild(null, i);
 */
  }
  public boolean TypeDecl.refineWith(ClassBodyObject decl, ClassBodyObject refinedDecl) {
	  org.jastadd.jrag.AST.SimpleNode node = refinedDecl.node;
          boolean keep = true;

          if(node instanceof org.jastadd.jrag.AST.ASTAspectConstructorDeclaration || node instanceof org.jastadd.jrag.AST.ASTAspectRefineConstructorDeclaration) {
            // the name of a constructor is the same as the type name
            String methodName = name();

            // add prefix void refined_
            org.jastadd.jrag.AST.Token t1 = ((org.jastadd.jrag.AST.SimpleNode)decl.node.jjtGetChild(0)).firstToken;
            org.jastadd.jrag.AST.Token t2 = ((org.jastadd.jrag.AST.SimpleNode)decl.node).firstToken;
            while(t2.next != t1)
              t2 = t2.next;
            t2.image = "void refined_" + decl.aspectName() + "_" + name() + "_" + t2.image;

            // find block node
            org.jastadd.jrag.AST.SimpleNode parent = node;
            boolean first = true;
            keep = false;
            for(int index = 1; index < parent.jjtGetNumChildren(); index++) {
              org.jastadd.jrag.AST.SimpleNode child = (org.jastadd.jrag.AST.SimpleNode)parent.jjtGetChild(index);
              if(child instanceof org.jastadd.jrag.AST.ASTBlockStatement || child instanceof org.jastadd.jrag.AST.ASTExplicitConstructorInvocation) {
                node = child;
                // replace "aspectName.typeName.methodName" in refinedDecl with "refined_aspectName_methodName"
                StringBuffer buf = new StringBuffer();
                node.jjtAccept(new ClassBodyDeclUnparser(), buf);
                String s = buf.toString();

                String pattern = "\\brefined\\b";
                if(grammar().refineLegacy) {
                  buf = new StringBuffer();
                  buf.append("(");
                  buf.append(pattern);
                  buf.append(")|(");
                  buf.append("\\b");
                  buf.append(decl.legacyAspectName());
                  buf.append("\\.[a-zA-Z0-9_$]+\\.");
                  buf.append(methodName);
                  buf.append("\\b)");
                  pattern = buf.toString();
                }
                String newContents = "refined_" + decl.aspectName() + "_" + name() + "_" + methodName;
                //s = s.replaceAll(pattern, newContents);
                // TODO: update keep to false if no strings are replaced

                java.util.regex.Matcher matcher = java.util.regex.Pattern.compile(pattern).matcher(s);
                if(matcher.find()) {
                  s = matcher.replaceAll(newContents);
                  keep = true;
                }

                if(first) {
                  s = " {" + s;
                  first = false;
                }
                if(index == (parent.jjtGetNumChildren() - 1)) {
                  s = s + "\n}\n";
                }

                org.jastadd.jrag.AST.Token token = org.jastadd.jrag.AST.Token.newToken(0);
                token.image = s;

                ((org.jastadd.jrag.AST.SimpleNode)parent.jjtGetChild(index-1)).lastToken.next = token;
                token.next = token;
                node = new org.jastadd.jrag.AST.ASTBlock(0);
                parent.lastToken = token;
                node.firstToken = node.lastToken = token;
                parent.jjtAddChild(node, index);
                node.jjtSetParent(parent);
              }
            }

            parent = decl.node;
            first = true;
            for(int index = 1; index < parent.jjtGetNumChildren(); index++) {
            	org.jastadd.jrag.AST.SimpleNode child = (org.jastadd.jrag.AST.SimpleNode)parent.jjtGetChild(index);
              if(child instanceof org.jastadd.jrag.AST.ASTExplicitConstructorInvocation) {
                node = child;
                // replace "aspectName.typeName.methodName" in refinedDecl with "refined_aspectName_methodName"
                StringBuffer buf = new StringBuffer();
                node.jjtAccept(new ClassBodyDeclUnparser(), buf);
                String s = buf.toString();
                if(child instanceof org.jastadd.jrag.AST.ASTExplicitConstructorInvocation) {
                  s = "";
                }
                if(first) {
                  s = " {" + s;
                  first = false;
                }
                /*
                if(index == (parent.jjtGetNumChildren() - 1)) {
                  s = s + "\n}\n";
                }
                */

                org.jastadd.jrag.AST.Token token = org.jastadd.jrag.AST.Token.newToken(0);
                token.image = s;

                ((org.jastadd.jrag.AST.SimpleNode)parent.jjtGetChild(index-1)).lastToken.next = token;
                token.next = node.lastToken.next;
                node = new org.jastadd.jrag.AST.ASTExplicitConstructorInvocation(0);
                //parent.lastToken = token;
                node.firstToken = node.lastToken = token;
                parent.jjtAddChild(node, index);
                node.jjtSetParent(parent);
              }
            }
          }
          else if(node instanceof org.jastadd.jrag.AST.ASTAspectMethodDeclaration ||
        		      node instanceof org.jastadd.jrag.AST.ASTAspectRefineMethodDeclaration) {
            // retrieve methodName
            // AspectMethodDeclaration -> MethodDeclarator -> <IDENTIFIER>
            String idDecl = ((org.jastadd.jrag.AST.SimpleNode)decl.node.jjtGetChild(1)).firstToken.image;
            String methodName = idDecl.trim();

            // add prefix refined_aspectName_
            idDecl = idDecl.replaceAll(methodName, "refined_" + decl.aspectName() + "_" + name() + "_" + methodName);
            ((org.jastadd.jrag.AST.SimpleNode)decl.node.jjtGetChild(1)).firstToken.image = idDecl;

            org.jastadd.jrag.AST.SimpleNode parent = node;
            int index = 2;
            while(index < node.jjtGetNumChildren() && !(node.jjtGetChild(index) instanceof org.jastadd.jrag.AST.ASTBlock))
              index++;
            if(index >= node.jjtGetNumChildren())
              throw new Error("Could not find block node");
            node = (org.jastadd.jrag.AST.SimpleNode)node.jjtGetChild(index);

            // replace "aspectName.typeName.methodName" in refinedDecl with "refined_aspectName_methodName"
            StringBuffer buf = new StringBuffer();
            node.jjtAccept(new ClassBodyDeclUnparser(), buf);
            String s = buf.toString();
            String pattern = "\\brefined\\b";
            if(grammar().refineLegacy) {
              buf = new StringBuffer();
              buf.append("(");
              buf.append(pattern);
              buf.append(")|(");
              buf.append("\\b");
              buf.append(decl.legacyAspectName());
              buf.append("\\.[a-zA-Z0-9_$]+\\.");
              buf.append(methodName);
              buf.append("\\b)");
              pattern = buf.toString();
            }
            String newContents = "refined_" + decl.aspectName() + "_" + name() + "_" + methodName;
            //s = s.replaceAll(pattern, newContents);
            // TODO: update keep to false if no strings are replaced

            java.util.regex.Matcher matcher = java.util.regex.Pattern.compile(pattern).matcher(s);
            if(matcher.find()) {
              s = matcher.replaceAll(newContents);
            }
            else {
              keep = false;
            }

            org.jastadd.jrag.AST.Token token = org.jastadd.jrag.AST.Token.newToken(0);
            token.image = s;

            ((org.jastadd.jrag.AST.SimpleNode)parent.jjtGetChild(index-1)).lastToken.next = token;
            token.next = token;
            node = new org.jastadd.jrag.AST.ASTBlock(0);
            parent.lastToken = token;
            node.firstToken = node.lastToken = token;
            parent.jjtAddChild(node, index);
            node.jjtSetParent(parent);
          }
          else {
            throw new Error("Unexpected node type " + node.getClass().getName());
          }


          /*
          org.jastadd.jrag.AST.SimpleNode n = new jrag.AST.ASTBlock(0);
          n.firstToken = n.lastToken = org.jastadd.jrag.AST.Token.newToken(0);
          n.firstToken.image = s;
          // store signature explicitly in decl since the node is replaced.
          String signature = refinedDecl.signature();
          refinedDecl.node = n;
          refinedDecl.setSignature(signature);
         */

         return keep;
  }

  public LinkedList TypeDecl.implementsList = new LinkedList();

  public boolean ASTDecl.implementsInterface(String name) { // DRAGONS
    for(Iterator iter = implementsList.iterator(); iter.hasNext(); ) {
      org.jastadd.jrag.AST.SimpleNode n = (org.jastadd.jrag.AST.SimpleNode)iter.next();
      StringBuffer s = new StringBuffer();
      n.jjtAccept(new Unparser(), s);
      String i = s.toString();
      int index = i.indexOf(name);
      if(index == -1)
        continue;
      if(index > 0 && Character.isJavaIdentifierPart(i.charAt(index-1)))
        continue;
      if(index + name.length() < i.length() && Character.isJavaIdentifierPart(i.charAt(index + name.length())))
        continue;
      return true;
    }
    return false;
  }

  public LinkedList Grammar.compUnits = new LinkedList();


  public org.jastadd.jrag.AST.SimpleNode AttrEq.rhs;
  public void AttrEq.setRHS(org.jastadd.jrag.AST.SimpleNode node) {
    rhs = node;
  }
  public org.jastadd.jrag.AST.SimpleNode AttrEq.getRHS() {
    return rhs;
  }

  syn String AttrEq.parametersDecl() {
    StringBuffer s = new StringBuffer();
    for(int i = 0; i < getNumParameter(); i++) {
      Parameter p = getParameter(i);
      s.append(p.getType() + " " + p.getName());
      if(i < getNumParameter() - 1) s.append(", ");
    }
    return s.toString();
  }

  syn String AttrEq.parameters() {
    StringBuffer s = new StringBuffer();
    for(int i = 0; i < getNumParameter(); i++) {
      Parameter p = getParameter(i);
      s.append(p.getName());
      if(i < getNumParameter() - 1) s.append(", ");
    }
    return s.toString();
  }
  syn String AttrDecl.parametersDecl() {
    StringBuffer s = new StringBuffer();
    for(int i = 0; i < getNumParameter(); i++) {
      Parameter p = getParameter(i);
      s.append(p.getType() + " " + p.getName());
      if(i < getNumParameter() - 1) s.append(", ");
    }
    return s.toString();
  }

  syn String AttrDecl.parameters() {
    StringBuffer s = new StringBuffer();
    for(int i = 0; i < getNumParameter(); i++) {
      Parameter p = getParameter(i);
      s.append(p.getName());
      if(i < getNumParameter() - 1) s.append(", ");
    }
    return s.toString();
  }


  syn String AttrDecl.interfaceParameters() =
    "caller, child" + (parameters().equals("") ? "" : (", " + parameters()));

  syn String AttrDecl.interfaceParametersDecl() =
    grammar().astNodeType + " caller, " + grammar().astNodeType + " child" + (parametersDecl().equals("") ? "" : (", " + parametersDecl()));

  syn String AttrEq.interfaceParameters() = "caller, child" + (parameters().equals("") ? "" : (", " + parameters()));

  syn String AttrEq.interfaceParametersDecl() =
    grammar().astNodeType + " caller, " + grammar().astNodeType + " child" + (parametersDecl().equals("") ? "" : (", " + parametersDecl()));

  public org.jastadd.jrag.AST.SimpleNode Rewrite.condition;
  public org.jastadd.jrag.AST.SimpleNode Rewrite.getCondition() {
    return condition;
  }
  public void Rewrite.setCondition(org.jastadd.jrag.AST.SimpleNode c) {
    condition = c;
  }

  public org.jastadd.jrag.AST.SimpleNode Rewrite.result;
  public org.jastadd.jrag.AST.SimpleNode Rewrite.getResult() {
    return result;
  }
  public void Rewrite.setResult(org.jastadd.jrag.AST.SimpleNode r) {
    result = r;
  }

  public String Rewrite.returnType;
  public String Rewrite.getReturnType() {
    return returnType;
  }
  public void Rewrite.setReturnType(String type) {
    returnType = type;
  }

  public String RewriteList.parentName;
  public String RewriteList.getParentName() {
    return parentName;
  }
  public void RewriteList.setParentName(String name) {
    parentName = name;
  }
  public String RewriteList.childName;
  public String RewriteList.getChildName() {
    return childName;
  }
  public void RewriteList.setChildName(String name) {
    childName = name;
  }

  // TODO: INH
  syn String AttrDecl.interfaceParametersStart() = "this, null" + (parameters().equals("") ? "" : (", " + parameters()));
  syn String AttrDecl.interfaceParametersContinue() = "this, caller" + (parameters().equals("") ? "" : (", " + parameters()));
  syn String AttrEq.interfaceParametersStart() = "this, null" + (parameters().equals("") ? "" : (", " + parameters()));
  syn String AttrEq.interfaceParametersContinue() = "this, caller" + (parameters().equals("") ? "" : (", " + parameters()));
}
