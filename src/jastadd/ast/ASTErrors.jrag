/* Copyright (c) 2005-2013, The JastAdd Team
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Lund University nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
package ast;

import org.jastadd.ast.AST.*;

import java.util.*;

import org.jastadd.Problem;

/**
 * Abstract syntax error checking
 */
aspect ASTErrors {
  /**
   * Collects problems in the AST.
   * @return A collection of problems in the AST
   */
  coll Collection<Problem> Grammar.problems()
    [new LinkedList<Problem>()]
    with add;

  syn boolean TypeDecl.isRootNode() = false;

  eq ASTDecl.isRootNode() =
    !hasAbstract() &&
    !isASTNodeDecl() &&
    !isOptSubtype() &&
    !isListSubtype() &&
    parents().isEmpty();

  Grammar contributes new Problem.Warning("there is no root node in the grammar!")
    when roots().isEmpty()
    to Grammar.problems()
    for this;

  // TODO add filename, line, col
  TypeDecl contributes new Problem.Error(
      "multiple production rule for non-terminal " + name())
    when grammar().lookup(name()) != this
    to Grammar.problems()
    for grammar();

  ASTDecl contributes new Problem.Error(
      "multiple production rule for non-terminal " + name(),
                                        getFileName(), getStartLine())
    when grammar().lookup(name()) != this
    to Grammar.problems()
    for grammar();

  ASTDecl contributes new Problem.Error(
      name() + " causes circular inheritance",
                                        getFileName(), getStartLine())
    when isCircular()
    to Grammar.problems()
    for grammar();

  ASTDecl contributes new Problem.Error(
      name() + " inherits from undeclared class " + getSuperClass().name(),
                                        getFileName(), getStartLine())
    when hasSuperClass() && superClass() == null
    to Grammar.problems()
    for grammar();

  Components contributes new Problem.Error(
      "Component name " + name() + " is not unique in production rule for " + hostClass().name(),
                                        hostClass().getFileName(), hostClass().getStartLine())
    when hostClass().lookupComponents(name()) != this
    to Grammar.problems()
    for grammar();

  Components contributes new Problem.Error(
      "Type " + type() + " of component " + name() + " in production " + hostClass().name() + " is not declared",
                                        hostClass().getFileName(), hostClass().getStartLine())
    when !declared()
    to Grammar.problems()
    for grammar();

  public boolean Components.declared() {
    return grammar().lookup(type()) != null;
  }

  public boolean TokenComponent.declared() {
    return true;
  }
}

