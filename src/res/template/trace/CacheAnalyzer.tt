# Copyright (c) 2013, The JastAdd Team
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright notice,
#       this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the Lund University nor the names of its
#       contributors may be used to endorse or promote products derived from
#       this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

# Code for CacheAnalyzer
CacheAnalyzer = [[
$PackageDecl

import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;

/**
 * Cache analyzer based on the ideas presented in
 *
 *   <a href="http://dx.doi.org/10.1007/978-3-642-19440-5_2">
 *   Automated selective caching for reference attribute grammars"
 *    </a>
 *   <i>Emma S&ouml;derberg and G&ouml;rel Hedin</i>
 *   <i>Dept. of Computer Science, Lund University</i>
 *
 */
public class CacheAnalyzer extends Tracer.InputFilter {
  
  private final String[] ATTRIBUTES = { $AttrNameList };
  private Map<String,Map<String,Integer>> attrMap = null;

  public Tracer.TraceObject createTraceObject(Tracer.Event evt, $ASTNode node, String attr, Object params, Object value) {
    if (evt == Tracer.Event.CACHED || evt == Tracer.Event.CACHE_READ) {
      if (attrMap == null) {
        createAttrMap();
      }
      Map<String,Integer> instanceMap = attrMap.get(attr);
      if (instanceMap == null) {
        instanceMap = new HashMap<String,Integer>();
        attrMap.put(attr, instanceMap);
      }
      String instance = String.format("%08X", node.hashCode());
      Integer calls = instanceMap.get(instance);
      instanceMap.put(instance, calls == null ? 1 : calls + 1); 
    }  
    return super.createTraceObject(evt, node, attr, params, value);
  }

  public boolean include(Tracer.TraceObject obj) {
    return false;
  }

  public String desc() {
    return "Cache analyzer";
  }

  private Map<String,Map<String,Integer>> createAttrMap() {
    attrMap = new HashMap<String,Map<String,Integer>>();
    for (String attrName : ATTRIBUTES) {
      attrMap.put(attrName, null);
    }
    return attrMap;
  }
  
  /**
   * @return The raw trace result of the analyzer, mapping attribute names to call counts
   */
  public Map<String,Map<String,Integer>> getRawResult() {
    Map<String,Map<String,Integer>> map = new HashMap<String,Map<String,Integer>>();
    if (attrMap == null) {
      return map;
    }
    for (Map.Entry<String,Map<String,Integer>> e : attrMap.entrySet()) {
      if (e.getValue() != null) {
        Map<String,Integer> innerMap = new HashMap<String,Integer>();
        for (Map.Entry<String,Integer> ie : e.getValue().entrySet()) {
          innerMap.put(ie.getKey(), ie.getValue());    
        }
        map.put(e.getKey(), innerMap);
      } else {
        map.put(e.getKey(), null);
      }
    }
    return map;
  }
  
  /**
   * @return The average number of calls per instance for the given attribute
   */
  public double getAverageAttrCalls(String attr) {
    if (attrMap == null) {
      return 0.0;
    }
    Map<String, Integer> instanceMap = attrMap.get(attr);
    if (instanceMap == null) {
      return 0.0;
    }
    double sum = 0.0;
    for (Integer calls : instanceMap.values()) {
      sum += calls;
    }
    return sum / instanceMap.size();
  }
  
  /**
   * @return The set of all attributes, represented with signature strings
   */
  public Set<String> getAllSet() {
    Set<String> set = new HashSet<String>();
    if (attrMap == null) {
      return set;
    }
    for (String attrName : ATTRIBUTES) {
      set.add(attrName);
    }
    return set;
  }
  
  /**
   * @return The set of used attributes, represented with signature strings
   */
  public Set<String> getUsedSet() {
    Set<String> set = new HashSet<String>();
    if (attrMap == null) {
      return set;
    }
    for (Map.Entry<String,Map<String,Integer>> e : attrMap.entrySet()) {
      if (e.getValue() != null) {
        set.add(e.getKey());
      }
    }
    return set;
  }
  
  /**
   * @return The set of attributes used once, represented with signature strings
   */
  public Set<String> getOneSet() {
    Set<String> set = new HashSet<String>();
    if (attrMap == null) {
      return set;
    }
    for (Map.Entry<String,Map<String,Integer>> e : attrMap.entrySet()) {
      if (e.getValue() != null && getAverageAttrCalls(e.getKey()) <= 1.0) {
        set.add(e.getKey());
      }
    }
    return set;
  }
  
  /**
   * @return The attribute coverage in percent (i.e., Used/All)
   */
   public double getAttributeCoverage() {
     return (getUsedSet().size()*1.0 / getAllSet().size()*1.0) * 100.0;
   }
   
  /**
   * Prints a cache configuration corresponding to All-One
   * @param out Print writer to use 
   */
   public void printAllOneConfig(java.io.PrintWriter out) {
     Set<String> configSet = getAllSet();
     configSet.removeAll(getOneSet());
     for (String attr : configSet) {
       out.println("cache " + attr + ";");  
     }
   }
   
  /**
   * Prints a cache configuration corresponding to Used-One
   * @param out Print writer to use 
   */
   public void printUsedOneConfig(java.io.PrintWriter out) {
     Set<String> configSet = getUsedSet();
     configSet.removeAll(getOneSet());
     for (String attr : configSet) {
       out.println("cache " + attr + ";");  
     }
   }
}
]]