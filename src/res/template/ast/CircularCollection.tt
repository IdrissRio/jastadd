# Copyright (c) 2013, The JastAdd Team
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright notice,
#       this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the Lund University nor the names of its
#       contributors may be used to endorse or promote products derived from
#       this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

# circular collection evaluation
AttrDecl.circularCollectionEval = [[
$if(#isParameterized)
  /**
   * @apilevel internal
   */
  protected $TypeDefaultSet #(attributeSignature)_computed = $CreateDefaultSet;

  /**
   * @apilevel internal
   */
  protected $TypeDefaultSet #(attributeSignature)_initialized = $CreateDefaultSet;

  /**
   * @apilevel internal
   */
  protected $TypeDefaultMap #(attributeSignature)_values = $CreateDefaultMap;

  #hostFileComment
  #annotations
  public #getType #attributeName(#parametersDecl) {
    $BlockBegin
    #parameterStructure
    #initLazyMaps
    $include(AttrDecl.cacheCheck)
    #addComponentCheck
    if (!#(attributeSignature)_initialized.contains(_parameters)) {
      #(attributeSignature)_initialized.add(_parameters);
      #(attributeSignature)_values.put(_parameters, $RefType1);
    }
    if (!state().IN_CIRCLE) {
      state().IN_CIRCLE = true;
      #cacheInitRewrite
      #addAddToComponent
      state().CIRCLE_INDEX = 1;
      #getType new_#(attributeSignature)_value;
      do {
        #(attributeSignature)_visited.put(_parameters, new Integer(state().CIRCLE_INDEX));
        state().CHANGE = false;
        new_#(attributeSignature)_value = $BottomValue;
        combine_#(attributeSignature)_contributions(new_#(attributeSignature)_value);
        if ($Cond2) {
          state().CHANGE = true;
        }
        #(attributeSignature)_values.put(_parameters, $RefType2);
        state().CIRCLE_INDEX++;
        #cycleLimitCheck
      } while (state().CHANGE);

      #cacheStoreRewrite {
        #(attributeSignature)_computed.add(_parameters);
        #cacheCycleInit
      } else {
        #resetCycleInit
        #(attributeSignature)_computed.remove(_parameters);
        #(attributeSignature)_initialized.remove(_parameters);
      }
      state().IN_CIRCLE = false;
      return new_#(attributeSignature)_value;
    }
    if(!new Interger(state().CIRCLE_INDEX).equals(#(attributeSignature)_visited.get(_parameters))) {
      #(attributeSignature)_visited.put(_paramters, new Integer(state().CIRCLE_INDEX));
      #cacheCycleCheck
      $include(AttrDecl.resetCycleCheck)
      #getType new_#(attributeSignature)_value = $BottomValue;
      combine_#(attributeSignature)_contributions(new_#(attributeSignature)_value);
      if ($Cond2) {
        state().CHANGE = true;
      }
      #(attributeSignature)_values.put(_parameters, $RefType2);
      return new_#(attributeSignature)_value;
    }
    return $FromRefType;
    $BlockEnd
  }
$else
  /**
   * @apilevel internal
   */
  protected boolean #(attributeSignature)_computed = false;

  /**
   * @apilevel internal
   */
  protected boolean #(attributeSignature)_initialized = false;

  /**
   * @apilevel internal
   */
  protected #getType #(attributeSignature)_value;

$if(SeparateEvaluation)
  protected #getType new_#(attributeSignature)_value;
$endif

  #hostFileComment
  #annotations
  public #getType #attributeName(#parametersDecl) {
    $BlockBegin
    #parameterStructure
    $include(AttrDecl.cacheCheck)
    ASTNode node = this;
    while(node.getParent() != null && !(node instanceof $RootType))
      node = node.getParent();
    #collDebugString
    $RootType root = ($RootType) node;

$if(!SeparateEvaluation)
    if(root.collecting_contributors_#collectingSignature)
      throw new RuntimeException("Circularity during phase 1");
$endif
    #addComponentCheck
$if(!SeparateEvaluation)
    root.collect_contributors_#collectingSignature();
$endif

    if (!#(attributeSignature)_initialized) {
      #(attributeSignature)_initialized = true;
      #(attributeSignature)_value = $BottomValue;
    }

    if (!state().IN_CIRCLE) {
      state().IN_CIRCLE = true;
      #addAddToComponent
      #cacheInitRewrite
      state().CIRCLE_INDEX = 1;
      do {
        #(attributeSignature)_visited = state().CIRCLE_INDEX;
        state().CHANGE = false;

$if(SeparateEvaluation)
        new_#(attributeSignature)_value = $BottomValue;
        root.#(name)_#(attributeSignature)_nextIteration(this);
$else
        #getType new_#(attributeSignature)_value = $BottomValue;
        combine_#(attributeSignature)_contributions(new_#(attributeSignature)_value);
$endif
        if ($Cond1) {
          state().CHANGE = true;
        }
        #(attributeSignature)_value = new_#(attributeSignature)_value;
        state().CIRCLE_INDEX++;
        #cycleLimitCheck
      } while (state().CHANGE);

      #cacheStoreRewrite {
        #(attributeSignature)_computed = true;
        #cacheCycleInit
      } else {
        #resetCycleInit
        #(attributeSignature)_computed = false;
        #(attributeSignature)_initialized = false;
      }
      state().IN_CIRCLE = false;
      $include(AttrDecl.returnStmt)
    }
    if(#(attributeSignature)_visited != state().CIRCLE_INDEX) {
      #(attributeSignature)_visited = state().CIRCLE_INDEX;
      #cacheCycleCheck
      $include(AttrDecl.resetCycleCheck)
      #addAddToComponent
$if(SeparateEvaluation)
      new_#(attributeSignature)_value = $BottomValue;
      root.#(name)_#(attributeSignature)_nextIteration(this);
$else
      #(getType) new_#(attributeSignature)_value = $BottomValue;
      combine_#(attributeSignature)_contributions(new_#(attributeSignature)_value);
$endif
      if ($Cond1) {
        state().CHANGE = true;
      }
      #(attributeSignature)_value = new_#(attributeSignature)_value;
      $include(AttrDecl.returnStmt)
    }
    $include(AttrDecl.returnStmt)
    $BlockEnd
  }
$endif
]]
