# Copyright (c) 2013, The JastAdd Team
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright notice,
#       this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the Lund University nor the names of its
#       contributors may be used to endorse or promote products derived from
#       this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

ASTNode.flushHookSetChildCopyState = [[
$if(FullFlush)

if (init_children != null) {
  ASTNode d[] = new ASTNode[i << 1];
  System.arraycopy(init_children, 0, d, 0, init_children.length);
  init_children = d;
}
if (rewritten_children != null) {
  boolean[] b = new boolean[i << 1];
  System.arraycopy(rewritten_children, 0, b, 0, rewritten_children.length);
  rewritten_children = b;
}

$endif
]]

ASTNode.flushHookSetChildInitState = [[
$if(FullFlush)

if (rewritten_children != null) {
  rewritten_children[i] = false; 
}
       
$endif
]]

ASTNode.flushHookInsertChildUpdateState = [[
$if(FullFlush)

if (init_children != null) {
  ASTNode d[] = new ASTNode[init_children.length + 1];
  System.arraycopy(init_children, 0, d, 0, init_children.length);
  if (i < init_children.length) {
    System.arraycopy(init_children, i, d, i+1, init_children.length - i);
  }
  init_children = d;
}
if (rewritten_children != null) {
  boolean b[] = new boolean[rewritten_children.length + 1];
  System.arraycopy(rewritten_children, 0, b, 0, rewritten_children.length);
  if (i < rewritten_children.length) {
    System.arraycopy(rewritten_children, i, b, i+1, rewritten_children.length - i);
  }
  rewritten_children = b;
}

$endif
]]

ASTNode.flushHookRemoveChild = [[
$if(FullFlush)

if (init_children != null) {
  System.arraycopy(init_children, i+1, init_children, i, init_children.length-i-1);
}      
if (rewritten_children != null) {
  System.arraycopy(rewritten_children, i+1, rewritten_children, i, rewritten_children.length-i-1);
}
    
$endif
]]

ASTNode.flushHookGetChildInit = [[
$if(FullFlush)
if(this.init_children == null) {
  this.init_children = new ASTNode[this.children.length];
  this.rewritten_children = new boolean[this.children.length];
}    
$endif
]]

ASTNode.flushHookGetChildCheckStoreInit = [[
$if(FullFlush)
if(!node.inc_hasEnclosingRewrittenNode()) {
  this.init_children[i] = node.fullCopy();
  this.rewritten_children[i] = true;
}
$endif
]]

ASTNode.flushHookGetChildRewritten = [[
$if(FullFlush)
if (rewriteState == ASTNode$$State.REWRITE_CHANGE) {
  this.rewritten_children[i] = true;
}
$endif
]]

# State variables needed to handle flushing of rewrites
# TODO: These should be protected, but are public now for debugging
ASTNode.flushRewritesInitValue = [[
$if(FullFlush)
$if(IsAstNode)
  /**
   * @apilevel internal
   */
  public ASTNode[] init_children;
  /**
   * @apilevel internal
   */
  public boolean[] rewritten_children;
$endif
$endif
]]

# Method needed for to handler flushing of rewrites.
# Checks whether there is an enclosing rewritten node.
ASTNode.flushRewritesHasEnclosingRewriteMethod = [[
$if(FullFlush)
$if(IsAstNode)
  /**
    * @apilevel internal
    */
  protected boolean inc_hasEnclosingRewrittenNode() {
    ASTNode child = this;
    ASTNode parent = this.parent;
    while (parent != null) {
      if (parent.mayHaveRewrite()) {
        return true;
      }
      child = parent;
      parent = parent.parent;
    }
    return false;
  } 
$endif
$endif
]]

ASTDecl.flushCacheMethod = [[
  /**
    * @apilevel low-level
    */
  public void flushCache() {
    $SynchBegin
    $if(!IsAstNode)
    super.flushCache();
    $endif 
$if(FullFlush)
  $if(IsAstNode)
    for (int i = 0; i < getNumChildNoTransform(); i++) {
      if (rewritten_children != null && rewritten_children[i]) {
        if (init_children[i] != null) {
          setChild(init_children[i], i);
          init_children[i] = null;
        }
        rewritten_children[i] = false;
      } else {
        getChildNoTransform(i).flushCache();
      }
    }
  $endif
    $FlushNTACache
$endif
    $FlushSynAttrCache
    $FlushInhAttrCache
    $FlushCollectionCache
    $SynchEnd
  }
]]

ASTDecl.flushCollectionCacheMethod = [[   
  /**
    * @apilevel internal
    */
  public void flushCollectionCache() {
    $if(!IsAstNode)
    super.flushCollectionCache();
    $endif
    $FlushCollectionCache
  }
]]

TokenComponent.flushNTACache = [[
$if(FullFlush)
if (((Object)token$(TypeSign)_$Id) instanceof ASTNode) {
  token$(TypeSign)_$Id = null;
}
$endif
]]