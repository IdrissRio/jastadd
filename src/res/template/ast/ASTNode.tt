# Boilerplate code for ASTNode

ASTNode.declarations = [[
  /**
   * @apilevel internal
   */
  public static final boolean ASTNode.generatedWithCircularEnabled = $CircularEnabled;
  /**
   * @apilevel internal
   */
  public static final boolean ASTNode.generatedWithCacheCycle = $CacheCycle;
  /**
   * @apilevel internal
   */
  public static final boolean ASTNode.generatedWithComponentCheck = $ComponentCheck;

$if(!JJTree)
  /**
   * Parent pointer
   * @apilevel low-level
   */
  protected ASTNode ASTNode.parent;

  /**
   * Child array
   * @apilevel low-level
   */
  protected ASTNode[] ASTNode.children;
$endif
]]

ASTNode.rewriteDecls = [[
$if(RewriteEnabled)
  /**
   * @apilevel internal
   */
  public boolean ASTNode.in$$Circle = false;

  /**
   * @apilevel internal
   */
  public boolean ASTNode.in$$Circle() {
    return in$$Circle;
  }

  /**
   * @apilevel internal
   */
  public void ASTNode.in$$Circle(boolean b) {
    in$$Circle = b;
  }

$if(HasRewriteLimit)
  /**
   * @apilevel internal
   */
  public void ASTNode.debugRewrite(String info) {
    if(!parent.is$$Final()) return;
      java.util.ArrayList key = new java.util.ArrayList(2);
      key.add(getParent());
      key.add(new Integer(getParent().getIndexOfChild(this)));
      java.util.ArrayList list;
      if(state().debugRewrite.containsKey(key))
        list = (java.util.ArrayList)state().debugRewrite.get(key);
    else {
      list = new java.util.ArrayList();
      state().debugRewrite.put(key, list);
    }
    list.add(info);
    if(list.size() > $RewriteLimit) {
      StringBuffer buf = new StringBuffer("Iteration count exceeded for rewrite:");
      for(java.util.Iterator iter = list.iterator(); iter.hasNext(); )
        buf.append("\n" + iter.next());
      throw new RuntimeException(buf.toString());
    }
  }

  /**
   * @apilevel internal
   */
  public void ASTNode.debugRewriteRemove() {
    java.util.ArrayList key = new java.util.ArrayList(2);
    key.add(getParent());
    key.add(new Integer(getParent().getIndexOfChild(this)));
    state().debugRewrite.remove(key);
  }
$endif
$if(StagedRewrites)
  /**
   * @apilevel internal
   */
  public int ASTNode.is$$Final = 0;
  /**
   * @apilevel internal
   */
  public boolean ASTNode.is$$Final() { return is$$Final >= state().rewritePhase; }
  /**
   * @apilevel internal
   */
  public void ASTNode.is$$Final(int phase) { is$$Final = phase; }
  /**
   * @apilevel internal
   */
  public void ASTNode.enterRewritePhase(int phase) { state().rewritePhase = phase; }
  /**
   * @apilevel internal
   */
  public boolean ASTNode.inRewritePhase(int phase) { return state().rewritePhase >= phase; }
$else
  /**
   * @apilevel internal
   */
  public boolean ASTNode.is$$Final = false;
  /**
   * @apilevel internal
   */
  public boolean ASTNode.is$$Final() { return is$$Final; }
  /**
   * @apilevel internal
   */
  public void ASTNode.is$$Final(boolean b) { is$$Final = b; }
$endif
$endif
]]

ASTNode.debugDecls = [[
$if(DebugMode)
  /**
   * @apilevel internal
   */
  protected boolean ASTNode.debugNodeAttachmentIsRoot() {
    return false;
  }

  /**
   * @apilevel internal
   */
  private static void ASTNode.debugNodeAttachment(ASTNode node) {
    if(node == null) {
      throw new RuntimeException("Trying to assign null to a tree child node");
    }

    while(node != null && !node.debugNodeAttachmentIsRoot()) {
$if(RewriteEnabled)
      if(node.in$$Circle())
        return;
$endif
      ASTNode parent = (ASTNode)node.parent;
      if(parent != null && parent.getIndexOfChild(node) == -1) {
        return;
      }
      node = parent;
    }

    if(node != null) {
      throw new RuntimeException("Trying to insert the same tree at multiple tree locations");
    }
  }
$endif
]]

ASTNode.childIndex = [[
  /**
   * @apilevel internal
   */
  private int ASTNode.childIndex;

  /**
   * @apilevel low-level
   */
  public int ASTNode.getIndexOfChild(ASTNode node) {
    if (node != null && node.childIndex < numChildren
        && node == children[node.childIndex])
      return node.childIndex;
    for(int i = 0; children != null && i < children.length; i++) {
      if(children[i] == node) {
        node.childIndex = i;
        return i;
      }
    }
    return -1;
  }
]]

ASTNode.iterator = [[
  /**
   * @apilevel low-level
   */
  public java.util.Iterator<T> ASTNode.iterator() {
    $SynchBegin
    return new java.util.Iterator<T>() {
      private int counter = 0;
      public boolean hasNext() {
        return counter < getNumChild();
      }
      @SuppressWarnings("unchecked") public T next() {
        if(hasNext())
          return (T)getChild(counter++);
        else
          return null;
      }
      public void remove() {
        throw new UnsupportedOperationException();
      }
    };
    $SynchEnd
  }
]]

ASTNode.setParent = [[
  /**
   * @apilevel low-level
   */
  public void ASTNode.setParent(ASTNode node) {
    $SynchBegin
    $include(ASTDecl.incHookSetParentBegin)
    parent = node;
    $SynchEnd
  }
]]
