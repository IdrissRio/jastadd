# Boilerplate code for ASTNode

ASTNode.declarations = [[
  /**
   * @apilevel internal
   */
  private int ASTNode.childIndex;

  /**
   * @apilevel low-level
   */
  public int ASTNode.getIndexOfChild(ASTNode node) {
    if (node != null && node.childIndex < numChildren
        && node == children[node.childIndex])
      return node.childIndex;
    for(int i = 0; children != null && i < children.length; i++) {
      if(children[i] == node) {
        node.childIndex = i;
        return i;
      }
    }
    return -1;
  }

  /**
   * @apilevel internal
   */
  public static final boolean ASTNode.generatedWithCircularEnabled = $CircularEnabled;
  /**
   * @apilevel internal
   */
  public static final boolean ASTNode.generatedWithCacheCycle = $CacheCycle;
  /**
   * @apilevel internal
   */
  public static final boolean ASTNode.generatedWithComponentCheck = $ComponentCheck;

$if(!JJTree)
  /**
   * Parent pointer
   * @apilevel low-level
   */
  protected ASTNode ASTNode.parent;

  /**
   * Child array
   * @apilevel low-level
   */
  protected ASTNode[] ASTNode.children;
$endif
$if(!NoStatic)
  /**
   * @apilevel internal
   */
  protected static ASTNode$$State ASTNode.state = new ASTNode$$State();

  /**
   * @apilevel internal
   */
  public final ASTNode$$State ASTNode.state() {
    return state;
  }
$endif
$if(RewriteEnabled)
  /**
   * @apilevel internal
   */
  public boolean ASTNode.in$$Circle = false;

  /**
   * @apilevel internal
   */
  public boolean ASTNode.in$$Circle() {
    return in$$Circle;
  }

  /**
   * @apilevel internal
   */
  public void ASTNode.in$$Circle(boolean b) {
    in$$Circle = b;
  }

$if(HasRewriteLimit)
  /**
   * @apilevel internal
   */
  public void ASTNode.debugRewrite(String info) {
    if(!parent.is$$Final()) return;
      java.util.ArrayList key = new java.util.ArrayList(2);
      key.add(getParent());
      key.add(new Integer(getParent().getIndexOfChild(this)));
      java.util.ArrayList list;
      if(state().debugRewrite.containsKey(key))
        list = (java.util.ArrayList)state().debugRewrite.get(key);
    else {
      list = new java.util.ArrayList();
      state().debugRewrite.put(key, list);
    }
    list.add(info);
    if(list.size() > $RewriteLimit) {
      StringBuffer buf = new StringBuffer("Iteration count exceeded for rewrite:");
      for(java.util.Iterator iter = list.iterator(); iter.hasNext(); )
        buf.append("\n" + iter.next());
      throw new RuntimeException(buf.toString());
    }
  }

  /**
   * @apilevel internal
   */
  public void ASTNode.debugRewriteRemove() {
    java.util.ArrayList key = new java.util.ArrayList(2);
    key.add(getParent());
    key.add(new Integer(getParent().getIndexOfChild(this)));
    state().debugRewrite.remove(key);
  }
$endif
$if(StagedRewrites)
  /**
   * @apilevel internal
   */
  public int ASTNode.is$$Final = 0;
  /**
   * @apilevel internal
   */
  public boolean ASTNode.is$$Final() { return is$$Final >= state().rewritePhase; }
  /**
   * @apilevel internal
   */
  public void ASTNode.is$$Final(int phase) { is$$Final = phase; }
  /**
   * @apilevel internal
   */
  public void ASTNode.enterRewritePhase(int phase) { state().rewritePhase = phase; }
  /**
   * @apilevel internal
   */
  public boolean ASTNode.inRewritePhase(int phase) { return state().rewritePhase >= phase; }
$else
  /**
   * @apilevel internal
   */
  public boolean ASTNode.is$$Final = false;
  /**
   * @apilevel internal
   */
  public boolean ASTNode.is$$Final() { return is$$Final; }
  /**
   * @apilevel internal
   */
  public void ASTNode.is$$Final(boolean b) { is$$Final = b; }
$endif
$endif
]]

ASTNode.debugDecls = [[
$if(DebugMode)
  /**
   * @apilevel internal
   */
  protected boolean ASTNode.debugNodeAttachmentIsRoot() {
    return false;
  }

  /**
   * @apilevel internal
   */
  private static void ASTNode.debugNodeAttachment(ASTNode node) {
    if(node == null) {
      throw new RuntimeException("Trying to assign null to a tree child node");
    }

    while(node != null && !node.debugNodeAttachmentIsRoot()) {
$if(RewriteEnabled)
      if(node.in$$Circle())
        return;
$endif
      ASTNode parent = (ASTNode)node.parent;
      if(parent != null && parent.getIndexOfChild(node) == -1) {
        return;
      }
      node = parent;
    }

    if(node != null) {
      throw new RuntimeException("Trying to insert the same tree at multiple tree locations");
    }
  }
$endif
]]

ASTNode.iterator = [[
  /**
   * @apilevel low-level
   */
  public java.util.Iterator<T> ASTNode.iterator() {
    $SynchBegin
    return new java.util.Iterator<T>() {
      private int counter = 0;
      public boolean hasNext() {
        return counter < getNumChild();
      }
      @SuppressWarnings("unchecked") public T next() {
        if(hasNext())
          return (T)getChild(counter++);
        else
          return null;
      }
      public void remove() {
        throw new UnsupportedOperationException();
      }
    };
    $SynchEnd
  }
]]

ASTNode.setParent = [[
  /**
   * @apilevel low-level
   */
  public void ASTNode.setParent(ASTNode node) {
    $SynchBegin
    $include(ASTNode.incHookSetParent)
    parent = node;
    $SynchEnd
  }
]]

ASTNode.getParent = [[
  /**
   * @apilevel low-level
   */
  public ASTNode ASTNode.getParent() {
    $SynchBegin
$if(RewriteEnabled)
    if(parent != null && ((ASTNode)parent).is$$Final() != is$$Final()) {
      state().boundariesCrossed++;
    }
$endif
    $include(ASTNode.incHookGetParent);
    return (ASTNode)parent;
    $SynchEnd
  }
]]

ASTNode.addChild = [[
  /**
    * @apilevel low-level
    */
$if(Java5)
  public void ASTNode.addChild(T node) {
$else
  public void ASTNode.addChild(ASTNode node) {
$endif
    setChild(node, getNumChildNoTransform());
    $include(ASTNode.incHookAddChild) 
  }
]]

ASTNode.numChildren = [[
  /**
   * @apilevel low-level
   */
   protected int ASTNode.numChildren;
   
  /**
   * @apilevel low-level
   */
  protected int ASTNode.numChildren() {
    $include(ASTNode.incHookNumChildren)
    return numChildren;
  }
  
  /**
    * @apilevel low-level
    */
  public int ASTNode.getNumChild() {
    $SynchBegin
    return numChildren();
    $SynchEnd
  }
  
  /**
    * <p><em>This method does not invoke AST transformations.</em></p>
    * @apilevel low-level
    */
  public final int ASTNode.getNumChildNoTransform() {
    $SynchBegin
    return numChildren();
    $SynchEnd
  }
]]

ASTNode.setChild = [[
  /**
    * @apilevel low-level
    */
  public void ASTNode.setChild(ASTNode node, int i) {
    $SynchBegin
$if(DebugMode)
    debugNodeAttachment(node);
$endif
    $include(ASTNode.incHookSetChild1)
    if(children == null) {
      children = new ASTNode[#initialChildArraySize];
      $include(ASTNode.incHookSetChild2)
    } else if (i >= children.length) {
      ASTNode c[] = new ASTNode[i << 1];
      System.arraycopy(children, 0, c, 0, children.length);
      children = c;
      $include(ASTNode.incHookSetChild3)
      $include(ASTNode.flushHookSetChildCopyState)
    }
    $include(ASTNode.incHookSetChild4)
    children[i] = node;
    if(i >= numChildren) {
      numChildren = i+1;
    }
    if(node != null) { 
      node.setParent(this); 
      node.childIndex = i; 
    }
    $include(ASTNode.incHookSetChild5)
    $include(ASTNode.flushHookSetChildInitState)
    $SynchEnd
  }
]]
