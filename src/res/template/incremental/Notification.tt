# Copyright (c) 2013, The JastAdd Team
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright notice,
#       this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the Lund University nor the names of its
#       contributors may be used to endorse or promote products derived from
#       this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

ASTDecl.incValueAffectedMethod = [[
$if(IncrementalEnabled)

$if(IncrementalLevelParam)
$if(IncrementalPropLimit)
  /**
   * @apilevel internal
   */
  public boolean #name.inc_valueAffected(String attrID, Object _parameters) {
    $AttrAffectedChecks
    $if(IsAstNode)
    return true;      
    $else
    return super.inc_valueAffected(attrID, _parameters);
    $endif      
  }
$endif
$endif
    
$endif
]]

# TODO: Add support for more than one parameter
ASTDecl.checkAttrValueAffected = [[
$if(IsNTA)
// NTAs are always considered affected
$if(IsParamAttr)
if (attrID.equals("$AttrSign") && $(AttrSign)_values != null && $(AttrSign)_values.containsKey(_parameters)) {
$else
if (attrID.equals("$AttrSign") && $(AttrSign)_computed) {
$endif
  return true;  
}                    
$else
// non-NTAs
$if(IsParamAttr)
if (attrID.equals("$AttrSign") && $(AttrSign)_values != null && $(AttrSign)_values.containsKey(_parameters)) {
  $if(IsPrimitiveAttr)
  // store old value
  $AttrType oldValue = $AttrObjectType.valueOf(($AttrObjectType)$(AttrSign)_values.get(_parameters));
  // flush value
  $(AttrSign)_values.remove(_parameters); 
  // clear dependencies in handler
  $DDGNodeName handler = ($DDGNodeName)$(AttrSign)_handler.get(_parameters);
  handler.clearDependencies();
  // compute new value
  $if(IsAttrWithOneParam)
  $(AttrType) newValue = $AttrName(($ParamTypeSignature)_parameters);
  $else
  throw new Error("No support for more than one parameter in affected value check");
  $endif
  $else
  // store old value
  $AttrType oldValue = ($AttrType)$(AttrSign)_values.get(_parameters);
  // flush value
  $(AttrSign)_values.remove(_parameters); 
  // clear dependencies in handler
  $DDGNodeName handler = ($DDGNodeName)$(AttrSign)_handler.get(_parameters);
  handler.clearDependencies();
  // compute new value
  $if(IsAttrWithOneParam)
  $AttrType newValue = $(AttrName)(($ParamTypeSignature)_parameters);
  $else
  throw new Error("No support for more than one parameter in affected value check");
  $endif
  $endif
  
$else
if (attrID.equals("$AttrSign") && $(AttrSign)_computed) {
  // store old value + flush value
  $AttrType oldValue = $(AttrSign)_value;
  $AttrResetVisit
  $AttrResetCache
  // clear dependencies in handler  
  $(AttrSign)_handler.clearDependencies();
  // compute new value
  $AttrType newValue = $AttrName();
$endif
  
  // compare old and new value
  $if(IsPrimitiveAttr)
  if (oldValue == newValue) {
  $else
  Object obj = (Object)oldValue;
  if ((obj instanceof ASTNode && (oldValue == newValue)) || 
      (oldValue == null && newValue == null) || 
      (oldValue != null && oldValue.equals(newValue))) {
  $endif
    return false;
  }
  return true;
}
$endif
]]

ASTDecl.incReactToDepChangeMethod = [[
$if(IncrementalEnabled)

$if(IncrementalLevelParam)
  /**
   * @api internal
   */
  public void #name.reactToDependencyChange(String attrID, Object _parameters) {
    $if(IncrementalChangeFlush)
    $include(ASTDecl.incChangeFlush)
    $endif
    $if(!IsAstNode)
    super.reactToDependencyChange(attrID, _parameters);      
    $endif
  }
$endif

$if(IncrementalLevelAttr)
  /**
   * @api internal
   */ 
  public void #name.reactToDependencyChange(String attrID) {
    $if(IncrementalChangeFlush)
    $include(ASTDecl.incChangeFlush)
    $endif
    $if(!IsAstNode)
    super.reactToDependencyChange(attrID);   
    $endif
  }
$endif

$if(IncrementalLevelNode) 
$if(IsAstNode)
  /**
   * @api internal
   */
  public void #name.reactToDependencyChange() {
    $if(IncrementalChangeFlush)
    $include(ASTDecl.incChangeFlush)
    $endif
  }
$endif
$endif
      
$if(IncrementalLevelRegion)
$if(#isRegionRoot)
  /**
   * @api internal
   */
  public void #name.reactToDependencyChange() {
    $if(IncrementalChangeFlush)
    $include(ASTDecl.incChangeFlush)
    $endif
  }
$else
  $if(IsAstNode)
  /**
   * @api internal
   */
  public void #name.reactToDependencyChange() {
  }
  $endif
$endif    
$endif

$endif
]]

ASTDecl.incChangeFlush = [[
$if(IncrementalChangeFlush)

// flush children
$if(IncrementalLevelParam)
$if(IsAstNode)
if (attrID.equals("getChild")) {
  int i = (Integer)_parameters;
  if (rewritten_children != null && i < rewritten_children.length && rewritten_children[i]) {
    // Make sure this condition is false before calling notify. 
    // There may be a circular dependency resulting in a double flush otherwise. 
    // A double flush will cause null to be moved in as the initial child.
    rewritten_children[i] = false;
    children[i].inc_resetRewrites();
    // outer rewrites
    if (init_children[i] != null) {
      // set up change
      ASTNode oldChild = children[i];
      ASTNode newChild = init_children[i];
      // make change
      oldChild.inc_flush_subtree(getChild_handler[i]);
      children[i] = newChild;
      init_children[i] = null;
      // set parent and notify
      newChild.setParent(this);
      getChild_handler[i].notifyDependencies();    
    } else {
      // inner rewrites
      inc_restoreEnclosingRewrite();
    }
  }
}
$endif
$endif

$if(IncrementalLevelAttr)
$if(IsAstNode)
if (attrID.equals("getChild")) {
  if (inc_checkRegionForInnerRewrite()) {
    ASTNode enclosingNode = inc_locateEnclosingRewrittenNode();
    enclosingNode.getChild_handler.flushRegion();
    return;
  } else {
    inc_flushRegion_rewrites();
    getChild_handler.notifyDependencies();
    return;
  }
}
$endif
$endif
    
$if(IncrementalLevelNode)
inc_flushRegionRoot();
handler.notifyDependencies();
$endif

$if(IncrementalLevelRegion)
$if(#isRegionRoot)
if (inc_flushRegionRoot()) {
  handler.clearDependencies();
  handler.notifyDependencies();      
}
$endif
$endif

$AttrFlushChecks    

$endif
]]

ASTDecl.attrFlushCheck = [[
$if(IncrementalLevelParam)
$if(IsParamAttr)
if (attrID.equals("$AttrSign") && $(AttrSign)_values != null && $(AttrSign)_values.containsKey(_parameters)) {
  $if(IsNTA)
  $AttrType value = ($AttrType)$(AttrSign)_values.remove(_parameters);                 
  for (int i = 0; i < $(AttrSign)_list.children.length; i++) {
    ASTNode child = $(AttrSign)_list.children[i];
    if (child != null && value == child) {
      // using dummy node to flush dependencies from NTA 
      value.inc_flush_subtree(($DDGNodeName)$(AttrSign)_handler.get(_parameters));
      $(AttrSign)_list.removeChild(i);
      break;
    }
  }
  $else
  $(AttrSign)_values.remove(_parameters); 
  $endif
  $DDGNodeName handler = ($DDGNodeName)$(AttrSign)_handler.remove(_parameters);
  handler.throwAway();
  handler.notifyDependencies();
  $if(!IsAstNode)
  super.reactToDependencyChange(attrID, _parameters);
  $endif
  return;
}                  
$else
if (attrID.equals("$AttrSign") && $(AttrSign)_computed) {
  $if(IsNTA)
  if ($(AttrSign)_value instanceof ASTNode) {
    $(AttrSign)_value.setParent(null);
    // using dummy node to flush dependencies from NTA 
    $(AttrSign)_value.inc_flush_subtree($(AttrSign)_handler);
  }
  $endif
  $AttrResetVisit
  $AttrResetCache
  $(AttrSign)_handler.notifyDependencies();
  $if(!IsAstNode)
  super.reactToDependencyChange(attrID, _parameters);
  $endif
  return;
}
$endif      
$endif

$if(IncrementalLevelAttr)
$if(IsParamAttr)
if (attrID.equals("$AttrSign") && $(AttrSign)_values != null && !$(AttrSign)_values.isEmpty()) {
  $if(IsNTA)
  if ($(AttrSign)_list != null) {
    $(AttrSign)_list.setParent(null);
    // using dummy node to flush dependencies from NTA 
    $(AttrSign)_list.inc_flush_subtree($(AttrSign)_handler);
  }
  $endif
  $AttrResetVisit
  $AttrResetCache
  $(AttrSign)_handler.notifyDependencies();
  $if(!IsAstNode)
  super.reactToDependencyChange(attrID);
  $endif
  return;
}
$else
if (attrID.equals("$AttrSign") && $(AttrSign)_computed) {
  $if(IsNTA)
  if ($(AttrSign)_value instanceof ASTNode) {
    $(AttrSign)_value.setParent(null);
    // using dummy node to flush dependencies from NTA 
    $(AttrSign)_value.inc_flush_subtree(new $DDGNodeName(new Opt(), ""));
  }
  $endif
  $AttrResetVisit
  $AttrResetCache
  $(AttrSign)_handler.notifyDependencies();
  $if(!IsAstNode)
  super.reactToDependencyChange(attrID);
  $endif
  return;
}
$endif
$endif
]]

ASTDecl.incFlushMethod = [[
$if(IncrementalEnabled)
$if(IncrementalChangeFlush)
$if(IncrementalLevelNode)
  /**
   * @api internal
   */
  public void #name.inc_flush() {
    $FlushAttrs
$if(!IsAstNode)
    super.inc_flush();
$endif
  }        
$endif
$if(IncrementalLevelRegion)
  /**
   * @api internal
   */
  public void #name.inc_flush() {
    $FlushAttrs
$if(!IsAstNode)
    super.inc_flush();
$endif
  }        
$endif
$endif
$endif
]]

ASTDecl.attrFlush = [[
$if(IsNTA)
$if(IncrementalLevelRegion)
// TODO: Add a flush of non-region root NTA children
$endif
$else
$if(IsParamAttr)
if ($(AttrSign)_values != null && !$(AttrSign)_values.isEmpty()) {
  $AttrResetVisit
  $AttrResetCache
}
$else
$AttrResetVisit
$AttrResetCache
$endif
$endif
]]

ASTNode.incFlushChildMethod = [[
$if(IncrementalEnabled)
$if(IncrementalChangeFlush)
$if(IsAstNode)

$if(IncrementalLevelNode)
  /**
   * @api internal
   */
  public boolean ASTNode.inc_flush_child(ASTNode node) {
    for (int i = 0; node.mayHaveRewrite() && i < children.length; i++) {        
      if (children[i] == node) {
        return inc_restoreInitialForIndex(i, node.handler());
      }
    }
    return true;
  }  
$endif

$if(IncrementalLevelRegion)
  /**
   * @api internal
   */
  public boolean ASTNode.inc_flush_child(ASTNode node) {
    for (int i = 0; node.mayHaveRewrite() && i < children.length; i++) {        
      if (children[i] == node) {
        return inc_restoreInitialForIndex(i, node.handler());
      }
    }
    return true;
  }  
$endif
      
$endif
$endif
$endif
]]

ASTDecl.incFlushNTAMethod = [[
$if(IncrementalEnabled)
$if(IncrementalChangeFlush)

$if(IncrementalLevelNode)
  /**
   * @api internal
   */
  public boolean #name.inc_flush_NTA(ASTNode node) {
  $if(IsListNode)
    if (inc_internalNTAList) {
      state().enterConstruction();
      int childIndex = getIndexOfChild(node);
      removeChild(childIndex);
      node.inc_flush_subtree(node.handler());
      node.handler().clearDependencies();
      state().exitConstruction();
      if (inc_internalNTAList_map.containsValue(node)) {
        for (java.util.Iterator itr = inc_internalNTAList_map.keySet().iterator(); itr.hasNext();) {
          Object key = itr.next();
          if (inc_internalNTAList_map.get(key) == node) {
            inc_internalNTAList_map.remove(key);
            break;
          }
        }
      }
      return true;
    }
    if (parent != null) {
      int index = parent.getIndexOfChild(this);
      if (index >= 0 && parent.childIsNTA(index)) {
        state().enterConstruction();
        int childIndex = getIndexOfChild(node);
        removeChild(childIndex);
        node.inc_flush_subtree(node.handler());
        node.handler().clearDependencies();
        state().exitConstruction();
        return true;
      }
      return false;
    }
  $else
    $if(IsOptNode)
    if (parent != null) {
      int index = parent.getIndexOfChild(this);
      if (index >= 0 && parent.childIsNTA(index)) {
        state().enterConstruction();
        node.setParent(null);
        node.inc_flush_subtree(node.handler());
        node.handler().clearDependencies();
        state().exitConstruction();
        return true;
      }
      return false;
    }
    $else
    $FlushNTAs  
    $endif
  $endif
    return false;
  }
$endif

$if(IncrementalLevelRegion)
  /**
   * @api internal
   */
  public boolean #name.inc_flush_NTA(ASTNode node) {
  $if(IsListNode)
    if (inc_internalNTAList) {
      state().enterConstruction();
      int childIndex = getIndexOfChild(node);
      removeChild(childIndex);
      node.inc_flush_subtree(node.handler());
      node.handler().clearDependencies();
      state().exitConstruction();
      if (inc_internalNTAList_map.containsValue(node)) {
        for (java.util.Iterator itr = inc_internalNTAList_map.keySet().iterator(); itr.hasNext();) {
          Object key = itr.next();
          if (inc_internalNTAList_map.get(key) == node) {
            inc_internalNTAList_map.remove(key);
            break;
          }
        }
      }
      return true;
    }
    if (parent != null) {
      int index = parent.getIndexOfChild(this);
      if (index >= 0 && parent.childIsNTA(index)) {
        state().enterConstruction();
        int childIndex = getIndexOfChild(node);
        removeChild(childIndex);
        node.inc_flush_subtree(node.handler());
        node.handler().clearDependencies();
        state().exitConstruction();
        return true;
      }
      return false;
    }
  $else
    $if(IsOptNode)
    if (parent != null) {
      int index = parent.getIndexOfChild(this);
      if (index >= 0 && parent.childIsNTA(index)) {
        state().enterConstruction();
        node.setParent(null);
        node.inc_flush_subtree(node.handler());
        node.handler().clearDependencies();
        state().exitConstruction();
        return true;
      }
      return false;
    }
    $else
    $FlushNTAs  
    $endif
  $endif
    return false;
  }
$endif
      
$endif
$endif
]]

ASTDecl.ntaFlush = [[
if ($(AttrSign)_value == node) {
  state().enterConstruction();
  $(AttrSign)_value.setParent(null);
  state().exitConstruction();
  $(AttrSign)_value.inc_flush_subtree(node.handler());
  node.handler().clearDependencies();
  $AttrResetVisit
  $AttrResetCache
}
]]

ASTDecl.incFlushRegionRootMethod = [[
$if(IncrementalEnabled)
$if(IncrementalChangeFlush)

$if(IncrementalLevelRegion)
$if(#isRegionRoot)
  /**
   * @api internal
   */
  public boolean #name.inc_flushRegionRoot() {
    // Check for rewrites
    // check for inner rewrite in region root
    boolean rewriteFlushed = true;
    if (parent != null) {
      rewriteFlushed = parent.inc_flush_child(this);
      // region root had an outer rewrite which was flushed (parent == null) -> done
      if (rewriteFlushed && parent == null) {
        return true;
      }
    }
    boolean innerRewrite = false;
    if (rewriteFlushed) {
      // the region may have inner rewrites
      innerRewrite = inc_checkRegionForInnerRewrite();
    } else {
      // region root had an inner rewrite which wasn't flushed
      innerRewrite = true;
    }
    // Inner rewrites in the region (including the root) means abort and notify the enclosing rewritten node
    if (innerRewrite) {
      ASTNode enclosingNode = inc_locateEnclosingRewrittenNode();
      enclosingNode.handler().flushRegion();
      return false;
    }
    // Check NTAs, this may remove the region
    boolean regionRemoved = false;
    if (parent != null) {
      regionRemoved = parent.inc_flush_NTA(this);     // check NTA
    }
    // region is still here, flush remaining values and outer rewrites
    if (!regionRemoved) {
      inc_flushRegion_rewrites();
      inc_flushRegion();
    }
    return true; 
  } 
$else
$if(IsAstNode)
  /**
   * @api internal
   */
  public boolean #name.inc_flushRegionRoot() {
    // Check for rewrites
    // check for inner rewrite in region root
    boolean rewriteFlushed = true;
    if (parent != null) {
      rewriteFlushed = parent.inc_flush_child(this);
      // region root had an outer rewrite which was flushed (parent == null) -> done
      if (rewriteFlushed && parent == null) {
        return true;
      }
    }
    boolean innerRewrite = false;
    if (rewriteFlushed) {
      // the region may have inner rewrites
      innerRewrite = inc_checkRegionForInnerRewrite();
    } else {
      // region root had an inner rewrite which wasn't flushed
      innerRewrite = true;
    }
    // Inner rewrites in the region (including the root) means abort and notify the enclosing rewritten node
    if (innerRewrite) {
      ASTNode enclosingNode = inc_locateEnclosingRewrittenNode();
      enclosingNode.handler().flushRegion();
      return false;
    }
    // Check NTAs, this may remove the region
    boolean regionRemoved = false;
    if (parent != null) {
      regionRemoved = parent.inc_flush_NTA(this);     // check NTA
    }
    // region is still here, flush remaining values and outer rewrites
    if (!regionRemoved) {
      inc_flushRegion_rewrites();
      inc_flushRegion();
    }
    return true; 
  } 
$endif
$endif
$endif

$if(IncrementalLevelNode)
$if(IsAstNode)
  /**
   * @api internal
   */
  public boolean ASTNode.inc_flushRegionRoot() {
    inc_flush();
    boolean rewriteFlushed = true;
    if (parent != null) {
      rewriteFlushed = parent.inc_flush_child(this);
      // region root had an outer rewrite which was flushed (parent == null) -> done
      if (rewriteFlushed && parent == null) {
        return true;
      }
    }
    if (!rewriteFlushed) {
      ASTNode enclosingNode = inc_locateEnclosingRewrittenNode();
      enclosingNode.handler().flushRegion();
      return false;
    }
    if (parent != null) {
      parent.inc_flush_NTA(this);     // check NTA
    }
    return true; 
  } 
$endif
$endif
      
$endif
$endif
]]

ASTNode.incCheckRegionForInnerRewriteMethod = [[
$if(IncrementalEnabled)
$if(IncrementalChangeFlush)

$if(IncrementalLevelRegion)
$if(IsAstNode)
  /**
   * @api internal
   */
  public boolean ASTNode.inc_checkRegionForInnerRewrite() {
    for (int i = 0; children != null && rewritten_children != null && i < children.length && i < rewritten_children.length; i++) {
      ASTNode child = children[i];
      if (child != null && !child.isRegionRoot()) {
        if (rewritten_children[i]) {
          if (init_children != null && i < init_children.length && init_children[i] == null) {
            return true;
          }
        } else {
          if (child.inc_checkRegionForInnerRewrite()) {
            return true;
          }
        }
      }
    }
    return false;
  }
$endif
$endif

$if(IncrementalLevelNode)
$if(IsAstNode)
  /**
   * @api internal
   */
  public boolean ASTNode.inc_checkRegionForInnerRewrite() {
    for (int i = 0; children != null && rewritten_children != null && i < children.length && i < rewritten_children.length; i++) {
      ASTNode child = children[i];
      if (child != null && !child.isRegionRoot()) {
        if (rewritten_children[i]) {
          if (init_children != null && i < init_children.length && init_children[i] == null) {
            return true;
          }
        } else {
          if (child.inc_checkRegionForInnerRewrite()) {
            return true;
          }
        }
      }
    }
    return false;
  }
$endif
$endif

$if(IncrementalLevelAttr)
$if(IsAstNode)
  /**
   * @api internal
   */
  public boolean ASTNode.inc_checkRegionForInnerRewrite() {
    for (int i = 0; children != null && rewritten_children != null && i < children.length && i < rewritten_children.length; i++) {
      ASTNode child = children[i];
      if (child != null) {
        if (rewritten_children[i]) {
          if (init_children != null && i < init_children.length && init_children[i] == null) {
            return true;
          }
        }
      }
    }
    return false;
  }
$endif
$endif

$endif
$endif
]]

ASTDecl.incFlushRegionMethod = [[
$if(IncrementalEnabled)
$if(IncrementalChangeFlush)
$if(IncrementalLevelRegion)
  /**
   * @api internal
   */
  public void #name.inc_flushRegion() {
  $if(IsAstNode)
    inc_flush();
    for (int i = 0; children != null && i < children.length; i++) {
      ASTNode child = children[i];
      if (child != null && !child.isRegionRoot()) {
        child.inc_flushRegion();
      }
    }
  $else
    super.inc_flushRegion();
  $endif
    $FlushNTAsInRegion
  }
$endif
$endif
$endif
]]

ASTDecl.flushNTAsInRegion = [[
$if(IncrementalEnabled)
$if(IncrementalChangeFlush)

$if(IsNTA)
$if(IsParamAttr)
if ($(AttrSign)_list != null) {
  for (int index = 0; index < $(AttrSign)_list.numChildren; index++) {
    ASTNode value = $(AttrSign)_list.children[index];              
    if (!value.isRegionRoot()) {
      state().enterConstruction();
      $(AttrSign)_list.removeChild(index);
      // removeChild will decrease the index of all remaining children and numChildren
      // hence, to visit the remainder of the list index need to be decreased by one for each removeChild
      index--; 
      state().exitConstruction();
      value.inc_flush_subtree(handler());
      // remove the value in the NTA values map
      for (java.util.Iterator itr = $(AttrSign)_values.keySet().iterator(); itr.hasNext();) {
        Object key = itr.next();
        if ($(AttrSign)_values.get(key) == value) {
          $(AttrSign)_values.remove(key);
          break;
        }
      }
    }
  }
}
$else
$if(IsNtaWithTree)
if ($(AttrSign)_value != null && !$(AttrSign)_value.isRegionRoot()) {
  state().enterConstruction();
  $(AttrSign)_value.setParent(null);
  state().exitConstruction();
  $(AttrSign)_value.inc_flush_subtree(handler());
  $AttrResetVisit
  $AttrResetCache
}
$endif
$endif
$endif

$endif
$endif
]]

ASTNode.incFlushRegionRewritesMethod = [[
$if(IncrementalEnabled)
$if(IncrementalChangeFlush)

$if(IncrementalLevelRegion)
$if(IsAstNode)
  /**
   * @api internal
   */
  public boolean ASTNode.inc_flushRegion_rewrites() {
    for (int i = 0; children != null && i < children.length; i++) { 
      ASTNode child = children[i];
      if (child == null || child.isRegionRoot()) {
        continue;
      }
      // rewritten child
      if (rewritten_children != null && i < rewritten_children.length && rewritten_children[i]) {
        if (!inc_restoreInitialForIndex(i, handler())) {
          return false;
        }
      } else {
        // not rewritten child
        if (!child.inc_flushRegion_rewrites()) {
          return false;
        }
      }
    } 
    return true;
  } 
$endif
$endif

$if(IncrementalLevelAttr)
$if(IsAstNode)
  /**
   * @api internal
   */
  public boolean ASTNode.inc_flushRegion_rewrites() {
    for (int i = 0; children != null && i < children.length; i++) { 
      ASTNode child = children[i];
      if (child == null) {
        continue;
      }
      // rewritten child
      if (rewritten_children != null && i < rewritten_children.length && rewritten_children[i]) {
        if (!inc_restoreInitialForIndex(i, getChild_handler)) {
          return false;
        }
      }
    } 
    return true;
  }
$endif
$endif

$endif
$endif
]]
