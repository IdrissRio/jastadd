State.incHook = [[
$if(IncrementalEnabled)

$if(IncrementalLevelRegion)
  public int IN_COMPUTATION = 0;
$endif

  protected java.util.Stack handlerAttrStack = new java.util.Stack();

//protected java.util.Stack handlerRewriteStack = new java.util.Stack();

  public void addHandlerDepTo(ASTNode$$DepGraphNode handler) {
    if (!IN_ATTR_STORE_EVAL || handler == null) {
//  if (!IN_ATTR_STORE_EVAL && !IN_REWRITE_EVAL || handler == null) {
      return;
    }
$if(IncrementalTrack)
    ASTNode$$DepGraphNode.trackedReads++;
$endif
    java.util.Stack handlerStack = handlerAttrStack;
//  if (IN_REWRITE_EVAL) 
//    handlerStack = handlerRewriteStack;
    if (!handlerStack.isEmpty()) {
      //throw new Error("Handler stack is empty at addition of dependency!");
      ASTNode$$DepGraphNode top = (ASTNode$$DepGraphNode)handlerStack.peek();
      handler.addDependant(top);

$if(IncrementalPropLimit)
      if (!handler.cacheInDependent)
        top.noCacheRead = false;
$endif
    }
  }

  public boolean IN_ATTR_STORE_EVAL = false;

  public void enterAttrStoreEval(ASTNode$$DepGraphNode handler) {
$if(IncrementalTrack)
    ASTNode$$DepGraphNode.trackedComputes++;
$endif
//  if (!IN_REWRITE_EVAL) {
    IN_ATTR_STORE_EVAL = true;
    //System.out.println("attr eval stack enter: " + handler.fAttrID);
    pushHandler(handlerAttrStack, handler);
//  }
  }

  public void exitAttrStoreEval(ASTNode$$DepGraphNode handler) {
//  if (!IN_REWRITE_EVAL) {
    popHandler(handlerAttrStack, handler);
    //System.out.println("attr eval stack exit: " + handler.fAttrID);
    IN_ATTR_STORE_EVAL = !handlerAttrStack.isEmpty();
//  }
  }

//public boolean IN_REWRITE_EVAL = false;

  public void enterRewriteEval(ASTNode$$DepGraphNode handler) {
    enterAttrStoreEval(handler);
//  if (grammar().incrementalTrack) {
//    ASTNode$$DepGraphNode.trackedComp++;
//  }
//  IN_REWRITE_EVAL = true;
//  pushHandler(handlerRewriteStack, handler);
  }

  public void exitRewriteEval(ASTNode$$DepGraphNode handler) {
    exitAttrStoreEval(handler);
//  if (IN_REWRITE_EVAL) {
//    popHandler(handlerRewriteStack, handler);
//    IN_REWRITE_EVAL = !handlerRewriteStack.isEmpty();
//  }
  }

  public boolean IN_CONSTRUCTION = false;

  private int inc_constructionCount = 0;

  public void enterConstruction() {
    IN_CONSTRUCTION = true;
    inc_constructionCount++;
  }

  public void exitConstruction() {
    inc_constructionCount--;
    if (inc_constructionCount == 0)
    IN_CONSTRUCTION = false;
  }

  protected void pushHandler(java.util.Stack stack, ASTNode$$DepGraphNode handler) {
$if(IncrementalPropLimit)
    // assume that evaluation will be clean from cached values
    handler.noCacheRead = true;
$endif
    stack.push(handler);
  }

  protected ASTNode$$DepGraphNode popHandler(java.util.Stack stack, ASTNode$$DepGraphNode handler) {
    if (stack.isEmpty())
      throw new Error("Handler stack is empty at exit!");
    ASTNode$$DepGraphNode h = (ASTNode$$DepGraphNode)stack.pop();
//  Skip this for now, deal with transitive dependencies later
//  if (grammar().incrementalPropLimit) {
//    h.setCacheInDependent(h.noCacheRead);
//    if (!stack.isEmpty()) {
//      ASTNode$$DepGraphNode top = (ASTNode$$DepGraphNode)stack.peek();
//      top.noCacheRead &= h.noCacheRead;
//    }
//  }
    if (h != handler)
      throw new Error("Top of handler stack does not match at pop!");
//    throw new Error("Top of handler stack does not match at pop! [" + handler.fAttrID + "]");
    return h;
  }
  
$endif
]]

State.incHookConstructionStart = [[
$if(IncrementalEnabled)
state().enterConstruction();
$endif
]]

State.incHookConstructionEnd = [[
$if(IncrementalEnabled)
state().exitConstruction();
$endif
]]