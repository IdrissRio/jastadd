aspect IncrementalEval {
  // ES_2011-10-05: Code generation for incremental evaluation, enter construction
  public String ASTDecl.genIncrementalConstructorStartConstruction() {
    return ind(2) + "state().enterConstruction();\n";
  }

  // ES_2011-10-05: Code generation for incremental evaluation, end construction
  public String ASTDecl.genIncrementalConstructorEndConstruction() {
    return ind(2) + "state().exitConstruction();\n";
  }

  // ES_2011-12-11: Code generation for incremental evaluation, track creation
  public String ASTDecl.genIncrementalTrackCreation() {
    if (ASTNode.incrementalLevelNode) {
      //return ind(2) + "state().addHandlerDepTo(handler);\n";
    }
    return "";
  }

  // ES_2011-11-23: Code generation for incremental evaluation, enter construction
  public String ListComponents.genIncrementalConstructorStartConstruction() {
    return ind(2) + "state().enterConstruction();\n";
  }

  // ES_2011-11-23: Code generation for incremental evaluation, end construction
  public String ListComponents.genIncrementalConstructorEndConstruction() {
    return ind(2) + "state().exitConstruction();\n";
  }

  // ES_2011-11-23: Code generation for incremental evaluation, enter construction
  public String OptionalComponent.genIncrementalConstructorStartConstruction() {
    return ind(2) + "state().enterConstruction();\n";
  }

  // ES_2011-11-23: Code generation for incremental evaluation, end construction
  public String OptionalComponent.genIncrementalConstructorEndConstruction() {
    return ind(2) + "state().exitConstruction();\n";
  }

  // ES_2011-11-23: Code generation for incremental evaluation, enter construction
  public String AggregateComponents.genIncrementalConstructorStartConstruction() {
    return ind(2) + "state().enterConstruction();\n";
  }

  // ES_2011-11-23: Code generation for incremental evaluation, end construction
  public String AggregateComponents.genIncrementalConstructorEndConstruction() {
    return ind(2) + "state().exitConstruction();\n";
  }

  // ES_2011-09-20: Code generation for incremental evaluation, evaluation stack
  public void Grammar.jjtGenIncrementalEvaluationStack(PrintWriter stream) {
    if (ASTNode.incrementalLevelRegion) {
    stream.println(ind + "public int IN_COMPUTATION = 0;");
    }
    stream.println(ind + "protected java.util.Stack handlerAttrStack = new java.util.Stack();");
//    stream.println(ind + "protected java.util.Stack handlerRewriteStack = new java.util.Stack();");
    stream.println(ind + "public void addHandlerDepTo(ASTNode$DepGraphNode handler) {");
    stream.println(ind(2) + "if (!IN_ATTR_STORE_EVAL || handler == null) {");
//    stream.println(ind(2) + "if (!IN_ATTR_STORE_EVAL && !IN_REWRITE_EVAL || handler == null) {");
    stream.println(ind(3) +   "return;");
    stream.println(ind(2) + "}");
    if (ASTNode.incrementalTrack) {
    stream.println(ind(2) + "ASTNode$DepGraphNode.trackedReads++;");
    }
    stream.println(ind(2) + "java.util.Stack handlerStack = handlerAttrStack;");
//    stream.println(ind(2) + "if (IN_REWRITE_EVAL) ");
//    stream.println(ind(3) +   "handlerStack = handlerRewriteStack;");
    stream.println(ind(2) + "if (!handlerStack.isEmpty()) {");
    stream.println(ind(3) +   "//throw new Error(\"Handler stack is empty at addition of dependency!\");");
    stream.println(ind(3) +   "ASTNode$DepGraphNode top = (ASTNode$DepGraphNode)handlerStack.peek();");
    stream.println(ind(3) +   "handler.addDependant(top);");
    if (ASTNode.incrementalPropLimit) {
    stream.println(ind(3) +   "if (!handler.cacheInDependent)");
    stream.println(ind(4) +     "top.noCacheRead = false;");
    }
    stream.println(ind(2) + "}");
    stream.println(ind + "}");
    stream.println(ind + "public boolean IN_ATTR_STORE_EVAL = false;");
    stream.println(ind + "public void enterAttrStoreEval(ASTNode$DepGraphNode handler) {"); 
    if (ASTNode.incrementalTrack) {
    stream.println(ind(2) + "ASTNode$DepGraphNode.trackedComputes++;");
    }
//    stream.println(ind(2) + "if (!IN_REWRITE_EVAL) {");
    stream.println(ind(3) +   "IN_ATTR_STORE_EVAL = true;");
    stream.println(ind(3) +   "//System.out.println(\"attr eval stack enter: \" + handler.fAttrID);");
    stream.println(ind(3) +   "pushHandler(handlerAttrStack, handler);");
//    stream.println(ind(2) + "}");
    stream.println(ind + "}"); 
    stream.println(ind + "public void exitAttrStoreEval(ASTNode$DepGraphNode handler) {"); 
//    stream.println(ind(2) + "if (!IN_REWRITE_EVAL) {");
    stream.println(ind(3) +   "popHandler(handlerAttrStack, handler);");
    stream.println(ind(3) +   "//System.out.println(\"attr eval stack exit: \" + handler.fAttrID);");
    stream.println(ind(3) +   "IN_ATTR_STORE_EVAL = !handlerAttrStack.isEmpty();");
//    stream.println(ind(2) + "}");
    stream.println(ind + "}"); 
//    stream.println(ind + "public boolean IN_REWRITE_EVAL = false;");
    stream.println(ind + "public void enterRewriteEval(ASTNode$DepGraphNode handler) {"); 
    stream.println(ind(2) + "enterAttrStoreEval(handler);");
//    if (ASTNode.incrementalTrack) {
//    stream.println(ind(2) + "ASTNode$DepGraphNode.trackedComp++;");
//    }
//    stream.println(ind(2) + "IN_REWRITE_EVAL = true;");
//    stream.println(ind(2) + "pushHandler(handlerRewriteStack, handler);");
    stream.println(ind + "}"); 
    stream.println(ind + "public void exitRewriteEval(ASTNode$DepGraphNode handler) {"); 
    stream.println(ind(2) + "exitAttrStoreEval(handler);");
//    stream.println(ind(2) + "if (IN_REWRITE_EVAL) {");
//    stream.println(ind(3) +   "popHandler(handlerRewriteStack, handler);");
//    stream.println(ind(3) +   "IN_REWRITE_EVAL = !handlerRewriteStack.isEmpty();");
//    stream.println(ind(2) + "}");
    stream.println(ind + "}"); 
    stream.println(ind + "public boolean IN_CONSTRUCTION = false;");
    stream.println(ind + "private int inc_constructionCount = 0;");
    stream.println(ind + "public void enterConstruction() {"); 
    stream.println(ind(2) + "IN_CONSTRUCTION = true;");
    stream.println(ind(2) + "inc_constructionCount++;");
    stream.println(ind + "}"); 
    stream.println(ind + "public void exitConstruction() {"); 
    stream.println(ind(2) + "inc_constructionCount--;");
    stream.println(ind(2) + "if (inc_constructionCount == 0)");
    stream.println(ind(3) +   "IN_CONSTRUCTION = false;");
    stream.println(ind + "}"); 
    stream.println(ind + "protected void pushHandler(java.util.Stack stack, ASTNode$DepGraphNode handler) {");
    if (ASTNode.incrementalPropLimit) {
    stream.println(ind(2) + "// assume that evaluation will be clean from cached values");
    stream.println(ind(2) + "handler.noCacheRead = true;");
    }
    stream.println(ind(2) + "stack.push(handler);");
    stream.println(ind + "}");        
    stream.println(ind + "protected ASTNode$DepGraphNode popHandler(java.util.Stack stack, ASTNode$DepGraphNode handler) {");
    stream.println(ind(2) + "if (stack.isEmpty())");
    stream.println(ind(3) +   "throw new Error(\"Handler stack is empty at exit!\");");
    stream.println(ind(2) + "ASTNode$DepGraphNode h = (ASTNode$DepGraphNode)stack.pop();");
    // Skip this for now, deal with transitive dependencies later
    //if (ASTNode.incrementalPropLimit) {
    //stream.println(ind(2) + "h.setCacheInDependent(h.noCacheRead);");
    //stream.println(ind(2) + "if (!stack.isEmpty()) {");
    //stream.println(ind(3) +   "ASTNode$DepGraphNode top = (ASTNode$DepGraphNode)stack.peek();");
    //stream.println(ind(3) +   "top.noCacheRead &= h.noCacheRead;");
    //stream.println(ind(2) + "}");
    //}
    stream.println(ind(2) + "if (h != handler)");
    stream.println(ind(3) +   "throw new Error(\"Top of handler stack does not match at pop!\");");
//    stream.println(ind(3) +   "throw new Error(\"Top of handler stack does not match at pop! [\" + handler.fAttrID + \"]\");");
    stream.println(ind(2) + "return h;");
    stream.println(ind + "}");
  }

  // ES_2011-12-10: Code generation for incremental evaluation, tracking rewrites
  public void ASTDecl.jjtGenIncrementalTrackRewrite5(PrintWriter stream) {
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(4) + "that.state().enterRewriteEval(node.handler);");
    }
    if (ASTNode.incrementalLevelRegion) {
      //stream.println(ind(4) + "that.state().IN_REWRITE_EVAL = true;");
      stream.println(ind(4) + "that.state().IN_COMPUTATION++;");
    }
  }
  // ES_2011-12-10: Code generation for incremental evaluation, tracking rewrites
  public void ASTDecl.jjtGenIncrementalTrackRewrite6(PrintWriter stream) {
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(4) + "that.state().exitRewriteEval(oldNode.handler);");
    }
    if (ASTNode.incrementalLevelRegion) {
      stream.println(ind(4) + "that.state().IN_COMPUTATION--;");
      //stream.println(ind(4) + "that.state().IN_REWRITE_EVAL = false;");
    }
  }
  // ES_2011-12-10: Code generation for incremental evaluation, tracking rewrites
  public void ASTDecl.jjtGenIncrementalTrackRewrite7(PrintWriter stream) {
    if (ASTNode.incrementalLevelNode || ASTNode.incrementalLevelRegion || 
          ASTNode.incrementalLevelAttr || ASTNode.incrementalLevelParam) {
      stream.println(ind(5) + "ASTNode initial = that.init_children[i];");
    }
  }
  // ES_2011-12-10: Code generation for incremental evaluation, tracking rewrites
  public void ASTDecl.jjtGenIncrementalTrackRewrite8(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(6) + "oldNode.inc_flush_subtree(that.getChild_handler[i]);");
      stream.println(ind(5) + "that.init_children[i] = initial;");
    }
    if (ASTNode.incrementalLevelAttr) {
      stream.println(ind(6) + "oldNode.inc_flush_subtree(that.getChild_handler);");
      stream.println(ind(5) + "that.init_children[i] = initial;");
    }
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(6) + "oldNode.inc_flush_subtree(node.handler());");
      stream.println(ind(5) + "that.init_children[i] = initial;");
    }
    if (ASTNode.incrementalLevelRegion) {
      stream.println(ind(5) + "if (node.isRegionRoot()) {");
      stream.println(ind(6) +   "oldNode.inc_flush_subtree(node.handler());");
      stream.println(ind(5) + "}");
      stream.println(ind(5) + "that.init_children[i] = initial;");
    }
  }
  // ES_2011-12-12_ Code generation for incremental evalutaion, crossing between regions
  public void ASTDecl.jjtGenIncrementalTrackRewrite9(PrintWriter stream) {
    if (ASTNode.incrementalLevelRegion) {
      if (isRegionRoot()) {
        stream.println(ind(2) + "ASTNode child = ASTNode.getChild(this, i);");
        stream.println(ind(2) + "if (state().IN_COMPUTATION > 0) {");
        stream.println(ind(3) +   "child.handler().addDependant(handler);");
        stream.println(ind(2) + "}");
        stream.println(ind(2) + "return (T)child;");
      } else {
        stream.println(ind(2) + "return (T)ASTNode.getChild(this, i);");
      }
    } else {
      stream.println(ind(2) + "return (T)ASTNode.getChild(this, i);");
    }
  }
  // ES_2011-12-12_ Code generation for incremental evalutaion, crossing between regions
  public void ASTDecl.jjtGenIncrementalTrackRewrite10(PrintWriter stream) {
    if (ASTNode.incrementalLevelRegion) {
      if (isRegionRoot()) {
        stream.println(ind(2) + "ASTNode child = ASTNode.getChild(this, i);");
        stream.println(ind(2) + "if (state().IN_COMPUTATION > 0) {");
        stream.println(ind(3) +   "child.handler().addDependant(handler);");
        stream.println(ind(2) + "}");
        stream.println(ind(2) + "return child;");
      } else {
        stream.println(ind(2) + "return ASTNode.getChild(this, i);");
      }
    } else {
      stream.println(ind(2) + "return ASTNode.getChild(this, i);");
    }
  }
  // ES_2011-09-20: Code generation for incremental evaluation, tracking rewrites
  public void ASTDecl.jjtGenIncrementalTrackRewrite1(PrintWriter stream) {
    if (!ASTNode.fullFlush) {
    stream.println(ind(2) + "if(that.init_children == null) {");
    stream.println(ind(3) +   "that.init_children = new ASTNode[that.children.length];");
    stream.println(ind(3) +   "that.rewritten_children = new boolean[that.children.length];");
    stream.println(ind(2) + "}");
    stream.println(ind(2) + "if(!node.inc_hasEnclosingRewrittenNode()) {");
    stream.println(ind(3) +   "that.init_children[i] = node.fullCopy();");
    stream.println(ind(3) +   "that.rewritten_children[i] = true;");
    stream.println(ind(2) + "}");
    }
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(2) + "that.state().enterRewriteEval(that.getChild_handler[i]);");
    }
    if (ASTNode.incrementalLevelAttr) {
      stream.println(ind(2) + "that.state().enterRewriteEval(that.getChild_handler);");
    }
  }
  // ES_2011-09-20: Code generation for incremental evaluation, tracking rewrites
  public void ASTDecl.jjtGenIncrementalTrackRewrite2(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(2) + "that.state().exitRewriteEval(that.getChild_handler[i]);");
    }
    if (ASTNode.incrementalLevelAttr) {
      stream.println(ind(2) + "that.state().exitRewriteEval(that.getChild_handler);");
    }
  }
  // ES_2011-09-30: Code generation for incremental evaluation, tracking rewrites
  public void ASTDecl.jjtGenIncrementalTrackRewrite3(PrintWriter stream) {
    if (!ASTNode.fullFlush) {
    stream.println(ind(4) + "if (rewriteState == ASTNode$State.REWRITE_CHANGE) {");
    stream.println(ind(5) +   "that.rewritten_children[i] = true;");
    stream.println(ind(4) + "}");
    }
  }

  // ES_2011-10-05: Code generation for incremental evaluation, tracking getChild
  public void ASTDecl.jjtGenIncrementalTrackRewrite4(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(3) + "if (that.getChild_handler[i] == null) {");
      if (ASTNode.incrementalPropLimit) {
      stream.println(ind(4) +   "that.getChild_handler[i] = new ASTNode$DepGraphNode(that, \"getChild\", new Integer(i), !node.mayHaveRewrite());");
      } else {
      stream.println(ind(4) +   "that.getChild_handler[i] = new ASTNode$DepGraphNode(that, \"getChild\", new Integer(i));");
      }
      stream.println(ind(3) + "}");
      stream.println(ind(3) + "that.state().addHandlerDepTo(that.getChild_handler[i]);");
    }
    if (ASTNode.incrementalLevelAttr) {
      stream.println(ind(2) + "that.state().addHandlerDepTo(that.getChild_handler);");  
    }
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(2) + "if (node != null) {");
      stream.println(ind(3) + "  that.state().addHandlerDepTo(node.handler);");
      stream.println(ind(2) + "}");
    }
  }
  // ES_2011-12-12: Code generation for incremental evaluation, tracking getChild
  public void ASTDecl.jjtGenIncrementalTrackRewrite11(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(3) + "if (that.getChild_handler[i] == null) {");
      if (ASTNode.incrementalPropLimit) {
      stream.println(ind(4) +   "that.getChild_handler[i] = new ASTNode$DepGraphNode(that, \"getChild\", new Integer(i), !node.mayHaveRewrite());");
      } else {
      stream.println(ind(4) +   "that.getChild_handler[i] = new ASTNode$DepGraphNode(that, \"getChild\", new Integer(i));");
      }
      stream.println(ind(3) + "}");
      stream.println(ind(3) + "that.state().addHandlerDepTo(that.getChild_handler[i]);");
    }
    if (ASTNode.incrementalLevelAttr) {
      stream.println(ind(2) + "that.state().addHandlerDepTo(that.getChild_handler);");  
    }
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(2) + "if (node != null) {");
      stream.println(ind(3) + "  that.state().addHandlerDepTo(node.handler);");
      // rewrite is evaluated in "that" and may use attributes in that node, but this is not tracked. 
      // The possibility of a dependency requires one.
      stream.println(ind(3) + "  that.handler.addDependant(node.handler);");
      stream.println(ind(2) + "}");
    }
    if (ASTNode.incrementalLevelRegion) {
      // rewrite is evaluated in "that" and may use attributes in that node, but this is not tracked. 
      // The possibility of a dependency requires one.
      stream.println(ind(2) + "if (node != null && node.isRegionRoot()) {");
      stream.println(ind(3) +   "that.handler().addDependant(node.handler());");
      stream.println(ind(3) +   "node.handler().addDependant(that.handler());");
      stream.println(ind(2) + "}");
    }
  }


  // ES_2011-12-13: Code generation for incremental evaluation, name getChildNoTransform
  public void ASTDecl.jjtGenIncrementalTrackGetChildNoTransformName1(PrintWriter stream) {
      stream.println(ind + "public ASTNode ASTNode.getChildNoTransform(int i) {");
  }
  // ES_2011-12-13: Code generation for incremental evaluation, name getChildNoTransform
  public void ASTDecl.jjtGenIncrementalTrackGetChildNoTransformName2(PrintWriter stream) {
      stream.println(ind + "public T ASTNode.getChildNoTransform(int i) {");
  }
  // ES_2011-09-20: Code generation for incremental evaluation, tracking getChild
  public void ASTDecl.jjtGenIncrementalTrackGetChildNoTransform(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(2) + "if (getChild_handler[i] == null) {");
      if (ASTNode.incrementalPropLimit) {
      stream.println(ind(4) +   "getChild_handler[i] = new ASTNode$DepGraphNode(this, \"getChild\", new Integer(i), !child.mayHaveRewrite());");
      } else {
      stream.println(ind(4) +   "getChild_handler[i] = new ASTNode$DepGraphNode(this, \"getChild\", new Integer(i));");
      }
      stream.println(ind(2) + "}");
      stream.println(ind(2) + "state().addHandlerDepTo(getChild_handler[i]);");
    }
    if (ASTNode.incrementalLevelAttr) {
      stream.println(ind(2) + "state().addHandlerDepTo(getChild_handler);");  
    }
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(2) + "if (child != null)");
      stream.println(ind(3) + "  state().addHandlerDepTo(child.handler);");
    }
    if (ASTNode.incrementalLevelRegion) {
      if (isRegionRoot()) {
        stream.println(ind(2) + "if (state().IN_COMPUTATION > 0 && child != null) {");
        stream.println(ind(3) + "  child.handler().addDependant(handler);");
        stream.println(ind(2) + "}");
      }
    }
  }
  // ES_2011-09-20: Code generation for incremental evaluation, tracking getParent
  public void ASTDecl.jjtGenIncrementalTrackGetParent(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
      stream.println(ind(2) + "state().addHandlerDepTo(getParent_handler);");
    }
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(2) + "if (parent != null)");
      stream.println(ind(3) +   "state().addHandlerDepTo(((ASTNode)parent).handler);");
    }
    if (ASTNode.incrementalLevelRegion) {
      if (isRegionRoot()) {
        stream.println(ind(2) + "if (state().IN_COMPUTATION > 0 && parent != null)");
        stream.println(ind(3) +   "parent.handler().addDependant(handler);");
      }
    }
  }
  // ES_2011-09-20: Code generation for incremental evaluation, tracking numChildren
  public void ASTDecl.jjtGenIncrementalTrackNumChild(PrintWriter stream) { 
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
      stream.println(ind(2) + "state().addHandlerDepTo(numChildren_handler);");
    }
  }

  // ES_2011-09-20: Code generation for incremental evaluation, modifying tree, set parent
  public void ASTDecl.jjtGenIncrementalSetParent(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr || ASTNode.incrementalLevelNode) {
//    stream.println(ind(2) + "if (!state().IN_CONSTRUCTION && !state().IN_REWRITE_EVAL && !state().IN_ATTR_STORE_EVAL) {");
    stream.println(ind(2) + "if (!state().IN_CONSTRUCTION && !state().IN_ATTR_STORE_EVAL) {");
    }
    if (ASTNode.incrementalLevelRegion) {
    stream.println(ind(2) + "if (!state().IN_CONSTRUCTION && !(state().IN_COMPUTATION > 0)) {");
    }
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
      stream.println(ind(3) + "getParent_handler.notifyDependencies();");
    }
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(2) + "if (parent != null) {");
      stream.println(ind(3) +   "parent.handler.flushRegion();");
      stream.println(ind(2) + "}");
    }
    if (ASTNode.incrementalLevelRegion) {
      stream.println(ind(2) + "if (parent != null) {");
      stream.println(ind(3) +   "parent.handler().flushRegion();");
      stream.println(ind(2) + "}");
    }
    stream.println(ind(2) + "}");
    stream.println(ind(2) + "if (parent != null) {");
    stream.println(ind(3) +   "int index = -1;");
    stream.println(ind(3) +   "for (int i = 0; parent.children != null && i < parent.children.length; i++) {");
    stream.println(ind(4) +     "if (parent.children[i] == this) {");
    stream.println(ind(5) +       "index = i;");
    stream.println(ind(5) +       "break;");
    stream.println(ind(4) +     "}");
    stream.println(ind(3) +   "}");
    stream.println(ind(3) +   "if (index >= 0)");
    stream.println(ind(4) +     "parent.removeChild(index);");
    stream.println(ind(2) + "}");
    stream.println(ind(2) + "if (node != null) {");
    stream.println(ind(3) +   "inc_changeState(node.inc_state);");
    stream.println(ind(2) + "} else inc_changeState(inc_GARBAGE);");
  }

}
