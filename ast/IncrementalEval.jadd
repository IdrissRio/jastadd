aspect IncrementalEval {
  // ES_2011-10-05: Code generation for incremental evaluation, enter construction
  public String ASTDecl.genIncrementalConstructorStartConstruction() {
    return ind(2) + "state().enterConstruction();\n";
  }

  // ES_2011-10-05: Code generation for incremental evaluation, end construction
  public String ASTDecl.genIncrementalConstructorEndConstruction() {
    return ind(2) + "state().exitConstruction();\n";
  }

  // ES_2011-12-11: Code generation for incremental evaluation, track creation
  public String ASTDecl.genIncrementalTrackCreation() {
    if (ASTNode.incrementalLevelNode) {
      //return ind(2) + "state().addHandlerDepTo(handler);\n";
    }
    return "";
  }

  // ES_2011-11-23: Code generation for incremental evaluation, enter construction
  public String ListComponents.genIncrementalConstructorStartConstruction() {
    return ind(2) + "state().enterConstruction();\n";
  }

  // ES_2011-11-23: Code generation for incremental evaluation, end construction
  public String ListComponents.genIncrementalConstructorEndConstruction() {
    return ind(2) + "state().exitConstruction();\n";
  }

  // ES_2011-11-23: Code generation for incremental evaluation, enter construction
  public String OptionalComponent.genIncrementalConstructorStartConstruction() {
    return ind(2) + "state().enterConstruction();\n";
  }

  // ES_2011-11-23: Code generation for incremental evaluation, end construction
  public String OptionalComponent.genIncrementalConstructorEndConstruction() {
    return ind(2) + "state().exitConstruction();\n";
  }

  // ES_2011-11-23: Code generation for incremental evaluation, enter construction
  public String AggregateComponents.genIncrementalConstructorStartConstruction() {
    return ind(2) + "state().enterConstruction();\n";
  }

  // ES_2011-11-23: Code generation for incremental evaluation, end construction
  public String AggregateComponents.genIncrementalConstructorEndConstruction() {
    return ind(2) + "state().exitConstruction();\n";
  }

  // ES_2011-09-20: Code generation for incremental evaluation, evaluation stack
  public void Grammar.jjtGenIncrementalEvaluationStack(PrintWriter stream) {
    if (ASTNode.incrementalLevelRegion) {
    stream.println(ind + "public int IN_COMPUTATION = 0;");
    }
    stream.println(ind + "protected java.util.Stack handlerAttrStack = new java.util.Stack();");
//    stream.println(ind + "protected java.util.Stack handlerRewriteStack = new java.util.Stack();");
    stream.println(ind + "public void addHandlerDepTo(ASTNode$DepGraphNode handler) {");
    stream.println(ind(2) + "if (!IN_ATTR_STORE_EVAL || handler == null) {");
//    stream.println(ind(2) + "if (!IN_ATTR_STORE_EVAL && !IN_REWRITE_EVAL || handler == null) {");
    stream.println(ind(3) +   "return;");
    stream.println(ind(2) + "}");
    if (ASTNode.incrementalTrack) {
    stream.println(ind(2) + "ASTNode$DepGraphNode.trackedReads++;");
    }
    stream.println(ind(2) + "java.util.Stack handlerStack = handlerAttrStack;");
//    stream.println(ind(2) + "if (IN_REWRITE_EVAL) ");
//    stream.println(ind(3) +   "handlerStack = handlerRewriteStack;");
    stream.println(ind(2) + "if (!handlerStack.isEmpty()) {");
    stream.println(ind(3) +   "//throw new Error(\"Handler stack is empty at addition of dependency!\");");
    stream.println(ind(3) +   "ASTNode$DepGraphNode top = (ASTNode$DepGraphNode)handlerStack.peek();");
    stream.println(ind(3) +   "handler.addDependant(top);");
    if (ASTNode.incrementalPropLimit) {
    stream.println(ind(3) +   "if (!handler.cacheInDependent)");
    stream.println(ind(4) +     "top.noCacheRead = false;");
    }
    stream.println(ind(2) + "}");
    stream.println(ind + "}");
    stream.println(ind + "public boolean IN_ATTR_STORE_EVAL = false;");
    stream.println(ind + "public void enterAttrStoreEval(ASTNode$DepGraphNode handler) {"); 
    if (ASTNode.incrementalTrack) {
    stream.println(ind(2) + "ASTNode$DepGraphNode.trackedComputes++;");
    }
//    stream.println(ind(2) + "if (!IN_REWRITE_EVAL) {");
    stream.println(ind(3) +   "IN_ATTR_STORE_EVAL = true;");
    stream.println(ind(3) +   "//System.out.println(\"attr eval stack enter: \" + handler.fAttrID);");
    stream.println(ind(3) +   "pushHandler(handlerAttrStack, handler);");
//    stream.println(ind(2) + "}");
    stream.println(ind + "}"); 
    stream.println(ind + "public void exitAttrStoreEval(ASTNode$DepGraphNode handler) {"); 
//    stream.println(ind(2) + "if (!IN_REWRITE_EVAL) {");
    stream.println(ind(3) +   "popHandler(handlerAttrStack, handler);");
    stream.println(ind(3) +   "//System.out.println(\"attr eval stack exit: \" + handler.fAttrID);");
    stream.println(ind(3) +   "IN_ATTR_STORE_EVAL = !handlerAttrStack.isEmpty();");
//    stream.println(ind(2) + "}");
    stream.println(ind + "}"); 
//    stream.println(ind + "public boolean IN_REWRITE_EVAL = false;");
    stream.println(ind + "public void enterRewriteEval(ASTNode$DepGraphNode handler) {"); 
    stream.println(ind(2) + "enterAttrStoreEval(handler);");
//    if (ASTNode.incrementalTrack) {
//    stream.println(ind(2) + "ASTNode$DepGraphNode.trackedComp++;");
//    }
//    stream.println(ind(2) + "IN_REWRITE_EVAL = true;");
//    stream.println(ind(2) + "pushHandler(handlerRewriteStack, handler);");
    stream.println(ind + "}"); 
    stream.println(ind + "public void exitRewriteEval(ASTNode$DepGraphNode handler) {"); 
    stream.println(ind(2) + "exitAttrStoreEval(handler);");
//    stream.println(ind(2) + "if (IN_REWRITE_EVAL) {");
//    stream.println(ind(3) +   "popHandler(handlerRewriteStack, handler);");
//    stream.println(ind(3) +   "IN_REWRITE_EVAL = !handlerRewriteStack.isEmpty();");
//    stream.println(ind(2) + "}");
    stream.println(ind + "}"); 
    stream.println(ind + "public boolean IN_CONSTRUCTION = false;");
    stream.println(ind + "private int inc_constructionCount = 0;");
    stream.println(ind + "public void enterConstruction() {"); 
    stream.println(ind(2) + "IN_CONSTRUCTION = true;");
    stream.println(ind(2) + "inc_constructionCount++;");
    stream.println(ind + "}"); 
    stream.println(ind + "public void exitConstruction() {"); 
    stream.println(ind(2) + "inc_constructionCount--;");
    stream.println(ind(2) + "if (inc_constructionCount == 0)");
    stream.println(ind(3) +   "IN_CONSTRUCTION = false;");
    stream.println(ind + "}"); 
    stream.println(ind + "protected void pushHandler(java.util.Stack stack, ASTNode$DepGraphNode handler) {");
    if (ASTNode.incrementalPropLimit) {
    stream.println(ind(2) + "// assume that evaluation will be clean from cached values");
    stream.println(ind(2) + "handler.noCacheRead = true;");
    }
    stream.println(ind(2) + "stack.push(handler);");
    stream.println(ind + "}");        
    stream.println(ind + "protected ASTNode$DepGraphNode popHandler(java.util.Stack stack, ASTNode$DepGraphNode handler) {");
    stream.println(ind(2) + "if (stack.isEmpty())");
    stream.println(ind(3) +   "throw new Error(\"Handler stack is empty at exit!\");");
    stream.println(ind(2) + "ASTNode$DepGraphNode h = (ASTNode$DepGraphNode)stack.pop();");
    // Skip this for now, deal with transitive dependencies later
    //if (ASTNode.incrementalPropLimit) {
    //stream.println(ind(2) + "h.setCacheInDependent(h.noCacheRead);");
    //stream.println(ind(2) + "if (!stack.isEmpty()) {");
    //stream.println(ind(3) +   "ASTNode$DepGraphNode top = (ASTNode$DepGraphNode)stack.peek();");
    //stream.println(ind(3) +   "top.noCacheRead &= h.noCacheRead;");
    //stream.println(ind(2) + "}");
    //}
    stream.println(ind(2) + "if (h != handler)");
    stream.println(ind(3) +   "throw new Error(\"Top of handler stack does not match at pop!\");");
//    stream.println(ind(3) +   "throw new Error(\"Top of handler stack does not match at pop! [\" + handler.fAttrID + \"]\");");
    stream.println(ind(2) + "return h;");
    stream.println(ind + "}");
  }

  // ES_2011-12-10: Code generation for incremental evaluation, tracking rewrites
  public void ASTDecl.jjtGenIncrementalTrackRewrite5(PrintWriter stream) {
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(4) + "this.state().enterRewriteEval(node.handler);");
    }
    if (ASTNode.incrementalLevelRegion) {
      //stream.println(ind(4) + "this.state().IN_REWRITE_EVAL = true;");
      stream.println(ind(4) + "this.state().IN_COMPUTATION++;");
    }
  }

  // ES_2011-12-10: Code generation for incremental evaluation, tracking rewrites
  public void ASTDecl.jjtGenIncrementalTrackRewrite6(PrintWriter stream) {
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(4) + "this.state().exitRewriteEval(oldNode.handler);");
    }
    if (ASTNode.incrementalLevelRegion) {
      stream.println(ind(4) + "this.state().IN_COMPUTATION--;");
      //stream.println(ind(4) + "this.state().IN_REWRITE_EVAL = false;");
    }
  }

  // ES_2011-12-10: Code generation for incremental evaluation, tracking rewrites
  public void ASTDecl.jjtGenIncrementalTrackRewrite7(PrintWriter stream) {
    if (ASTNode.incrementalLevelNode || ASTNode.incrementalLevelRegion || 
          ASTNode.incrementalLevelAttr || ASTNode.incrementalLevelParam) {
      stream.println(ind(5) + "ASTNode initial = this.init_children[i];");
    }
  }

  // ES_2011-12-10: Code generation for incremental evaluation, tracking rewrites
  public void ASTDecl.jjtGenIncrementalTrackRewrite8(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(6) + "oldNode.inc_flush_subtree(this.getChild_handler[i]);");
      stream.println(ind(5) + "this.init_children[i] = initial;");
    }
    if (ASTNode.incrementalLevelAttr) {
      stream.println(ind(6) + "oldNode.inc_flush_subtree(this.getChild_handler);");
      stream.println(ind(5) + "this.init_children[i] = initial;");
    }
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(6) + "oldNode.inc_flush_subtree(node.handler());");
      stream.println(ind(5) + "this.init_children[i] = initial;");
    }
    if (ASTNode.incrementalLevelRegion) {
      stream.println(ind(5) + "if (node.isRegionRoot()) {");
      stream.println(ind(6) +   "oldNode.inc_flush_subtree(node.handler());");
      stream.println(ind(5) + "}");
      stream.println(ind(5) + "this.init_children[i] = initial;");
    }
  }

  // JO 2013-02-05 Incremental code gen
  public void ASTDecl.genIncrementalTrackRewrite12(PrintWriter stream) {
    if (ASTNode.incrementalLevelRegion) {
      if (isRegionRoot()) {
        stream.println(ind(2) + "if (state().IN_COMPUTATION > 0) {");
        stream.println(ind(3) +   "node.handler().addDependant(handler);");
        stream.println(ind(2) + "}");
      }
    }
  }

  // ES_2011-09-20: Code generation for incremental evaluation, tracking rewrites
  public void ASTDecl.jjtGenIncrementalTrackRewrite1(PrintWriter stream) {
    if (!ASTNode.fullFlush) {
    stream.println(ind(2) + "if(this.init_children == null) {");
    stream.println(ind(3) +   "this.init_children = new ASTNode[this.children.length];");
    stream.println(ind(3) +   "this.rewritten_children = new boolean[this.children.length];");
    stream.println(ind(2) + "}");
    stream.println(ind(2) + "if(!node.inc_hasEnclosingRewrittenNode()) {");
    stream.println(ind(3) +   "this.init_children[i] = node.fullCopy();");
    stream.println(ind(3) +   "this.rewritten_children[i] = true;");
    stream.println(ind(2) + "}");
    }
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(2) + "this.state().enterRewriteEval(this.getChild_handler[i]);");
    }
    if (ASTNode.incrementalLevelAttr) {
      stream.println(ind(2) + "this.state().enterRewriteEval(this.getChild_handler);");
    }
  }

  // ES_2011-09-20: Code generation for incremental evaluation, tracking rewrites
  public void ASTDecl.jjtGenIncrementalTrackRewrite2(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(2) + "this.state().exitRewriteEval(this.getChild_handler[i]);");
    }
    if (ASTNode.incrementalLevelAttr) {
      stream.println(ind(2) + "this.state().exitRewriteEval(this.getChild_handler);");
    }
  }

  // ES_2011-09-30: Code generation for incremental evaluation, tracking rewrites
  public void ASTDecl.jjtGenIncrementalTrackRewrite3(PrintWriter stream) {
    if (!ASTNode.fullFlush) {
    stream.println(ind(4) + "if (rewriteState == ASTNode$State.REWRITE_CHANGE) {");
    stream.println(ind(5) +   "this.rewritten_children[i] = true;");
    stream.println(ind(4) + "}");
    }
  }

  // ES_2011-10-05: Code generation for incremental evaluation, tracking getChild
  public void ASTDecl.jjtGenIncrementalTrackRewrite4(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(3) + "if (this.getChild_handler[i] == null) {");
      if (ASTNode.incrementalPropLimit) {
      stream.println(ind(4) +   "this.getChild_handler[i] = new ASTNode$DepGraphNode(this, \"getChild\", new Integer(i), !node.mayHaveRewrite());");
      } else {
      stream.println(ind(4) +   "this.getChild_handler[i] = new ASTNode$DepGraphNode(this, \"getChild\", new Integer(i));");
      }
      stream.println(ind(3) + "}");
      stream.println(ind(3) + "this.state().addHandlerDepTo(this.getChild_handler[i]);");
    }
    if (ASTNode.incrementalLevelAttr) {
      stream.println(ind(2) + "this.state().addHandlerDepTo(this.getChild_handler);");  
    }
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(2) + "if (node != null) {");
      stream.println(ind(3) + "  this.state().addHandlerDepTo(node.handler);");
      stream.println(ind(2) + "}");
    }
  }

  // ES_2011-12-12: Code generation for incremental evaluation, tracking getChild
  public void ASTDecl.jjtGenIncrementalTrackRewrite11(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(3) + "if (this.getChild_handler[i] == null) {");
      if (ASTNode.incrementalPropLimit) {
      stream.println(ind(4) +   "this.getChild_handler[i] = new ASTNode$DepGraphNode(this, \"getChild\", new Integer(i), !node.mayHaveRewrite());");
      } else {
      stream.println(ind(4) +   "this.getChild_handler[i] = new ASTNode$DepGraphNode(this, \"getChild\", new Integer(i));");
      }
      stream.println(ind(3) + "}");
      stream.println(ind(3) + "this.state().addHandlerDepTo(this.getChild_handler[i]);");
    }
    if (ASTNode.incrementalLevelAttr) {
      stream.println(ind(2) + "this.state().addHandlerDepTo(this.getChild_handler);");  
    }
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(2) + "if (node != null) {");
      stream.println(ind(3) + "  this.state().addHandlerDepTo(node.handler);");
      // rewrite is evaluated in "that" and may use attributes in that node, but this is not tracked. 
      // JO 2013-02-05: "this" is used instead of "that"
      // The possibility of a dependency requires one.
      stream.println(ind(3) + "  this.handler.addDependant(node.handler);");
      stream.println(ind(2) + "}");
    }
    if (ASTNode.incrementalLevelRegion) {
      // rewrite is evaluated in "that" and may use attributes in that node, but this is not tracked. 
      // JO 2013-02-05: "this" is used instead of "that"
      // The possibility of a dependency requires one.
      stream.println(ind(2) + "if (node != null && node.isRegionRoot()) {");
      stream.println(ind(3) +   "this.handler().addDependant(node.handler());");
      stream.println(ind(3) +   "node.handler().addDependant(this.handler());");
      stream.println(ind(2) + "}");
    }
  }

  // ES_2011-12-13: Code generation for incremental evaluation, name getChildNoTransform
  public void ASTDecl.jjtGenIncrementalTrackGetChildNoTransformName1(PrintWriter stream) {
      stream.println(ind + "public ASTNode ASTNode.getChildNoTransform(int i) {");
  }

  // ES_2011-12-13: Code generation for incremental evaluation, name getChildNoTransform
  public void ASTDecl.jjtGenIncrementalTrackGetChildNoTransformName2(PrintWriter stream) {
      stream.println(ind + "public T ASTNode.getChildNoTransform(int i) {");
  }

  // ES_2011-09-20: Code generation for incremental evaluation, tracking getChild
  public void ASTDecl.jjtGenIncrementalTrackGetChildNoTransform(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(2) + "if (getChild_handler[i] == null) {");
      if (ASTNode.incrementalPropLimit) {
      stream.println(ind(4) +   "getChild_handler[i] = new ASTNode$DepGraphNode(this, \"getChild\", new Integer(i), !child.mayHaveRewrite());");
      } else {
      stream.println(ind(4) +   "getChild_handler[i] = new ASTNode$DepGraphNode(this, \"getChild\", new Integer(i));");
      }
      stream.println(ind(2) + "}");
      stream.println(ind(2) + "state().addHandlerDepTo(getChild_handler[i]);");
    }
    if (ASTNode.incrementalLevelAttr) {
      stream.println(ind(2) + "state().addHandlerDepTo(getChild_handler);");  
    }
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(2) + "if (child != null)");
      stream.println(ind(3) + "  state().addHandlerDepTo(child.handler);");
    }
    if (ASTNode.incrementalLevelRegion) {
      if (isRegionRoot()) {
        stream.println(ind(2) + "if (state().IN_COMPUTATION > 0 && child != null) {");
        stream.println(ind(3) + "  child.handler().addDependant(handler);");
        stream.println(ind(2) + "}");
      }
    }
  }

  // ES_2011-09-20: Code generation for incremental evaluation, tracking getParent
  public void ASTDecl.jjtGenIncrementalTrackGetParent(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
      stream.println(ind(2) + "state().addHandlerDepTo(getParent_handler);");
    }
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(2) + "if (parent != null)");
      stream.println(ind(3) +   "state().addHandlerDepTo(((ASTNode)parent).handler);");
    }
    if (ASTNode.incrementalLevelRegion) {
      if (isRegionRoot()) {
        stream.println(ind(2) + "if (state().IN_COMPUTATION > 0 && parent != null)");
        stream.println(ind(3) +   "parent.handler().addDependant(handler);");
      }
    }
  }

  // ES_2011-09-20: Code generation for incremental evaluation, tracking numChildren
  public void ASTDecl.jjtGenIncrementalTrackNumChild(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
      stream.println(ind(2) + "state().addHandlerDepTo(numChildren_handler);");
    }
  }

  // ES_2011-09-20: Code generation for incremental evaluation, modifying tree, set parent
  public void ASTDecl.jjtGenIncrementalSetParent(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr || ASTNode.incrementalLevelNode) {
//    stream.println(ind(2) + "if (!state().IN_CONSTRUCTION && !state().IN_REWRITE_EVAL && !state().IN_ATTR_STORE_EVAL) {");
    stream.println(ind(2) + "if (!state().IN_CONSTRUCTION && !state().IN_ATTR_STORE_EVAL) {");
    }
    if (ASTNode.incrementalLevelRegion) {
    stream.println(ind(2) + "if (!state().IN_CONSTRUCTION && !(state().IN_COMPUTATION > 0)) {");
    }
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
      stream.println(ind(3) + "getParent_handler.notifyDependencies();");
    }
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(2) + "if (parent != null) {");
      stream.println(ind(3) +   "parent.handler.flushRegion();");
      stream.println(ind(2) + "}");
    }
    if (ASTNode.incrementalLevelRegion) {
      stream.println(ind(2) + "if (parent != null) {");
      stream.println(ind(3) +   "parent.handler().flushRegion();");
      stream.println(ind(2) + "}");
    }
    stream.println(ind(2) + "}");
    stream.println(ind(2) + "if (parent != null) {");
    stream.println(ind(3) +   "int index = -1;");
    stream.println(ind(3) +   "for (int i = 0; parent.children != null && i < parent.children.length; i++) {");
    stream.println(ind(4) +     "if (parent.children[i] == this) {");
    stream.println(ind(5) +       "index = i;");
    stream.println(ind(5) +       "break;");
    stream.println(ind(4) +     "}");
    stream.println(ind(3) +   "}");
    stream.println(ind(3) +   "if (index >= 0)");
    stream.println(ind(4) +     "parent.removeChild(index);");
    stream.println(ind(2) + "}");
    stream.println(ind(2) + "if (node != null) {");
    stream.println(ind(3) +   "inc_changeState(node.inc_state);");
    stream.println(ind(2) + "} else inc_changeState(inc_GARBAGE);");
  }

  // ES_2011-09-20: Code generation for incremental evaluation
  String TokenComponent.jaddGenIncrementalTokenHandler() {
    if (!isNTA()) {
    if (ASTNode.incrementalLevelParam)
      if (ASTNode.incrementalPropLimit) {
        return "    protected ASTNode$DepGraphNode #HOST#.get#ID#_handler = " +
                   "new ASTNode$DepGraphNode(this, \"get#ID#\", null, true);\n";
      } else {
        return "    protected ASTNode$DepGraphNode #HOST#.get#ID#_handler = " +
                   "new ASTNode$DepGraphNode(this, \"get#ID#\", null);\n";
      }
    if (ASTNode.incrementalLevelAttr)
      return "    protected ASTNode$DepGraphNode #HOST#.get#ID#_handler = " +
                 "new ASTNode$DepGraphNode(this, \"get#ID#\");\n";
    }
    return ""; // ASTNode.incrementalLevelNode
  }

  // ES_2011-09-20: Code generation for incremental evaluation
  String TokenComponent.jaddGenIncrementalTokenChange(String varName) {
    StringBuffer buf = new StringBuffer();
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr || ASTNode.incrementalLevelNode) {
//      buf.append("    if (!state().IN_CONSTRUCTION && !state().IN_REWRITE_EVAL && !state().IN_ATTR_STORE_EVAL) {\n");
      buf.append("    if (!state().IN_CONSTRUCTION && !state().IN_ATTR_STORE_EVAL) {\n");
    }
    if (ASTNode.incrementalLevelRegion) {
      buf.append("    if (!state().IN_CONSTRUCTION && !(state().IN_COMPUTATION > 0)) {\n");
    }
    if (isNTA()) {
      buf.append("     if (get#ID#_computed) {\n");
      buf.append("       get#ID#_computed = false;\n");
      if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
      buf.append("       get#ID#_handler.notifyDependencies();\n");
      }
      if (ASTNode.incrementalLevelNode) {
      buf.append("       handler.flushRegion();\n");
      }
      if (ASTNode.incrementalLevelRegion) {
      buf.append("       handler().flushRegion();\n");
      }
      buf.append("     }\n");
    } else {
      if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
        if (ASTNode.incrementalTrack) {
          buf.append("       get#ID#_handler.trackChange();\n");    
        }
        buf.append("       get#ID#_handler.notifyDependencies();\n");
      }
      if (ASTNode.incrementalLevelNode) {
        buf.append("       handler.flushRegion();\n");
        String type = getTokenId().getTYPE();
        boolean isStringToken = type.equals("String") || type.equals("java.lang.String");
        boolean isPrimitiveToken = isPrimitive();
        if (!isStringToken && !isPrimitiveToken) {
          buf.append("       if (token#TYPEINSIGNATURE#_#ID# instanceof ASTNode) {\n");
          buf.append("         token#TYPEINSIGNATURE#_#ID#.handler.flushRegion();\n");
          buf.append("       }\n");
        }
      }
      if (ASTNode.incrementalLevelRegion) {
        buf.append("       handler().flushRegion();\n");
        String type = getTokenId().getTYPE();
        boolean isStringToken = type.equals("String") || type.equals("java.lang.String");
        boolean isPrimitiveToken = isPrimitive();
        if (!isStringToken && !isPrimitiveToken) {
          buf.append("       if (token#TYPEINSIGNATURE#_#ID# instanceof ASTNode && token#TYPEINSIGNATURE#_#ID#.isRegionRoot()) {\n");
          buf.append("         token#TYPEINSIGNATURE#_#ID#.handler().flushRegion();\n");
          buf.append("       }\n");
        }
      }
      buf.append("       ASTNode initial = inc_locateInitialCopy();\n");
      buf.append("       if (initial != null) {\n");
      buf.append("         state().enterConstruction();\n");
      buf.append("         ((#HOST#)initial).set#ID#(" + varName + ");\n");
      buf.append("         state().exitConstruction();\n");
      buf.append("         return;\n");
      buf.append("       }\n");
    }
    buf.append("    }\n");
    return buf.toString();
  }

  // ES_2011-09-20: Code generation for incremental evaluation
  String TokenComponent.jaddGenIncrementalTokenTrack() {
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr)
      return "        state().addHandlerDepTo(get#ID#_handler);\n";
    if (ASTNode.incrementalLevelNode) {
      String type = getTokenId().getTYPE();
      boolean isStringToken = type.equals("String") || type.equals("java.lang.String");
      boolean isPrimitiveToken = isPrimitive();
      if (!isStringToken && !isPrimitiveToken) {
        StringBuffer buf = new StringBuffer();
        buf.append("        if (token#TYPEINSIGNATURE#_#ID# instanceof ASTNode) {\n");
        buf.append("          state().addHandlerDepTo(((ASTNode)token#TYPEINSIGNATURE#_#ID#).handler);\n");
        buf.append("        }\n");
        return buf.toString();
      }
    }
    if (ASTNode.incrementalLevelRegion) {
      String type = getTokenId().getTYPE();
      boolean isStringToken = type.equals("String") || type.equals("java.lang.String");
      boolean isPrimitiveToken = isPrimitive();
      if (!isStringToken && !isPrimitiveToken) {
        StringBuffer buf = new StringBuffer();
        buf.append("        if (token#TYPEINSIGNATURE#_#ID# instanceof ASTNode && token#TYPEINSIGNATURE#_#ID#.isRegionRoot()) {\n");
        buf.append("          ((ASTNode)token#TYPEINSIGNATURE#_#ID#).handler().addDependant(handler());\n");
        buf.append("        }\n");
        return buf.toString();
      }
    }
    return "";
  }

  // ES_2011-10-10: Code generation for full flush, creating initial copy store
  public void ASTDecl.jjtGenFullFlush1(PrintWriter stream) {
    stream.println(ind(2) + "if(this.init_children == null) {");
    stream.println(ind(3) +   "this.init_children = new ASTNode[this.children.length];");
    stream.println(ind(3) +   "this.rewritten_children = new boolean[this.children.length];");
    stream.println(ind(2) + "}");
    stream.println(ind(2) + "if(!node.inc_hasEnclosingRewrittenNode()) {");
    stream.println(ind(3) +   "this.init_children[i] = node.fullCopy();");
    stream.println(ind(3) +   "this.rewritten_children[i] = true;");
    stream.println(ind(2) + "}");
  }

  // ES_2011-10-10: Code generation for full flush, storing initial copy setting rewrite to true
  public void ASTDecl.jjtGenFullFlush2(PrintWriter stream) {
    stream.println(ind(4) + "if (rewriteState == ASTNode$State.REWRITE_CHANGE) {");
    stream.println(ind(5) +   "this.rewritten_children[i] = true;");
    stream.println(ind(4) + "}");
  }
  
  // ES_2011-10-10: Code generation for full flush, set child 1
  public void ASTDecl.jjtGenFullFlushSetChild1(PrintWriter stream) {
    stream.println(ind(2) + "if (init_children != null) {");
    stream.println(ind(3) +   "ASTNode d[] = new ASTNode[i << 1];");
    stream.println(ind(3) +   "System.arraycopy(init_children, 0, d, 0, init_children.length);");
    stream.println(ind(3) +   "init_children = d;");
    stream.println(ind(2) + "}");
    stream.println(ind(2) + "if (rewritten_children != null) {");
    stream.println(ind(3) +   "boolean[] b = new boolean[i << 1];");
    stream.println(ind(3) +   "System.arraycopy(rewritten_children, 0, b, 0, rewritten_children.length);");
    stream.println(ind(3) +   "rewritten_children = b;");
    stream.println(ind(2) + "}");
  }

  // ES_2011-10-10: Code generation for full flush, set child 2
  public void ASTDecl.jjtGenFullFlushSetChild2(PrintWriter stream) {
    stream.println(ind(2) + "if (rewritten_children != null) {");
    stream.println(ind(3) +   "rewritten_children[i] = false;"); 
    stream.println(ind(2) + "}");   
  }

  // ES_2011-10-10: Code generation for full flush, insert child 1
  public void ASTDecl.jjtGenFullFlushInsertChild1(PrintWriter stream) {
    stream.println(ind(2) + "if (init_children != null) {");
    stream.println(ind(3) +   "ASTNode d[] = new ASTNode[init_children.length + 1];");
    stream.println(ind(3) +   "System.arraycopy(init_children, 0, d, 0, init_children.length);");
    stream.println(ind(3) +   "if (i < init_children.length) {");
    stream.println(ind(4) +     "System.arraycopy(init_children, i, d, i+1, init_children.length - i);");
    stream.println(ind(3) +   "}");
    stream.println(ind(3) +   "init_children = d;");
    stream.println(ind(2) + "}");
    stream.println(ind(2) + "if (rewritten_children != null) {");
    stream.println(ind(3) +   "boolean b[] = new boolean[rewritten_children.length + 1];");
    stream.println(ind(3) +   "System.arraycopy(rewritten_children, 0, b, 0, rewritten_children.length);");
    stream.println(ind(3) +   "if (i < rewritten_children.length) {");
    stream.println(ind(4) +     "System.arraycopy(rewritten_children, i, b, i+1, rewritten_children.length - i);");
    stream.println(ind(3) +   "}");
    stream.println(ind(3) +   "rewritten_children = b;");
    stream.println(ind(2) + "}");
  }

  // ES_2011-10-10: Code generation for full flush, remove child 1
  public void ASTDecl.jjtGenFullFlushRemoveChild1(PrintWriter stream) {
    stream.println(ind(3) + "if (init_children != null) {");
    stream.println(ind(4) +   "System.arraycopy(init_children, i+1, init_children, i, init_children.length-i-1);");
    stream.println(ind(3) + "}");      
    stream.println(ind(3) + "if (rewritten_children != null) {");
    stream.println(ind(4) +   "System.arraycopy(rewritten_children, i+1, rewritten_children, i, rewritten_children.length-i-1);");
    stream.println(ind(3) + "}");
  }

  // ES_2012-01-31: Code generation for incremental evaluation, modifying tree, add child 1
  public void ASTDecl.jjtGenIncrementalASTChangeAddChild1(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(3) + "int i = getNumChildNoTransform() - 1;");
      stream.println(ind(3) + "if (getChild_handler[i] == null)");
      if (ASTNode.incrementalPropLimit) {
      stream.println(ind(4) +   "getChild_handler[i] = new ASTNode$DepGraphNode(this, \"getChild\", new Integer(i), !node.mayHaveRewrite());");
      } else {
      stream.println(ind(4) +   "getChild_handler[i] = new ASTNode$DepGraphNode(this, \"getChild\", new Integer(i));");
      }
      stream.println(ind(3) + "state().addHandlerDepTo(getChild_handler[i]);");    
      stream.println(ind(3) + "if (state().IN_ATTR_STORE_EVAL && !node.mayHaveRewrite()) node.is$Final(is$Final());");
    }
    if (ASTNode.incrementalLevelAttr) {
      stream.println(ind(3) + "state().addHandlerDepTo(getChild_handler);");
      stream.println(ind(3) + "if (state().IN_ATTR_STORE_EVAL && !node.mayHaveRewrite()) node.is$Final(is$Final());");
    }
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(3) + "if (node != null) {");
      stream.println(ind(4) +   "state().addHandlerDepTo(node.handler);");
      stream.println(ind(4) +   "if (state().IN_ATTR_STORE_EVAL && !node.mayHaveRewrite()) node.is$Final(is$Final());");
      stream.println(ind(3) + "}");
    }
    if (ASTNode.incrementalLevelRegion) {
      stream.println(ind(3) + "if (node != null && node.isRegionRoot()) {");
      stream.println(ind(4) +   "state().addHandlerDepTo(node.handler());");
      stream.println(ind(4) +   "if (state().IN_ATTR_STORE_EVAL && !node.mayHaveRewrite()) node.is$Final(is$Final());");
      stream.println(ind(3) + "}");
    }
  }

  // ES_2011-10-06: Code generation for incremental evaluation, modifying tree, set child 1
  public void ASTDecl.jjtGenIncrementalASTChangeSetChild1(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr || ASTNode.incrementalLevelNode) {
//    stream.println(ind(2) + "if (!state().IN_CONSTRUCTION && !state().IN_REWRITE_EVAL && !state().IN_ATTR_STORE_EVAL) {");
    stream.println(ind(2) + "if (!state().IN_CONSTRUCTION && !state().IN_ATTR_STORE_EVAL) {");
    }
    if (ASTNode.incrementalLevelRegion) {
    stream.println(ind(2) + "if (!state().IN_CONSTRUCTION && !(state().IN_COMPUTATION > 0)) {");
    }
    // notify current child
    stream.println(ind(3) +   "if (children != null && i < children.length && children[i] != null) {");
    stream.println(ind(4) +     "children[i].inc_notifyForRemove();");
    //if (ASTNode.incrementalDebug) stream.println(ind(4) +     "children[i].inc_clearDepsInTree();");
    stream.println(ind(3) +   "}");

    // notify dependencies
    if (ASTNode.incrementalLevelParam) {  
      // notify empty
      stream.println(ind(3) +   "if (children == null) {");
      stream.println(ind(4) +     "numChildren_handler.notifyDependencies();");
      // notify add
      stream.println(ind(3) +   "} else if (i >= numChildren) {");
      stream.println(ind(4) +     "numChildren_handler.notifyDependencies();");
      stream.println(ind(4) +     "if (i > 0 && getChild_handler[i-1] != null) {");
      stream.println(ind(5) +       "getChild_handler[i-1].notifyDependencies();");
      stream.println(ind(4) +     "}");
      stream.println(ind(3) +   "}");
    }
    // notify set
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(3) +   "else {");
      stream.println(ind(4) +     "if (getChild_handler[i] != null) {");
      stream.println(ind(5) +       "getChild_handler[i].notifyDependencies();");
      stream.println(ind(4) +     "} else getChild_handler[i] = new ASTNode$DepGraphNode(this, \"getChild\", new Integer(i));");
      stream.println(ind(3) +   "}");
    }
    if (ASTNode.incrementalLevelAttr) {
      //stream.println(ind(3) +   "getChild_handler.notifyDependencies();");
      stream.println(ind(3) +   "getChild_handler.flushRegion();");
    }
    if (ASTNode.incrementalLevelNode) {
      //stream.println(ind(3) +   "handler.notifyDependencies();");
      stream.println(ind(3) +   "if (children != null && i < children.length && children[i] != null) children[i].handler.notifyDependencies();");
      stream.println(ind(3) +   "if (i == numChildren) handler.notifyDependencies();");
    }
    if (ASTNode.incrementalLevelRegion) {
      stream.println(ind(3) +   "ASTNode$DepGraphNode h = (children != null && i < children.length && children[i] != null) ? children[i].handler() : handler();");
      stream.println(ind(3) +   "if (h != null) h.notifyDependencies();");
      stream.println(ind(3) +   "if (i == numChildren) handler.notifyDependencies();");
    }
    // change in initial copy?
    stream.println(ind(3) +   "ASTNode initial  = inc_locateInitialCopy();");
    stream.println(ind(3) +   "if (initial != null) {");
    stream.println(ind(4) +     "state().enterConstruction();");
    stream.println(ind(4) +     "if (i >= initial.numChildren)");
    stream.println(ind(5) +       "initial.addChild(node);");
    stream.println(ind(4) +     "else initial.setChild(node, i);");
    stream.println(ind(4) +     "state().exitConstruction();");
    stream.println(ind(4) +     "return;");
    stream.println(ind(3) +   "}");
    stream.println(ind(2) + "}");
  }

  // ES_2011-10-06: Code generation for incremental evaluation, modifying tree, set child 1
  public void ASTDecl.jjtGenIncrementalASTChangeSetChild2(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam) 
      stream.println(ind(3) + "getChild_handler = new ASTNode$DepGraphNode[i+1>" + MIN_LIST_LIMIT + "?i+1:" + MIN_LIST_LIMIT + "];");
  }

  // ES_2011-10-06: Code generation for incremental evaluation, modifying tree, set child 2
  public void ASTDecl.jjtGenIncrementalASTChangeSetChild3(PrintWriter stream) {
    // rewrite code
    if (!ASTNode.fullFlush) {
      stream.println(ind(3) + "if (init_children != null) {");
      stream.println(ind(4) +   "ASTNode d[] = new ASTNode[i << 1];");
      stream.println(ind(4) +   "System.arraycopy(init_children, 0, d, 0, init_children.length);");
      stream.println(ind(4) +   "init_children = d;");
      stream.println(ind(3) + "}");
      stream.println(ind(3) + "if (rewritten_children != null) {");
      stream.println(ind(4) +   "boolean[] b = new boolean[i << 1];");
      stream.println(ind(4) +   "System.arraycopy(rewritten_children, 0, b, 0, rewritten_children.length);");
      stream.println(ind(4) +   "rewritten_children = b;");
      stream.println(ind(3) + "}");
    }
    //
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(3) + "if (getChild_handler != null) {");
      stream.println(ind(4) +   "ASTNode$DepGraphNode h[] = new ASTNode$DepGraphNode[i << 1];");
      stream.println(ind(4) +   "System.arraycopy(getChild_handler, 0, h, 0, getChild_handler.length);");
      stream.println(ind(4) +   "getChild_handler = h;");
      stream.println(ind(3) + "}");
    }
  }

  // ES_2011-09-20: Code generation for incremental evaluation, modifying tree, set child 3
  public void ASTDecl.jjtGenIncrementalASTChangeSetChild4(PrintWriter stream) {
    if (!ASTNode.fullFlush) {
      stream.println(ind(2) + "if (rewritten_children != null) {");
      stream.println(ind(3) +   "rewritten_children[i] = false;"); 
      stream.println(ind(2) + "}");   
    }
  }

  // ES_2011-09-20: Code generation for incremental evaluation, modifying tree, set child 3
  public void ASTDecl.jjtGenIncrementalASTChangeSetChild5(PrintWriter stream) {
    stream.println(ind(2) + "if (children[i] != null) {");
    stream.println(ind(3) +   "children[i].inc_throwAway();");
    stream.println(ind(3) +   "children[i].parent = null;");
    stream.println(ind(2) + "}");
  }

  // ES_2011-09-20: Code generation for incremental evaluation, modifying tree, insert child 1
  public void ASTDecl.jjtGenIncrementalASTChangeInsertChild1(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(3) + "getChild_handler = new ASTNode$DepGraphNode[i + 1];");
      stream.println(ind(3) + "getChild_handler[i] = new ASTNode$DepGraphNode(this, \"getChild\", new Integer(i));");
    }
  }

  // ES_2011-09-20: Code generation for incremental evaluation, modifying tree, insert child 2
  public void ASTDecl.jjtGenIncrementalASTChangeInsertChild2(PrintWriter stream) {
    // rewrite code
    if (!ASTNode.fullFlush) {
      stream.println(ind(2) + "if (init_children != null) {");
      stream.println(ind(3) +   "ASTNode d[] = new ASTNode[init_children.length + 1];");
      stream.println(ind(3) +   "System.arraycopy(init_children, 0, d, 0, init_children.length);");
      stream.println(ind(3) +   "if (i < init_children.length) {");
      stream.println(ind(4) +     "System.arraycopy(init_children, i, d, i+1, init_children.length - i);");
      stream.println(ind(3) +   "}");
      stream.println(ind(3) +   "init_children = d;");
      stream.println(ind(2) + "}");
      stream.println(ind(2) + "if (rewritten_children != null) {");
      stream.println(ind(3) +   "boolean b[] = new boolean[rewritten_children.length + 1];");
      stream.println(ind(3) +   "System.arraycopy(rewritten_children, 0, b, 0, rewritten_children.length);");
      stream.println(ind(3) +   "if (i < rewritten_children.length) {");
      stream.println(ind(4) +     "System.arraycopy(rewritten_children, i, b, i+1, rewritten_children.length - i);");
      stream.println(ind(3) +   "}");
      stream.println(ind(3) +   "rewritten_children = b;");
      stream.println(ind(2) + "}");
    }
    //
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(2) + "if (getChild_handler != null) {");
      stream.println(ind(3) +   "ASTNode$DepGraphNode h[] = new ASTNode$DepGraphNode[getChild_handler.length + 1];");
      stream.println(ind(3) +   "System.arraycopy(getChild_handler, 0, h, 0, getChild_handler.length);");
//      stream.println(ind(3) +   "if (i < getChild_handler.length) {");
//      stream.println(ind(4) +     "System.arraycopy(getChild_handler, i, h, i+1, getChild_handler.length - 1);");
//      stream.println(ind(3) +   "}");
      stream.println(ind(3) +   "getChild_handler = h;");
//      stream.println(ind(3) +   "for (int k = i; k < getChild_handler.length; k++) {");
//      stream.println(ind(4) +     "if (getChild_handler[k] != null) {");
//      stream.println(ind(5) +       "getChild_handler[k].setParams(new Integer(k));");
//      stream.println(ind(4) +     "}");Region
//      stream.println(ind(3) +   "}");
      stream.println(ind(2) + "}");
    }
  }

  // ES_2011-10-06: Code generation for incremental evaluation, modifying tree, insert child 4
  public void ASTDecl.jjtGenIncrementalASTChangeInsertChild3(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr || ASTNode.incrementalLevelNode) {
//    stream.println(ind(2) + "if (!state().IN_CONSTRUCTION && !state().IN_REWRITE_EVAL && !state().IN_ATTR_STORE_EVAL) {");
    stream.println(ind(2) + "if (!state().IN_CONSTRUCTION && !state().IN_ATTR_STORE_EVAL) {");
    }
    if (ASTNode.incrementalLevelRegion) {
    stream.println(ind(2) + "if (!state().IN_CONSTRUCTION && !(state().IN_COMPUTATION > 0)) {");
    }
    // notify
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
      stream.println(ind(3) + "if (children == null || i > numChildren) {");
      stream.println(ind(4) +   "numChildren_handler.notifyDependencies();");
      stream.println(ind(3) + "} else {");
      stream.println(ind(4) +   "numChildren_handler.notifyDependencies();");
      if (ASTNode.incrementalLevelParam) { 
        stream.println(ind(4) +   "for (int k = i; k < children.length; k++) {");
        stream.println(ind(5) +     "if (getChild_handler[k] != null) {");
        stream.println(ind(6) +       "getChild_handler[k].notifyDependencies();");
        stream.println(ind(5) +     "}");
       stream.println(ind(4) +   "}");
      }
      if (ASTNode.incrementalLevelAttr) {
        //stream.println(ind(4) +   "getChild_handler.notifyDependencies();");
        stream.println(ind(4) +   "getChild_handler.flushRegion();");
      }
      stream.println(ind(3) + "}");
    }
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(3) + "for (int k = i; k < children.length; k++) {");
      stream.println(ind(4) +   "ASTNode child = children[i];");
      stream.println(ind(4) +   "if (child != null) {");
      stream.println(ind(5) +     "child.handler.flushRegion();");
      stream.println(ind(4) +   "}");
      stream.println(ind(3) + "}");
    }
    if (ASTNode.incrementalLevelRegion) {
      stream.println(ind(3) + "for (int k = i; k < children.length; k++) {");
      stream.println(ind(4) +   "ASTNode child = children[i];");
      stream.println(ind(4) +   "if (child != null) {");
      stream.println(ind(5) +     "child.handler().flushRegion();");
      stream.println(ind(4) +   "}");
      stream.println(ind(3) + "}");
    }
    // locate initial copy
    stream.println(ind(3) +   "ASTNode initial = inc_locateInitialCopy();");
    stream.println(ind(3) +   "if (initial != null) {");
    stream.println(ind(4) +     "state().enterConstruction();");
    stream.println(ind(4) +     "initial.insertChild(node, i);");
    stream.println(ind(4) +     "state().exitConstruction();");
    stream.println(ind(4) +     "return;");
    stream.println(ind(3) +   "}");
    stream.println(ind(2) + "}");
  }

  // ES_2011-09-20: Code generation for incremental evaluation, modifying tree, remove child 1
  public void ASTDecl.jjtGenIncrementalASTChangeRemoveChild1(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr || ASTNode.incrementalLevelNode) {
//    stream.println(ind(2) + "if (!state().IN_CONSTRUCTION && !state().IN_REWRITE_EVAL && !state().IN_ATTR_STORE_EVAL) {");
    stream.println(ind(2) + "if (!state().IN_CONSTRUCTION && !state().IN_ATTR_STORE_EVAL) {");
    }
    if (ASTNode.incrementalLevelRegion) {
    stream.println(ind(2) + "if (!state().IN_CONSTRUCTION && !(state().IN_COMPUTATION > 0)) {");
    }
    // notify
    stream.println(ind(4) +   "if (children[i] != null)");
    stream.println(ind(5) +     "children[i].inc_notifyForRemove();");
    if (ASTNode.incrementalLevelParam) {
    stream.println(ind(4) +   "numChildren_handler.notifyDependencies();");
    stream.println(ind(4) +   "for (int k = i; k < children.length; k++) {");
    stream.println(ind(5) +     "if (getChild_handler[k] != null) {");
    stream.println(ind(6) +       "getChild_handler[k].notifyDependencies();");
    stream.println(ind(5) +     "}");
    stream.println(ind(4) +   "}");
    }
    if (ASTNode.incrementalLevelAttr) {
      //stream.println(ind(4) +   "getChild_handler.notifyDependencies();");
      stream.println(ind(4) +   "getChild_handler.flushRegion();");
    }
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(4) +   "handler.flushRegion();");
      stream.println(ind(3) + "for (int k = i; k < children.length; k++) {");
      stream.println(ind(4) +   "ASTNode child = children[i];");
      stream.println(ind(4) +   "if (child != null) {");
      stream.println(ind(5) +     "child.handler.flushRegion();");
      stream.println(ind(4) +   "}");
      stream.println(ind(3) + "}");
    }
    if (ASTNode.incrementalLevelRegion) {
      stream.println(ind(4) + "handler().flushRegion();");
      stream.println(ind(3) + "for (int k = i; k < children.length; k++) {");
      stream.println(ind(4) +   "ASTNode child = children[i];");
      stream.println(ind(4) +   "if (child != null) {");
      stream.println(ind(5) +     "child.handler().flushRegion();");
      stream.println(ind(4) +   "}");
      stream.println(ind(3) + "}");
    }
    // locate initial copy
    stream.println(ind(4) +   "ASTNode initial = inc_locateInitialCopy();");
    stream.println(ind(4) +   "if (initial != null) {");
    stream.println(ind(5) +     "state().enterConstruction();");
    stream.println(ind(5) +     "initial.removeChild(i);");
    stream.println(ind(5) +     "state().exitConstruction();");
    stream.println(ind(5) +     "return;");
    stream.println(ind(4) +   "}");
    stream.println(ind(3) + "}");
  }

  // ES_2011-09-20: Code generation for incremental evaluation, modifying tree, remove child 1
  public void ASTDecl.jjtGenIncrementalASTChangeRemoveChild2(PrintWriter stream) {
    // rewrite code
    if (!ASTNode.fullFlush) {
      stream.println(ind(3) + "if (init_children != null) {");
      stream.println(ind(4) +   "if (i < init_children.length && init_children[i] != null) {");
      stream.println(ind(5) +     "init_children[i].inc_throwAway();");
      stream.println(ind(4) +   "}");
      stream.println(ind(4) +   "System.arraycopy(init_children, i+1, init_children, i, init_children.length-i-1);");
      stream.println(ind(4) +   "init_children[init_children.length-1] = null;");
      stream.println(ind(3) + "}");      
      stream.println(ind(3) + "if (rewritten_children != null) {");
      stream.println(ind(4) +   "System.arraycopy(rewritten_children, i+1, rewritten_children, i, rewritten_children.length-i-1);");
      stream.println(ind(4) +   "rewritten_children[rewritten_children.length-1] = false;");
      stream.println(ind(3) + "}");
    }
    //
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(3) + "if (getChild_handler != null && this instanceof List) {");
      stream.println(ind(4) +   "getChild_handler[numChildren] = null;");
//      stream.println(ind(4) +   "System.arraycopy(getChild_handler, i+1, " + 
//          "getChild_handler, i, getChild_handler.length-i-1);");
//      stream.println(ind(4) +   "for (int k = i; k < getChild_handler.length; k++) {");
//      stream.println(ind(5) +     "if (getChild_handler[k] != null) {");
//      stream.println(ind(6) +       "getChild_handler[k].setParams(new Integer(k));");
//      stream.println(ind(5) +     "}");
//      stream.println(ind(4) +   "}");
      stream.println(ind(3) + "}");
    }
  }

  // ES_2011-11-28: Code generation for incremental evaluation, modifying tree, remove child 3
  public void ASTDecl.jjtGenIncrementalASTChangeRemoveChild3(PrintWriter stream) {
    // prevent recursive call during state handling where setParent calls removeChild
    stream.println(ind(4) + "child.inc_throwAway();");      
  }

  // ES_2011-09-20: Code generation for incremental evaluation
  public void ASTDecl.jjtGenIncremental(PrintWriter stream) {

    if (ASTNode.incremental && !ASTNode.incrementalDebug && name().equals("ASTNode")) {
      stream.println(ind + "public String ASTNode.relativeNodeID() {");
      stream.println(ind(2) + "ASTNode parent = this.parent;");
      stream.println(ind(2) + "StringBuffer buf = new StringBuffer();");
      stream.println(ind(2) + "int index = -1;");
      stream.println(ind(2) + "if (parent != null) {");
      stream.println(ind(3) +   "buf.append(parent.relativeNodeID() + \"/\");");
      stream.println(ind(3) +   "for (int i = 0; parent.children != null && i < parent.children.length; i++) {");
      stream.println(ind(4) +    "if (parent.children[i] != null && parent.children[i] == this && !parent.childIsNTA(i)) {");
      stream.println(ind(5) +       "index = i;");
      stream.println(ind(5) +       "break;");
      stream.println(ind(4) +     "}");
      stream.println(ind(3) +   "}");
      stream.println(ind(2) + "}");
      stream.println(ind(2) + "buf.append(getClass().getSimpleName());");
      stream.println(ind(2) + "if (index > -1) {");
      stream.println(ind(3) +   "buf.append(\"[\" + index + (mayHaveRewrite()?\",r\":\"\") + \"]\");");
      stream.println(ind(2) + "}");
      stream.println(ind(2) + "return buf.toString();");
      stream.println(ind + "}");
    }
    
    jjtGenIncrementalHandlers(stream);
    jjtGenIncrementalCopyHandlers(stream);
    jjtGenIncrementalTreeModification(stream);
    jjtGenIncrementalNTAChildCheck(stream);
    jjtGenIncrementalAffectedValue(stream);
    jjtGenIncrementalReactToChange(stream);
    jjtGenIncrementalReactToASTChange(stream);
    jjtGenIncrementalState(stream);
    jjtGenIncrementalRegions(stream);
    if (ASTNode.incrementalDebug) jjtGenIncrementalDebug(stream);
  }

  // ES_2011-10-06: Code generation for incremental evaluation, tree modification
  public void ASTDecl.jjtGenIncrementalTreeModification(PrintWriter stream) {

    if (name().equals("ASTNode")) {

      // rewrite code: intial copy store -- full flush also adds this
      if (!ASTNode.fullFlush) {

        // ES_TODO: These should be protected, public now for debugging reasons
        stream.println(ind + "public ASTNode[] ASTNode.init_children;");
        stream.println(ind + "public boolean[] ASTNode.rewritten_children;");

        // method: inc_hasEnclosingRewrittenNode
        stream.println(ind + "protected boolean ASTNode.inc_hasEnclosingRewrittenNode() {");
        stream.println(ind(2) + "ASTNode child = this;");
        stream.println(ind(2) + "ASTNode parent = this.parent;");
        stream.println(ind(2) + "while (parent != null) {");
        //stream.println(ind(3) +   "int index = parent.getIndexOfChild(child);");
        stream.println(ind(3) +   "if (parent.mayHaveRewrite()) {");
        //  stream.println(ind(3) +   "if (parent.rewritten_children != null && index >= 0 && " + 
        //  "index < parent.rewritten_children.length && parent.rewritten_children[index]) {");
        stream.println(ind(4) +     "return true;");
        stream.println(ind(3) +   "}");
        stream.println(ind(3) +   "child = parent;");
        stream.println(ind(3) +   "parent = parent.parent;");
        stream.println(ind(2) + "}");
        stream.println(ind(2) + "return false;");
        stream.println(ind + "}"); // end method: inc_hasEnclosingRewrittenNode

        // method: inc_locateEnclosingRewrittenNode
        if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
          stream.println(ind + "protected ASTNode ASTNode.inc_locateEnclosingRewrittenNode() {");
          stream.println(ind(2) + "ASTNode child = this;");
          stream.println(ind(2) + "ASTNode parent = this.parent;");
          stream.println(ind(2) + "while (parent != null) {");
          stream.println(ind(3) +   "if (child.mayHaveRewrite()) {");
          //  stream.println(ind(3) +   "if (parent.rewritten_children != null && index >= 0 && " + 
          //  "index < parent.rewritten_children.length && parent.rewritten_children[index]) {");
          stream.println(ind(4) +     "return parent;");
          stream.println(ind(3) +   "}");
          stream.println(ind(3) +   "child = parent;");
          stream.println(ind(3) +   "parent = parent.parent;");
          stream.println(ind(2) + "}");
          stream.println(ind(2) + "return null;");
          stream.println(ind + "}"); 
        }
        if (ASTNode.incrementalLevelRegion || ASTNode.incrementalLevelNode) {
          stream.println(ind + "protected ASTNode ASTNode.inc_locateEnclosingRewrittenNode() {");
          stream.println(ind(2) + "ASTNode node = parent;");
          stream.println(ind(2) + "while (node != null) {");
          stream.println(ind(3) +   "if (node.mayHaveRewrite()) {");
          //  stream.println(ind(3) +   "if (parent.rewritten_children != null && index >= 0 && " + 
          //  "index < parent.rewritten_children.length && parent.rewritten_children[index]) {");
          stream.println(ind(4) +     "return node;");
          stream.println(ind(3) +   "}");
          stream.println(ind(3) +   "node = node.parent;");
          stream.println(ind(2) + "}");
          stream.println(ind(2) + "return null;");
          stream.println(ind + "}"); 
        }
        // end method: inc_locateEnclosingRewrittenNode

        // method: inc_resetRewrites
        stream.println(ind + "protected void ASTNode.inc_resetRewrites() {");
        stream.println(ind(2) + "for (int i = 0; i < numChildren; i++) {");
        stream.println(ind(3) +   "if (rewritten_children != null && i < rewritten_children.length) {");
        stream.println(ind(4) +     "rewritten_children[i] = false;");
        stream.println(ind(4) +     "if (init_children[i] != null) {");
        stream.println(ind(5) +       "init_children[i].inc_throwAway();");
        stream.println(ind(5) +       "init_children[i] = null;");
        stream.println(ind(4) +     "}");
        stream.println(ind(3) +   "}");
        stream.println(ind(3) +   "if (children[i] != null) {");
        stream.println(ind(4) +     "children[i].inc_resetRewrites();");
        stream.println(ind(3) +   "}");
        stream.println(ind(2) + "}");
        stream.println(ind + "}"); // end method: inc_resetRewrites
      }

      // method: inc_restoreEnclosingRewrite  
      if (ASTNode.incrementalLevelParam) {  
        stream.println(ind + "protected void ASTNode.inc_restoreEnclosingRewrite() {");
        stream.println(ind(2) + "ASTNode child = this;");
        stream.println(ind(2) + "ASTNode parent = this.parent;");
        stream.println(ind(2) + "while (parent != null) {");
        stream.println(ind(3) +   "int index = -1;");
        stream.println(ind(3) +   "for (int i = 0; i < parent.children.length; i++) {");
        stream.println(ind(4) +     "if (parent.children[i] == child) {");
        stream.println(ind(5) +       "index = i;");
        stream.println(ind(4) +     "}");
        stream.println(ind(3) +   "}");
        stream.println(ind(3) +   "if (child.mayHaveRewrite() && parent.inc_restoreInitialForIndex(index, parent.getChild_handler[index])) {");
        stream.println(ind(4) +     "parent.getChild_handler[index].notifyDependencies();");
        stream.println(ind(4) +     "break;");
        stream.println(ind(3) +   "}");
        stream.println(ind(3) +   "child = parent;");
        stream.println(ind(3) +   "parent = parent.getParent();");
        stream.println(ind(2) + "}");
        stream.println(ind + "}"); 
      }
      // end method: inc_restoreEnclosingRewrite
    
      // method: inc_restoreInitialForIndex
      if (ASTNode.incrementalLevelRegion || ASTNode.incrementalLevelNode) {      
        stream.println(ind + "protected boolean ASTNode.inc_restoreInitialForIndex(int index, ASTNode$DepGraphNode h) {");
        stream.println(ind(2) + "if (init_children != null && index < init_children.length " + 
                                                  "&& init_children[index] != null) {");
        stream.println(ind(3) +   "ASTNode oldNode = children[index];");
        stream.println(ind(3) +   "state().enterConstruction();");
        stream.println(ind(3) +   "setChild(init_children[index], index);");
        stream.println(ind(3) +   "state().exitConstruction();");
        stream.println(ind(3) +   "oldNode.inc_flush_subtree(h);");
        stream.println(ind(3) +   "init_children[index] = null;");
        stream.println(ind(3) +   "rewritten_children[index] = false;");
        stream.println(ind(3) +   "return true;");
        stream.println(ind(2) + "}");
        stream.println(ind(2) + "return false;");
        stream.println(ind + "}"); 
      }
      if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
        stream.println(ind + "protected boolean ASTNode.inc_restoreInitialForIndex(int index, ASTNode$DepGraphNode h) {");
        stream.println(ind(2) + "if (init_children != null && index < init_children.length " + 
                                                  "&& init_children[index] != null) {");
        stream.println(ind(3) + "ASTNode oldNode = children[index];");
        stream.println(ind(3) + "state().enterConstruction();");
        stream.println(ind(3) + "setChild(init_children[index], index);");
        stream.println(ind(3) + "state().exitConstruction();");
        stream.println(ind(3) + "oldNode.inc_flush_subtree(h);");
        stream.println(ind(3) + "init_children[index] = null;");
        stream.println(ind(3) + "return true;");
        stream.println(ind(2) + "}");
        stream.println(ind(2) + "return false;");
        stream.println(ind + "}"); 

      }
      // end method: inc_restoreInitialForIndex

      // method: inc_locateInitialCopy
      stream.println(ind + "protected ASTNode ASTNode.inc_locateInitialCopy() {");
      // locate enclosing rewrite
      stream.println(ind(2) + "ASTNode child = this;");
      stream.println(ind(2) + "ASTNode parent = getParent();");
      stream.println(ind(2) + "java.util.LinkedList indexList = new java.util.LinkedList();");
      stream.println(ind(2) + "while (parent != null) {");
      stream.println(ind(3) +   "int index = child.childIndex;");
      stream.println(ind(3) +   "indexList.addFirst(new Integer(index));");
      stream.println(ind(3) +   "if (parent.init_children != null && index >= 0 && " +
                                "index < parent.init_children.length && parent.init_children[index] != null) {");
      // stream.println(ind(3) +   "if (parent.is$Final() != child.is$Final()) {");
      stream.println(ind(4) +     "break;");
      stream.println(ind(3) +   "}");
      stream.println(ind(3) +   "child = parent;");
      stream.println(ind(3) +   "parent = child.getParent();");
      stream.println(ind(2) + "}");
      // root reached -- no enclosing rewrite
      stream.println(ind(2) + "if (parent == null) {");
      stream.println(ind(3) +   "return null;");
      stream.println(ind(2) + "}");
      // root not reached -- enclosing rewrite found
      stream.println(ind(2) + "boolean first = true;");
      stream.println(ind(2) + "for (java.util.Iterator itr = indexList.iterator(); itr.hasNext();) {");
      stream.println(ind(3) +   "int index = ((Integer)itr.next()).intValue();");
      stream.println(ind(3) +   "if (first) {");
      stream.println(ind(4) +     "first = false;");
      stream.println(ind(4) +     "child = parent.init_children[index];");
      stream.println(ind(4) +     "parent = child;");
      stream.println(ind(3) +   "} else if (index < parent.getNumChildNoTransform()) {");
      stream.println(ind(4) +     "child = parent.getChildNoTransform(index);");
      stream.println(ind(4) +     "parent = child;");
      stream.println(ind(3) +   "} else return null;");
      // stream.println(ind(3) +   "child = parent.getChildNoTransform(index);");
      // stream.println(ind(3) +   "parent = child;");
      // stream.println(ind(3) +   "if (child == null) {");
      // stream.println(ind(4) +     "throw new RuntimeException(\"Incremental tree modification error: " + 
      //                                        "premature end of change point path\");");
      // stream.println(ind(3) +   "}");
      stream.println(ind(2) + "}");
      // initial change point found
      stream.println(ind(2) + "return child;");      
      stream.println(ind + "}"); // end method: inc_locateInitialCopy
      
    }

  }

  // ES_2011-09-20: Code generation for incremental evaluation, initialization of handlers
  public void ASTDecl.jjtGenIncrementalHandlers(PrintWriter stream) {


    // if a change has been made to a list then the list should again be touched by the "touch rewrite"
    // but this does not happen if the list is final.
    //if (name().equals("List") && !ASTNode.fullFlush) {
    //  stream.println(ind + "public boolean List.is$Final() { return super.is$Final() && !list$touched; }");
    //}
    //

    // level region: one handler per region, non-region root nodes need a method to find the handler of their region
    if (ASTNode.incrementalLevelRegion) {
      if (isRegionRoot() && !hasRegionRootAsSuperClass()) {
        stream.println(ind + "protected ASTNode$DepGraphNode " + name() + 
          ".handler = new ASTNode$DepGraphNode(this);");                    
      }
    }

    // level node: one handler per node
    if (ASTNode.incrementalLevelNode) {
      if (name().equals("ASTNode")) {
        stream.println(ind + "protected ASTNode$DepGraphNode " + 
          "ASTNode.handler = new ASTNode$DepGraphNode(this);");                    
      }
    } 

    // level param, attr: at least one handler per attribute
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
      // handlers specific for ASTNode
      if (name().equals("ASTNode")) {
        if (ASTNode.incrementalLevelParam) {
          if (ASTNode.incrementalPropLimit) {
            stream.println(ind + "protected ASTNode$DepGraphNode ASTNode.getParent_handler = " + 
                "new ASTNode$DepGraphNode(this, \"getParent\", null, true);");
            stream.println(ind + "protected ASTNode$DepGraphNode ASTNode.numChildren_handler = " +
                "new ASTNode$DepGraphNode(this, \"numChildren\", null, true);");
          } else {
            stream.println(ind + "protected ASTNode$DepGraphNode ASTNode.getParent_handler = " + 
                "new ASTNode$DepGraphNode(this, \"getParent\", null);");
            stream.println(ind + "protected ASTNode$DepGraphNode ASTNode.numChildren_handler = " +
                "new ASTNode$DepGraphNode(this, \"numChildren\", null);");
          }
          stream.println(ind + "protected ASTNode$DepGraphNode[] ASTNode.getChild_handler;");
        } 
        if (ASTNode.incrementalLevelAttr) {
          stream.println(ind + "protected ASTNode$DepGraphNode ASTNode.getParent_handler = " + 
              "new ASTNode$DepGraphNode(this, \"getParent\");");
          stream.println(ind + "protected ASTNode$DepGraphNode ASTNode.numChildren_handler = " +
              "new ASTNode$DepGraphNode(this, \"numChildren\");");
          stream.println(ind + "protected ASTNode$DepGraphNode ASTNode.getChild_handler = " +
              "new ASTNode$DepGraphNode(this, \"getChild\");");
        }
      }
      // collect attributes
      ArrayList list = new ArrayList();
      for(int k = 0; k < getNumSynDecl(); k++) {
        AttrDecl attr = getSynDecl(k);
        if (attr.getLazy() || attr.isCircular()) 
          list.add(attr);
      }
      for(int k = 0; k < getNumInhDecl(); k++) {
        AttrDecl attr = getInhDecl(k);
        if (attr.getLazy() || attr.isCircular()) 
          list.add(attr);
      }
      for (int k = 0; k < getNumCollDecl(); k++) {
        CollDecl attr = getCollDecl(k);
        list.add(attr);      
      }
      // attribute code 
      for (Iterator itr = list.iterator(); itr.hasNext();) {
        AttrDecl attr = (AttrDecl)itr.next();
        if (ASTNode.incrementalLevelParam) {
          // level param: check if this is a parameterized attribute
          if (attr.getNumParameter() > 0) {
            stream.println(ind + "protected java.util.Map " + name() + "." + attr.attributeSignature() + 
                  "_handler = new java.util.HashMap(4);");
          } else {
            stream.println("  protected ASTNode$DepGraphNode " + name() + "." + 
                  attr.attributeSignature() + "_handler;");
          }
        }
        // level attr: Add one handler per attribute
        if (ASTNode.incrementalLevelAttr) {
          stream.println(ind + "protected ASTNode$DepGraphNode " + name() + "." + 
                  attr.attributeSignature() + "_handler;");            
        }
      }
    }

  }

  // ES_2011-11-22: Code generation for incremental evaluation, copying of handlers
  public void ASTDecl.jjtGenIncrementalCopyHandlers(PrintWriter stream) {

    stream.println(ind + "protected void " + name() + ".inc_copyHandlers(" + name() + " copy) {");
    // ast handlers
    if (name().equals("ASTNode")) {
      if (ASTNode.incrementalLevelParam) {
        stream.println(ind(2) + "if (getChild_handler != null)");
        stream.println(ind(3) +   "copy.getChild_handler = (ASTNode$DepGraphNode[])getChild_handler.clone();");
        stream.println(ind(2) + "copy.numChildren_handler = new ASTNode$DepGraphNode(numChildren_handler, copy);");
        stream.println(ind(2) + "copy.getParent_handler = new ASTNode$DepGraphNode(getParent_handler, copy);");
        stream.println(ind(2) + "for (int i = 0; getChild_handler != null && i < getChild_handler.length; i++) {");
        stream.println(ind(3) +   "if (getChild_handler[i] != null) {");
        stream.println(ind(4) +     "copy.getChild_handler[i] = new ASTNode$DepGraphNode(getChild_handler[i], copy);");
        stream.println(ind(3) +   "}");
        stream.println(ind(2) + "}");
      }
      if (ASTNode.incrementalLevelAttr) {
        stream.println(ind(2) + "copy.getChild_handler = new ASTNode$DepGraphNode(getChild_handler, copy);");
        stream.println(ind(2) + "copy.numChildren_handler = new ASTNode$DepGraphNode(numChildren_handler, copy);");
        stream.println(ind(2) + "copy.getParent_handler = new ASTNode$DepGraphNode(getParent_handler, copy);");
      }
      if (ASTNode.incrementalLevelNode) {
        stream.println(ind(2) + "copy.handler = new ASTNode$DepGraphNode(handler, copy);");
      }
      if (ASTNode.incrementalLevelRegion) {
        if (isRegionRoot())
          stream.println(ind(2) + "copy.handler = new ASTNode$DepGraphNode(handler, copy);");
      }
    } else {
      if (ASTNode.incrementalLevelRegion || ASTNode.incrementalLevelNode) {
        if (isRegionRoot()) {
          stream.println(ind(2) + "copy.handler = new ASTNode$DepGraphNode(handler, copy);"); 
        } else {
          stream.println(ind(2) + "super.inc_copyHandlers(copy);");
        }
      }
      if (ASTNode.incrementalLevelAttr || ASTNode.incrementalLevelParam) {
        stream.println(ind(2) + "super.inc_copyHandlers(copy);");
      }
    }
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
      // tokens
      for (int c = 0; c < getNumComponents(); c++) {
        Components comp = getComponents(c);
        if (comp instanceof TokenComponent) {
          stream.println(ind(2) + "if (get" + ((TokenComponent)comp).getTokenId().getID() + "_handler != null) {");
          stream.println(ind(3) +   "copy.get" + ((TokenComponent)comp).getTokenId().getID() + 
                                    "_handler = new ASTNode$DepGraphNode(get" + 
                               ((TokenComponent)comp).getTokenId().getID() + "_handler, copy);\n");
          stream.println(ind(2) + "}");

         }
       }
      // Collect attributes: syn then inh
      ArrayList list = new ArrayList();
      for(int k = 0; k < getNumSynDecl(); k++) {
        AttrDecl attr = getSynDecl(k);
        if (attr != null && (attr.getLazy() || attr.isCircular())) 
          list.add(attr);
      }
      for(int k = 0; k < getNumInhDecl(); k++) {
        AttrDecl attr = getInhDecl(k);
        if (attr != null && (attr.getLazy() || attr.isCircular())) 
          list.add(attr);
      }
      // Attribute code: propagate change of all cached values being removed
      for(Iterator itr = list.iterator(); itr.hasNext();) {
        AttrDecl attr = (AttrDecl)itr.next();
        if (attr.getNumParameter() > 0) {
          if (ASTNode.incrementalLevelParam) {
            stream.println(ind(2) + "if (" + attr.attributeSignature() + "_handler != null) {");
            stream.println(ind(3) +   "copy." + attr.attributeSignature() + "_handler = new java.util.HashMap(4);");
            stream.println(ind(2) + "}");
          } else {
            stream.println(ind(2) + "if (" + attr.attributeSignature() + "_handler != null) {");
            stream.println(ind(3) + "copy." + attr.attributeSignature() + "_handler = new ASTNode$DepGraphNode(" + 
                                    attr.attributeSignature() + "_handler, copy);");
            stream.println(ind(2) + "}");
          }
        } else {
          stream.println(ind(2) + "if (" + attr.attributeSignature() + "_handler != null) {");
          stream.println(ind(3) + "copy." + attr.attributeSignature() + "_handler = new ASTNode$DepGraphNode(" + 
                                  attr.attributeSignature() + "_handler, copy);");
          stream.println(ind(2) + "}");
        }
      }    
    }

    // end of method
    stream.println(ind + "}");
  }

  // ES_2011-09-23: Code generation for incremental evaluation, check if NTA child
  public void ASTDecl.jjtGenIncrementalNTAChildCheck(PrintWriter stream) {
    // collect attributes
    ArrayList list = new ArrayList();
    for(int k = 0; k < getNumSynDecl(); k++) {
      AttrDecl attr = getSynDecl(k);
      if (attr.isNTA()) 
        list.add(attr);
    }
    for(int k = 0; k < getNumInhDecl(); k++) {
      AttrDecl attr = getInhDecl(k);
      if (attr.isNTA()) 
        list.add(attr);
    }
    // method signature
    stream.println(ind + "protected boolean " + name() + ".childIsNTA(int index) {");
    // attribute code
    boolean first = true;
    for (Iterator itr = list.iterator(); itr.hasNext();) {
      AttrDecl attr = (AttrDecl)itr.next();
      if (first) {
        stream.print(ind(2) + "if (");
        first = false;
      } else stream.print(" || ");
      stream.print("index == " +  attr.indexNTAchild());
    }
    if (!first) {
      stream.println(")");
      stream.println(ind(3) + "return true;");
    }
    // method end
    if (name().equals("ASTNode"))
      stream.println(ind(2) + "return false;");
    else stream.println(ind(2) + "return super.childIsNTA(index);");
    stream.println(ind + "}");

    if (name().equals("List")) {
      stream.println(ind + "public boolean List.inc_internalNTAList = false;");
      stream.println(ind + "public java.util.Map List.inc_internalNTAList_map;");
      stream.println(ind + "public void List.inc_internalNTAList(java.util.Map m) {");
      stream.println(ind(2) + "inc_internalNTAList = true;");
      stream.println(ind(2) + "inc_internalNTAList_map = m;");
      stream.println(ind + "}");
    }
  }

  // ES_2012-05-17: Code generation for incremental evaluation, check if value is affected
  public void ASTDecl.jjtGenIncrementalAffectedValue(PrintWriter stream) {

    // start method: inc_valueAffected
    if (ASTNode.incrementalLevelParam && ASTNode.incrementalPropLimit) {
      stream.println(ind + "public boolean " + name() + ".inc_valueAffected(String attrID, Object _parameters) {");      

      ArrayList list = new ArrayList();
      for(int k = 0; k < getNumSynEq(); k++) {
        AttrDecl attr = getSynEq(k).decl();
        if (attr != null && (attr.getLazy() || attr.isCircular())) 
          list.add(attr);
      }
      for(int k = 0; k < getNumInhDecl(); k++) {
        AttrDecl attr = getInhDecl(k);
        if (attr != null && (attr.getLazy() || attr.isCircular())) 
          list.add(attr);
      }

      // Add attribute code: flush attributes
      boolean first = true;
      for(Iterator itr = list.iterator(); itr.hasNext();) {
        AttrDecl attr = (AttrDecl)itr.next();

        // NTAs: Are always considered affected
        if (attr.isNTA() || attr.getNTA()) {
          stream.println(ind(2) + "// NTA");              
          stream.print(ind(2) + (first ? "" : "else "));
          stream.print("if (" + "attrID.equals(\"" + attr.attributeSignature() + "\")");
          if (attr.getNumParameter() > 0) {
            stream.print(" && " + attr.attributeSignature() + "_values != null" + 
              " && " + attr.attributeSignature() + "_values.containsKey(_parameters)");
          } else {
            stream.print(" && " + attr.attributeSignature() + "_computed");
          }
          stream.println(") {");
          stream.println(ind(3) + "return true;");  
          stream.println(ind(2) + "}");      // end match statements            
        } 

        // non-NTAs
        else {

          // start match attribute statement
          stream.print(ind(2) + (first ? "" : "else "));
          stream.print("if (" + "attrID.equals(\"" + attr.attributeSignature() + "\")");
          if (attr.getNumParameter() > 0) {
            stream.print(" && " + attr.attributeSignature() + "_values != null" + 
              " && " + attr.attributeSignature() + "_values.containsKey(_parameters)");
          } else {
            stream.print(" && " + attr.attributeSignature() + "_computed");
          }
          stream.println(") {");

          // TODO: Add support for more than one parameter
          // with parameters
          if (attr.getNumParameter() > 0) {
            if (attr.isPrimitive()) {
              // store old value
              String type = attr.type();
              type = type.substring(0,1).toUpperCase() + type.substring(1);
              stream.println(ind(3) + attr.type() + " oldValue = " + type + ".valueOf((" + type + ")" + attr.attributeSignature() + "_values.get(_parameters));");
              // flush value
              stream.println(ind(3) + attr.attributeSignature() + "_values.remove(_parameters);"); 
              // clear dependencies in handler
              stream.println(ind(3) + "ASTNode$DepGraphNode handler = (ASTNode$DepGraphNode)" + attr.attributeSignature() + "_handler.get(_parameters);");
              stream.println(ind(3) + "handler.clearDependencies();");
              // compute new value
              if (attr.getNumParameter() == 1) {
                String param = "(" + attr.getParameter(0).getTypeInSignature() + ")_parameters";
                stream.println(ind(3) + attr.type() + " newValue = " + attr.getName() + "(" + param + ");");
              } else {
                stream.println(ind(3) + "throw new Error(\"No support for more than one parameter in affected value check\");");
              }
            } else {
              // store old value
              stream.println(ind(3) + attr.type() + " oldValue = (" + attr.type() + ")" + attr.attributeSignature() + "_values.get(_parameters);");
              // flush value
              stream.println(ind(3) + attr.attributeSignature() + "_values.remove(_parameters);"); 
              // clear dependencies in handler
              stream.println(ind(3) + "ASTNode$DepGraphNode handler = (ASTNode$DepGraphNode)" + attr.attributeSignature() + "_handler.get(_parameters);");
              stream.println(ind(3) + "handler.clearDependencies();");
              // compute new value
              if (attr.getNumParameter() == 1) {
                String param = "(" + attr.getParameter(0).getTypeInSignature() + ")_parameters";
                stream.println(ind(3) + attr.type() + " newValue = " + attr.getName() + "(" + param + ");");
              } else {
                stream.println(ind(3) + "throw new Error(\"No support for more than one parameter in affected value check\");");
              }
            }
          } 
          // without parameters
          else {
            // store old value + flush value
            stream.println(ind(3) + attr.type() + " oldValue = " + attr.attributeSignature() + "_value;");
            String u = attr.resetVisit() + attr.resetCache();
            u = u.replaceAll("#NAME#", attr.attributeSignature());            
            stream.print(u);         
            // clear dependencies in handler  
            stream.println(ind(3) + attr.attributeSignature() + "_handler.clearDependencies();");
            // compute new value
            stream.println(ind(3) + attr.type() + " newValue = " + attr.getName() + "();");
          }

          // compare old and new value
          if (attr.isPrimitive()) {
            stream.println(ind(3) + "if (oldValue == newValue)");
          } else {
            stream.println(ind(3) + "Object obj = (Object)oldValue;");
            stream.println(ind(3) + "if ((obj instanceof ASTNode && (oldValue == newValue)) || " + 
              "(oldValue == null && newValue == null) || (oldValue != null && oldValue.equals(newValue)))");
          }
          stream.println(ind(4) + "return false;");
          stream.println(ind(3) + "return true;");
          stream.println(ind(2) + "}");      // end match statements
          first = false;

        }
      }
      if (name().equals("ASTNode"))
        stream.println(ind(2) + "return true;");      
      else 
        stream.println(ind(2) + "return super.inc_valueAffected(attrID, _parameters);");      
      stream.println(ind + "}");
    }
    // end method: inc_valueAffected
  }

  // ES_2011-09-20: Code generation for incremental evaluation, react to change
  public void ASTDecl.jjtGenIncrementalReactToChange(PrintWriter stream) {

    // method: reactToDependencyChange
    if (ASTNode.incrementalLevelParam)
      stream.println(ind + "public void " + name() + ".reactToDependencyChange(String attrID, Object _parameters) {");      
    if (ASTNode.incrementalLevelAttr) 
      stream.println(ind + "public void " + name() + ".reactToDependencyChange(String attrID) {");      
    if (ASTNode.incrementalLevelNode) 
      if (name().equals("ASTNode"))
        stream.println(ind + "public void " + name() + ".reactToDependencyChange() {");      
    if (ASTNode.incrementalLevelRegion) {
      if (isRegionRoot() || name().equals("ASTNode")) 
        stream.println(ind + "public void " + name() + ".reactToDependencyChange() {");      
    }

    if (ASTNode.incrementalChangeFlush) {
      if (ASTNode.incrementalLevelRegion) {
        if (isRegionRoot())
          jjtGenIncrementalChangeFlush(stream);
      } else if (ASTNode.incrementalLevelNode) {
        if (name().equals("ASTNode")) 
          jjtGenIncrementalChangeFlush(stream);
      } else {
        jjtGenIncrementalChangeFlush(stream);
      }
    }

    // super class if not ASTNode
    if (!name().equals("ASTNode")) {
      if (ASTNode.incrementalLevelParam)
        stream.println(ind(2) + "super.reactToDependencyChange(attrID, _parameters);");      
      if (ASTNode.incrementalLevelAttr) 
        stream.println(ind(2) + "super.reactToDependencyChange(attrID);");   
    }

    if (ASTNode.incrementalLevelRegion) {
      if (isRegionRoot() || name().equals("ASTNode")) 
        stream.println(ind + "}");      
    } 
    else if (ASTNode.incrementalLevelNode) {
      if (name().equals("ASTNode")) {
        stream.println(ind + "}");
      }
    }
    else {
      stream.println(ind + "}");
    }
    // end method: reactToDependencyChange


    // method: inc_flush
    if (ASTNode.incrementalChangeFlush) {

      // collect attributes: syn, inh
      ArrayList list = new ArrayList();
      for(int k = 0; k < getNumSynEq(); k++) {
        AttrDecl attr = getSynEq(k).decl();
        if (attr != null && (attr.getLazy() || attr.isCircular())) 
          list.add(attr);
      }
      for(int k = 0; k < getNumInhDecl(); k++) {
        AttrDecl attr = getInhDecl(k);
        if (attr != null && (attr.getLazy() || attr.isCircular())) 
          list.add(attr);
      }

      // start method: inc_flush
      if (ASTNode.incrementalLevelNode || ASTNode.incrementalLevelRegion) {
        stream.println(ind + "public void " + name() + ".inc_flush() {");
        // flush attributes
        for(Iterator itr = list.iterator(); itr.hasNext();) {
          AttrDecl attr = (AttrDecl)itr.next();
          // NTAs
          if ((attr.isNTA() || attr.getNTA()) && !attr.isPrimitive() 
              && !(attr.type().equals("String") || attr.type().equals("java.lang.String"))) {

            if (ASTNode.incrementalLevelRegion) {
              // TODO: Add a flush of non-region root NTA children
            }


          } 
          // Non NTAs
          else {
            if (attr.getNumParameter() > 0) {
              stream.println(ind(2) + "if (" + attr.attributeSignature() + "_values != null && !" + 
                attr.attributeSignature() + "_values.isEmpty()) {");
              String u = attr.resetVisit() + attr.resetCache();
              u = u.replaceAll("#NAME#", attr.attributeSignature());
              stream.print(u);              
              //if (ASTNode.incrementalTrack) {
              //  stream.println(ind(3) + "ASTNode$DepGraphNode.trackedFlushes++;");
              //}
              stream.println(ind(2) + "}");
            } else {
              //stream.println(ind(2) + "if (" + attr.attributeSignature() + "_computed) {");
              String u = attr.resetVisit() + attr.resetCache();
              u = u.replaceAll("#NAME#", attr.attributeSignature());
              stream.print(u);              
              //if (ASTNode.incrementalTrack) {
              //  stream.println(ind(3) + "ASTNode$DepGraphNode.trackedFlushes++;");
              //}
              //stream.println(ind(2) + "}");
            }
          }
        }
        if (name().equals("ASTNode")) {
        } else {
          stream.println(ind(2) + "super.inc_flush();");
        }
        stream.println(ind + "}");        
      }
      // end method: inc_flush

      // methods: inc_flush_child
      if (ASTNode.incrementalLevelNode || ASTNode.incrementalLevelRegion) {
        if (name().equals("ASTNode")) {
        stream.println(ind + "public boolean ASTNode.inc_flush_child(ASTNode node) {");
        stream.println(ind(2) + "for (int i = 0; node.mayHaveRewrite() && i < children.length; i++) {");        
//        stream.println(ind(3) +   "if (children[i] == node && rewritten_children != null && " +
//                                      "i < rewritten_children.length && rewritten_children[i]) {");
        stream.println(ind(3) +    "if (children[i] == node) {");
        stream.println(ind(4) +     "return inc_restoreInitialForIndex(i, node.handler());");
        stream.println(ind(3) +   "}");
        stream.println(ind(2) + "}");
        stream.println(ind(2) + "return true;");
        stream.println(ind + "}"); 
        }
      }
      // end methods: inc_flush_child

      // methods: inc_flush_NTA
      if (ASTNode.incrementalLevelNode || ASTNode.incrementalLevelRegion) {
        stream.println(ind + "public boolean " + name() + ".inc_flush_NTA(ASTNode node) {");
        if (name().equals("List") || name().equals("Opt")) {

          if (name().equals("List")) {
            stream.println(ind(2) + "if (inc_internalNTAList) {");
            stream.println(ind(3) +   "state().enterConstruction();");
            stream.println(ind(3) +   "int childIndex = getIndexOfChild(node);");
            stream.println(ind(3) +   "removeChild(childIndex);");
            stream.println(ind(3) +   "node.inc_flush_subtree(node.handler());");
            stream.println(ind(3) +   "node.handler().clearDependencies();");
            stream.println(ind(3) +   "state().exitConstruction();");
            stream.println(ind(3) +   "if (inc_internalNTAList_map.containsValue(node)) {");
            stream.println(ind(4) +     "for (java.util.Iterator itr = inc_internalNTAList_map.keySet().iterator(); itr.hasNext();) {");
            stream.println(ind(5) +       "Object key = itr.next();");
            stream.println(ind(5) +       "if (inc_internalNTAList_map.get(key) == node) {");
            stream.println(ind(6) +         "inc_internalNTAList_map.remove(key);");
            stream.println(ind(6) +         "break;");
            stream.println(ind(5) +       "}");
            stream.println(ind(4) +     "}");
            stream.println(ind(3) +   "}");
            stream.println(ind(3) +   "return true;");
            stream.println(ind(2) + "}");
          }

          stream.println(ind(2) + "if (parent != null) {");
          stream.println(ind(3) +   "int index = parent.getIndexOfChild(this);");
          stream.println(ind(3) +   "if (index >= 0 && parent.childIsNTA(index)) {");
          stream.println(ind(4) +     "state().enterConstruction();");
          if (name().equals("List")) {
            stream.println(ind(4) +     "int childIndex = getIndexOfChild(node);");
            stream.println(ind(4) +     "removeChild(childIndex);");
          } else {
            stream.println(ind(4) +     "node.setParent(null);");
          }
          stream.println(ind(4) +     "node.inc_flush_subtree(node.handler());");
          stream.println(ind(4) +     "node.handler().clearDependencies();");
          stream.println(ind(4) +     "state().exitConstruction();");
          //if (ASTNode.incrementalTrack) {
          //  stream.println(ind(4) +     "ASTNode$DepGraphNode.trackedFlushes++;");
          //}
          stream.println(ind(4) +     "return true;");
          stream.println(ind(3) +   "}");
          stream.println(ind(3) +   "return false;");
          stream.println(ind(2) + "}");

        } else {

          for(Iterator itr = list.iterator(); itr.hasNext();) {
            AttrDecl attr = (AttrDecl)itr.next();

            // NTAs
            if ((attr.isNTA() || attr.getNTA()) && !attr.isPrimitive() 
                  && !(attr.type().equals("String") || attr.type().equals("java.lang.String"))) {

              if (attr.getNumParameter() > 0) {
/* Parameterized NTAs are kept in a List and will consequently ask its parent list if it should be flushed, see code above
                stream.println(ind(2) + "if (" + attr.attributeSignature() + "_list != null) {");
                stream.println(ind(3) +   "for (int index = 0; i < " + attr.attributeSignature() + "_list.numChildren; i++;) {");
                stream.println(ind(4) +     "ASTNode value = " + attr.attributeSignature() + "_list.children[index];");              
                stream.println(ind(4) +     "if (value == node) {");
                stream.println(ind(5) +       "state().enterConstruction();");
                stream.println(ind(5) +       attr.attributeSignature() + "_list.removeChild(index);");
                stream.println(ind(5) +       "state().exitConstruction();");
                stream.println(ind(5) +       attr.attributeSignature() + "_list.inc_flush_subtree(node.handler());");
                stream.println(ind(4) +     "node.handler().clearDependencies();");
                String u = attr.resetVisit() + attr.resetCache();
                u = u.replaceAll("#NAME#", attr.attributeSignature());
                stream.print(u);
                if (ASTNode.incrementalTrack) {
                  stream.println(ind(5) + "ASTNode$DepGraphNode.trackedFlush++;");
                }
                stream.println(ind(5) +       "return true;");
                stream.println(ind(4) +     "}");
                stream.println(ind(3) +   "}");
                stream.println(ind(2) + "}");
*/
              } else {
                Components comp = attr.findCorrespondingNTA();
//                if (comp == null || !(comp instanceof OptionalComponentNTA || comp instanceof ListComponentsNTA)) {
                if (comp == null || comp instanceof OptionalComponentNTA || comp instanceof ListComponentsNTA) {
                  stream.println(ind(2) + "if (" + attr.attributeSignature() + "_value == node) {");
                  stream.println(ind(3) +   "state().enterConstruction();");
                  stream.println(ind(3) +   attr.attributeSignature() + "_value.setParent(null);");
                  stream.println(ind(3) +   "state().exitConstruction();");
                  stream.println(ind(3) +   attr.attributeSignature() + "_value.inc_flush_subtree(node.handler());");
                  stream.println(ind(4) +     "node.handler().clearDependencies();");
                  String u = attr.resetVisit() + attr.resetCache();
                  u = u.replaceAll("#NAME#", attr.attributeSignature());
                  stream.print(u);
                  //if (ASTNode.incrementalTrack) {
                  //  stream.println(ind(3) + "ASTNode$DepGraphNode.trackedFlushes++;");
                  //}
                  stream.println(ind(2) + "}");
                }
              }

            }
          }
        }
        stream.println(ind(2) + "return false;");
        stream.println(ind + "}"); 
      }
      // end methods: inc_flush_NTA

      // method: inc_flushRegionRoot
      if ((ASTNode.incrementalLevelRegion && (isRegionRoot() || name().equals("ASTNode"))) || 
            (ASTNode.incrementalLevelNode && name().equals("ASTNode"))) {
        stream.println(ind + "public boolean " + name() + ".inc_flushRegionRoot() {");
        if (ASTNode.incrementalLevelRegion) {
          // Check for rewrites
          stream.println(ind(2) + "// check for inner rewrite in region root");
          stream.println(ind(2) + "boolean rewriteFlushed = true;");
          stream.println(ind(2) + "if (parent != null) {");
          stream.println(ind(3) +   "rewriteFlushed = parent.inc_flush_child(this);");
          stream.println(ind(3) +   "// region root had an outer rewrite which was flushed (parent == null) -> done");
          stream.println(ind(3) +   "if (rewriteFlushed && parent == null) {");
          stream.println(ind(4) +     "return true;");
          stream.println(ind(3) +   "}");
          stream.println(ind(2) + "}");
          stream.println(ind(2) + "boolean innerRewrite = false;");
          stream.println(ind(2) + "if (rewriteFlushed) {");
          stream.println(ind(3) +   "// the region may have inner rewrites");
          stream.println(ind(3) +   "innerRewrite = inc_checkRegionForInnerRewrite();");
          stream.println(ind(2) + "} else {");
          stream.println(ind(3) +   "// region root had an inner rewrite which wasn't flushed");
          stream.println(ind(3) +   "innerRewrite = true;");
          stream.println(ind(2) + "}");
          stream.println(ind(2) + "// Inner rewrites in the region (including the root) means abort and notify the enclosing rewritten node");
          stream.println(ind(2) + "if (innerRewrite) {");
          stream.println(ind(3) +   "ASTNode enclosingNode = inc_locateEnclosingRewrittenNode();");
          stream.println(ind(3) +   "enclosingNode.handler().flushRegion();");
          stream.println(ind(3) +   "return false;");
          stream.println(ind(2) + "}");
          stream.println(ind(2) + "// Check NTAs, this may remove the region");
          stream.println(ind(2) + "boolean regionRemoved = false;");
          stream.println(ind(2) + "if (parent != null) {");
          stream.println(ind(3) +   "regionRemoved = parent.inc_flush_NTA(this);     // check NTA");
          stream.println(ind(2) + "}");
          stream.println(ind(2) + "// region is still here, flush remaining values and outer rewrites");
          stream.println(ind(2) + "if (!regionRemoved) {");
          stream.println(ind(3) +   "inc_flushRegion_rewrites();");
          stream.println(ind(3) +   "inc_flushRegion();");
          stream.println(ind(2) + "}");
          stream.println(ind(2) + "return true;"); 
          stream.println(ind + "}"); 
        }
        if (ASTNode.incrementalLevelNode) {
          stream.println(ind(2) + "inc_flush();");
          stream.println(ind(2) + "boolean rewriteFlushed = true;");
          stream.println(ind(2) + "if (parent != null) {");
          stream.println(ind(3) +   "rewriteFlushed = parent.inc_flush_child(this);");
          stream.println(ind(3) +   "// region root had an outer rewrite which was flushed (parent == null) -> done");
          stream.println(ind(3) +   "if (rewriteFlushed && parent == null) {");
          stream.println(ind(4) +     "return true;");
          stream.println(ind(3) +   "}");
          stream.println(ind(2) + "}");
          stream.println(ind(2) + "if (!rewriteFlushed) {");
          stream.println(ind(3) +   "ASTNode enclosingNode = inc_locateEnclosingRewrittenNode();");
          stream.println(ind(3) +   "enclosingNode.handler().flushRegion();");
          stream.println(ind(3) +   "return false;");
          stream.println(ind(2) + "}");
          stream.println(ind(2) + "if (parent != null) {");
          stream.println(ind(3) +   "parent.inc_flush_NTA(this);     // check NTA");
          stream.println(ind(2) + "}");
          stream.println(ind(2) + "return true;"); 
          stream.println(ind + "}"); 
        }
      }
      // end method: inc_flushRegionRoot

      // method: inc_checkRegionForInnerRewrite
      if (ASTNode.incrementalLevelRegion || ASTNode.incrementalLevelNode || ASTNode.incrementalLevelAttr) {
        if (name().equals("ASTNode")) {
          stream.println(ind + "public boolean ASTNode.inc_checkRegionForInnerRewrite() {");
          stream.println(ind(2) + "for (int i = 0; children != null && rewritten_children != null && " + 
                                            "i < children.length && i < rewritten_children.length; i++) {");
          stream.println(ind(3) +   "ASTNode child = children[i];");
          if (ASTNode.incrementalLevelRegion || ASTNode.incrementalLevelNode) {
          stream.println(ind(3) +   "if (child != null && !child.isRegionRoot()) {");
          } 
          if (ASTNode.incrementalLevelAttr) {
          stream.println(ind(3) +   "if (child != null) {");
          }
          stream.println(ind(4) +     "if (rewritten_children[i]) {");
          stream.println(ind(5) +       "if (init_children != null && i < init_children.length && init_children[i] == null) {");
          stream.println(ind(6) +         "return true;");
          stream.println(ind(5) +       "}");
          stream.println(ind(4) +     "}");
          if (ASTNode.incrementalLevelRegion || ASTNode.incrementalLevelNode) {
          stream.println(ind(4) +     "else {");
          stream.println(ind(5) +       "if (child.inc_checkRegionForInnerRewrite()) {");
          stream.println(ind(6) +         "return true;");
          stream.println(ind(5) +       "}");
          stream.println(ind(4) +     "}");
          }
          stream.println(ind(3) +   "}");
          stream.println(ind(2) + "}");
          stream.println(ind(2) + "return false;");
          stream.println(ind + "}");
        }
      }
      // end method: inc_checkRegionForInnerRewrite

      // method: inc_flushRegion
      if (ASTNode.incrementalLevelRegion) {
        stream.println(ind + "public void " + name() + ".inc_flushRegion() {");
        if (name().equals("ASTNode")) {
          stream.println(ind(2) + "inc_flush();");
          stream.println(ind(2) + "for (int i = 0; children != null && i < children.length; i++) {");
          stream.println(ind(3) +   "ASTNode child = children[i];");
          stream.println(ind(3) +   "if (child != null && !child.isRegionRoot()) {");
          stream.println(ind(4) +     "child.inc_flushRegion();");
          stream.println(ind(3) +   "}");
          stream.println(ind(2) + "}");
        } else {
          stream.println(ind(2) + "super.inc_flushRegion();");
        }
        // Flush NTAs if not region root
        for(Iterator itr = list.iterator(); itr.hasNext();) {
          AttrDecl attr = (AttrDecl)itr.next();
          // NTAs
          if ((attr.isNTA() || attr.getNTA()) && !attr.isPrimitive() 
                && !(attr.type().equals("String") || attr.type().equals("java.lang.String"))) {

            if (attr.getNumParameter() > 0) {
              stream.println(ind(2) + "if (" + attr.attributeSignature() + "_list != null) {");
              stream.println(ind(3) +   "for (int index = 0; index < " + attr.attributeSignature() + 
                                              "_list.numChildren; index++) {");
              stream.println(ind(4) +     "ASTNode value = " + attr.attributeSignature() + 
                                              "_list.children[index];");              
              stream.println(ind(4) +     "if (!value.isRegionRoot()) {");
              stream.println(ind(5) +       "state().enterConstruction();");
              stream.println(ind(5) +       attr.attributeSignature() + "_list.removeChild(index);");
              // removeChild will decrease the index of all remaining children and numChildren
              // hence, to visit the remainder of the list index need to be decreased by one for each removeChild
              stream.println(ind(5) +       "index--;"); 
              stream.println(ind(5) +       "state().exitConstruction();");
              stream.println(ind(5) +       "value.inc_flush_subtree(handler());");
              // remove the value in the NTA values map
              stream.println(ind(5) +       "for (java.util.Iterator itr = " + attr.attributeSignature() + "_values.keySet().iterator(); itr.hasNext();) {");
              stream.println(ind(6) +         "Object key = itr.next();");
              stream.println(ind(6) +         "if (" + attr.attributeSignature() + "_values.get(key) == value) {");
              stream.println(ind(7) +           attr.attributeSignature() + "_values.remove(key);");
              stream.println(ind(7) +           "break;");
              stream.println(ind(6) +         "}");
              stream.println(ind(5) +       "}");
//              String u = attr.resetVisit() + attr.resetCache();
//              u = u.replaceAll("#NAME#", attr.attributeSignature());
//              stream.print(u);
              //if (ASTNode.incrementalTrack) {
              //  stream.println(ind(3) + "ASTNode$DepGraphNode.trackedFlushes++;");
              //}
              //stream.println(ind(5) +       "return true;");
              stream.println(ind(4) +     "}");
              stream.println(ind(3) +   "}");
              stream.println(ind(2) + "}");
            } else {
              Components comp = attr.findCorrespondingNTA();
//              if (comp == null || !(comp instanceof OptionalComponentNTA || comp instanceof ListComponentsNTA)) {
              if (comp == null || comp instanceof OptionalComponentNTA || comp instanceof ListComponentsNTA) {
                stream.println(ind(2) + "if (" + attr.attributeSignature() + "_value != null && !" + 
                                                  attr.attributeSignature() + "_value.isRegionRoot()) {");
                stream.println(ind(3) +   "state().enterConstruction();");
                stream.println(ind(3) +   attr.attributeSignature() + "_value.setParent(null);");
                stream.println(ind(3) +   "state().exitConstruction();");
                stream.println(ind(3) +   attr.attributeSignature() + "_value.inc_flush_subtree(handler());");
                String u = attr.resetVisit() + attr.resetCache();
                u = u.replaceAll("#NAME#", attr.attributeSignature());
                stream.print(u);
                //if (ASTNode.incrementalTrack) {
                //  stream.println(ind(3) + "ASTNode$DepGraphNode.trackedFlushes++;");
                //}
                stream.println(ind(2) + "}");
              }
            }
          }
        }
        stream.println(ind + "}"); 
      }
      // end method: inc_flushRegion

      // method: inc_flushRegion_rewrites
      if (ASTNode.incrementalLevelRegion || ASTNode.incrementalLevelAttr) {
        if (name().equals("ASTNode")) {
          stream.println(ind + "public boolean ASTNode.inc_flushRegion_rewrites() {");
          stream.println(ind(2) + "for (int i = 0; children != null && i < children.length; i++) {"); 
          stream.println(ind(3) +   "ASTNode child = children[i];");
          if (ASTNode.incrementalLevelRegion) {
            stream.println(ind(3) +   "if (child == null || child.isRegionRoot()) continue;");
            stream.println(ind(3) +   "// rewritten child");

            stream.println(ind(3) +   "if (rewritten_children != null && i < rewritten_children.length && " +
                                         "rewritten_children[i]) {");
            stream.println(ind(4) +     "if (!inc_restoreInitialForIndex(i, handler())) {");
            stream.println(ind(5) +       "return false;");
            stream.println(ind(4) +     "}");
            stream.println(ind(3) +   "}");
            stream.println(ind(3) +   "// not rewritten child");
            stream.println(ind(3) +   "else {");
            stream.println(ind(4) +     "if (!child.inc_flushRegion_rewrites()) {");
            stream.println(ind(5) +       "return false;");
            stream.println(ind(4) +     "}");
            stream.println(ind(3) +   "}");
          }
          if (ASTNode.incrementalLevelAttr) {
            stream.println(ind(3) +   "if (child == null) continue;");
            stream.println(ind(3) +   "// rewritten child");
            stream.println(ind(3) +   "if (rewritten_children != null && i < rewritten_children.length && " +
                                         "rewritten_children[i]) {");
            stream.println(ind(4) +     "if (!inc_restoreInitialForIndex(i, getChild_handler)) {");
            stream.println(ind(5) +       "return false;");
            stream.println(ind(4) +     "}");
            stream.println(ind(3) +   "}");
          }
          stream.println(ind(2) + "}"); 
          stream.println(ind(2) + "return true;");
          stream.println(ind + "}"); 
        }
      }      
      // end method: inc_flushRegion_rewrites


      // method: inc_flush_subtree
      if (ASTNode.incrementalLevelRegion || ASTNode.incrementalLevelNode || 
          ASTNode.incrementalLevelAttr || ASTNode.incrementalLevelParam) {
        stream.println(ind + "protected void " + name() + ".inc_flush_subtree(ASTNode$DepGraphNode h) {");
        stream.println(ind(2) + "inc_state = inc_GARBAGE;");
        // NTAs
        for(Iterator itr = list.iterator(); itr.hasNext();) {
          AttrDecl attr = (AttrDecl)itr.next(); 
          if ((attr.isNTA() || attr.getNTA()) && !attr.isPrimitive() 
              && !(attr.type().equals("String") || attr.type().equals("java.lang.String"))) {

            if (attr.getNumParameter() > 0) {
              stream.println(ind(2) + "if (" + attr.attributeSignature() + "_list != null) {");
              stream.println(ind(3) +   attr.attributeSignature() + "_list.inc_flush_subtree(h);");
              stream.println(ind(2) + "}");
            } else {
              Components comp = attr.findCorrespondingNTA();
              if (comp == null || !(comp instanceof OptionalComponentNTA || comp instanceof ListComponentsNTA)) {
                stream.println(ind(2) + "if (" + attr.attributeSignature() + "_value != null) {");
                stream.println(ind(3) +   attr.attributeSignature() + "_value.inc_flush_subtree(h);");
                stream.println(ind(2) + "}");
              }
            }
          }
        }

        // attributes and tokens
        if (ASTNode.incrementalLevelAttr) {
          for(Iterator itr = list.iterator(); itr.hasNext();) {
            AttrDecl attr = (AttrDecl)itr.next();
            stream.println(ind(2) + "h.transferSetsFrom(" + attr.attributeSignature() + "_handler);");
          }
          for (int c = 0; c < getNumComponents(); c++) {
             Components comp = getComponents(c);
             if (comp instanceof TokenComponent) {
              stream.println(ind(2) + "h.transferSetsFrom(get" + ((TokenComponent)comp).getTokenId().getID() + "_handler);");
             }
           }
        }
        if (ASTNode.incrementalLevelParam) {
          for(Iterator itr = list.iterator(); itr.hasNext();) {
            AttrDecl attr = (AttrDecl)itr.next();
            if (attr.getNumParameter() > 0) {
              stream.println(ind(2) + "if (" + attr.attributeSignature() + "_handler != null) {");
              stream.println(ind(3) +   "for (java.util.Iterator itr = " + attr.attributeSignature() + 
                                              "_handler.values().iterator(); itr.hasNext();) {");
              stream.println(ind(4) +     "h.transferSetsFrom((ASTNode$DepGraphNode)itr.next());");
              stream.println(ind(3) +   "}");
              stream.println(ind(2) + "}");
            } else {
              stream.println(ind(2) + "h.transferSetsFrom(" + attr.attributeSignature() + "_handler);");
            }
          }
          for (int c = 0; c < getNumComponents(); c++) {
             Components comp = getComponents(c);
             if (comp instanceof TokenComponent) {
              stream.println(ind(2) + "h.transferSetsFrom(get" + ((TokenComponent)comp).getTokenId().getID() + "_handler);");
             }
           }
        }

        if (name().equals("ASTNode")) {    
          stream.println(ind(2) + "// flush subtree of values, take sets from encountered handler and remove it from DDG");
          if (ASTNode.incrementalLevelRegion) {
            stream.println(ind(2) + "if (isRegionRoot()) {");
            stream.println(ind(3) +   "h.transferSetsFrom(handler());");
            stream.println(ind(2) + "}");
            stream.println(ind(2) + "inc_flush();");
          }
          if (ASTNode.incrementalLevelNode) {
            stream.println(ind(2) + "h.transferSetsFrom(handler());");
            stream.println(ind(2) + "inc_flush();");
          }
          if (ASTNode.incrementalLevelAttr) {
            stream.println(ind(3) +   "h.transferSetsFrom(getParent_handler);");
            stream.println(ind(3) +   "h.transferSetsFrom(getChild_handler);");
            stream.println(ind(3) +   "h.transferSetsFrom(numChildren_handler);");
          }
          if (ASTNode.incrementalLevelParam) {
            stream.println(ind(3) +   "h.transferSetsFrom(getParent_handler);");
            stream.println(ind(3) +   "h.transferSetsFrom(numChildren_handler);");
            stream.println(ind(3) +   "for (int i = 0; getChild_handler != null && i < getChild_handler.length; i++) {");
            stream.println(ind(4) +     "h.transferSetsFrom(getChild_handler[i]);");
            stream.println(ind(3) +   "}");
          }
          stream.println(ind(2) + "for (int i = 0; children != null && i < children.length; i++) {");
          stream.println(ind(3) +   "ASTNode child = children[i];");
          stream.println(ind(3) +   "if (child != null) {");
          stream.println(ind(4) +     "child.inc_flush_subtree(h);");
          stream.println(ind(3) +   "}");
          stream.println(ind(2) + "}");
        } else {
          stream.println(ind(2) + "super.inc_flush_subtree(h);");
        }
        stream.println(ind + "}"); 
      }
      // end method: inc_flush_subtree




    }

  }

  // ES_2011-09-20: Code generation for incremental evaluation, change strategy: flush
  public void ASTDecl.jjtGenIncrementalChangeFlush(PrintWriter stream) {

    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(2) + "inc_flushRegionRoot();");
      stream.println(ind(2) + "handler.notifyDependencies();");
    }
    if (ASTNode.incrementalLevelRegion) {
      if (isRegionRoot()) {
        stream.println(ind(2) + "if (inc_flushRegionRoot()) {");
        stream.println(ind(3) +   "handler.clearDependencies();");
        stream.println(ind(3) +   "handler.notifyDependencies();");      
        stream.println(ind(2) + "}");
      }
    }

    // flush child start
    if (ASTNode.incrementalLevelParam) {
      if (name().equals("ASTNode")) {
        // stream.println("    if (attrID.equals(\"getChild\") && !state().IN_REWRITE_EVAL) {");
        stream.println(ind(2) + "if (attrID.equals(\"getChild\")) {");
        stream.println(ind(3) +   "int i = (Integer)_parameters;");
        stream.println(ind(3) +   "if (rewritten_children != null && i < rewritten_children.length && rewritten_children[i]) {");
        // make sure this condition is false before calling notify, there may be a circular dependency resulting in a double
        // flush otherwise, a double flush will cause null to be moved in as the initial child
        stream.println(ind(4) +     "rewritten_children[i] = false;");
        stream.println(ind(4) +     "children[i].inc_resetRewrites();");
        stream.println(ind(4) +     "// outer rewrites");
        stream.println(ind(4) +     "if (init_children[i] != null) {");
        stream.println(ind(5) +       "// set up change");
        stream.println(ind(5) +       "ASTNode oldChild = children[i];");
        stream.println(ind(5) +       "ASTNode newChild = init_children[i];");
        stream.println(ind(5) +       "// make change");
//        stream.println(ind(5) +       "oldChild.inc_throwAway();");
        stream.println(ind(5) +       "oldChild.inc_flush_subtree(getChild_handler[i]);");
        stream.println(ind(5) +       "children[i] = newChild;");
        stream.println(ind(5) +       "init_children[i] = null;");
        stream.println(ind(5) +       "// set parents and notify");
        stream.println(ind(5) +       "newChild.setParent(this);");
        stream.println(ind(5) +       "getChild_handler[i].notifyDependencies();");    
        stream.println(ind(4) +     "}");
        stream.println(ind(4) +     "// inner rewrites");
        stream.println(ind(4) +     "else {");
        stream.println(ind(5) +       "inc_restoreEnclosingRewrite();");
        stream.println(ind(4) +     "}");
        stream.println(ind(3) +   "}");
        stream.println(ind(2) + "}");
      }
    }
    if (ASTNode.incrementalLevelAttr) {
      if (name().equals("ASTNode")) {
        stream.println(ind(2) + "if (attrID.equals(\"getChild\")) {");
        stream.println(ind(3) +   "if (inc_checkRegionForInnerRewrite()) {");
        stream.println(ind(4) +     "ASTNode enclosingNode = inc_locateEnclosingRewrittenNode();");
        stream.println(ind(4) +     "enclosingNode.getChild_handler.flushRegion();");
        stream.println(ind(4) +     "return;");
        stream.println(ind(3) +   "} else {");
        stream.println(ind(4) +     "inc_flushRegion_rewrites();");
        stream.println(ind(4) +     "getChild_handler.notifyDependencies();");
        stream.println(ind(4) +     "return;");
        stream.println(ind(3) +   "}");
        stream.println(ind(2) + "}");
      }
    }
    // flush child end


    // flush attributes start
    if (ASTNode.incrementalLevelAttr || ASTNode.incrementalLevelParam) {
      ArrayList list = new ArrayList();
      for(int k = 0; k < getNumSynEq(); k++) {
        AttrDecl attr = getSynEq(k).decl();
        if (attr != null && (attr.getLazy() || attr.isCircular())) 
          list.add(attr);
      }
      for(int k = 0; k < getNumInhDecl(); k++) {
        AttrDecl attr = getInhDecl(k);
        if (attr != null && (attr.getLazy() || attr.isCircular())) 
          list.add(attr);
      }

      // Add attribute code: flush attributes
      boolean first = true;
      for(Iterator itr = list.iterator(); itr.hasNext();) {
        AttrDecl attr = (AttrDecl)itr.next();

        // start match attribute statement
        if (ASTNode.incrementalLevelParam) {
          stream.print(ind(2) + (first ? "" : "else "));
          stream.print("if (" + "attrID.equals(\"" + attr.attributeSignature() + "\")");
          if (attr.getNumParameter() > 0) 
            stream.print(" && " + attr.attributeSignature() + "_values != null" + 
              " && " + attr.attributeSignature() + "_values.containsKey(_parameters)");
          else stream.print(" && " + attr.attributeSignature() + "_computed");
          stream.println(") {");
        }
        if (ASTNode.incrementalLevelAttr) {
          stream.print(ind(2) + (first ? "" : "else "));
          stream.print("if (attrID.equals(\"" + attr.attributeSignature() + "\")");
          if (attr.getNumParameter() > 0) {
            stream.print(" && " + attr.attributeSignature() + "_values != null" + 
              " && !" + attr.attributeSignature() + "_values.isEmpty()");  
          } else stream.println(" && " + attr.attributeSignature() + "_computed");
          stream.println(") {");
        }

        // handle parameterized attributes
        if (attr.getNumParameter() > 0) {

          if (ASTNode.incrementalLevelParam) {
            // handler NTA
            if ((attr.isNTA() || attr.getNTA()) && !attr.isPrimitive() 
                && !(attr.type().equals("String") || attr.type().equals("java.lang.String"))) {
              stream.println(ind(3) + attr.type() + " value = (" + attr.type() + ")" + attr.attributeSignature() + "_values.remove(_parameters);");                 
              stream.println(ind(3) + "for (int i = 0; i < " + attr.attributeSignature() + "_list.children.length; i++) {");
              stream.println(ind(4) +   "ASTNode child = " + attr.attributeSignature() + "_list.children[i];");
              stream.println(ind(4) +   "if (child != null && value == child) {");
              // using dummy node to flush dependencies from NTA 
//              stream.println(ind(5) +     "value.inc_flush_subtree(new ASTNode$DepGraphNode(new Opt(), \"\", null));");
              stream.println(ind(5) +     "value.inc_flush_subtree((ASTNode$DepGraphNode)" + 
                                        attr.attributeSignature() + "_handler.get(_parameters));");
              stream.println(ind(5) +     attr.attributeSignature() + "_list.removeChild(i);");
              stream.println(ind(5) +     "break;");
              stream.println(ind(4) +   "}");
              stream.println(ind(3) + "}");
            } else {
              stream.println(ind(3) + attr.attributeSignature() + "_values.remove(_parameters);"); 
            }
          } else {
            // handler NTA
            if ((attr.isNTA() || attr.getNTA()) && !attr.isPrimitive() 
                && !(attr.type().equals("String") || attr.type().equals("java.lang.String"))) {
                stream.println(ind(2) + "if (" + attr.attributeSignature() + "_list != null) {");
                stream.println(ind(3) +     attr.attributeSignature() + "_list.setParent(null);");
                // using dummy node to flush dependencies from NTA 
//                stream.println(ind(3) +     attr.attributeSignature() + 
//                                  "_value.inc_flush_subtree(new ASTNode$DepGraphNode(new Opt(), \"\", null))");
                stream.println(ind(3) +     attr.attributeSignature() + "_list.inc_flush_subtree(" + 
                                  attr.attributeSignature() + "_handler);");
                stream.println(ind(2) + "}");
            }
            String u = attr.resetVisit() + attr.resetCache();
            u = u.replaceAll("#NAME#", attr.attributeSignature());
            stream.print(u);              
          }

        } else {

          // handle NTAs
          if ((attr.isNTA() || attr.getNTA()) && !attr.isPrimitive() && 
                !(attr.type().equals("String") || attr.type().equals("java.lang.String"))) {
            stream.println(ind(3) + "if (" + attr.attributeSignature() + "_value instanceof ASTNode) {");
            stream.println(ind(4) + attr.attributeSignature() + "_value.setParent(null);");
            // using dummy node to flush dependencies from NTA 
            if (ASTNode.incrementalLevelParam) {
//              stream.println(ind(4) + attr.attributeSignature() + "_value.inc_flush_subtree(new ASTNode$DepGraphNode(new Opt(), \"\", null));");
              stream.println(ind(4) + attr.attributeSignature() + "_value.inc_flush_subtree(" + attr.attributeSignature() + "_handler);");
            }
            else if (ASTNode.incrementalLevelAttr) {
              stream.println(ind(4) + attr.attributeSignature() + "_value.inc_flush_subtree(new ASTNode$DepGraphNode(new Opt(), \"\"));");
            } else {
              stream.println(ind(4) + attr.attributeSignature() + "_value.inc_flush_subtree(new ASTNode$DepGraphNode(new Opt()));");
            }
            stream.println(ind(3) + "}");
          }

          String u = attr.resetVisit() + attr.resetCache();
          u = u.replaceAll("#NAME#", attr.attributeSignature());
          stream.print(u);

        }

        // notify
        if (ASTNode.incrementalLevelParam) {
          if (attr.getNumParameter() > 0) {
            stream.println(ind(3) +   "ASTNode$DepGraphNode handler = (ASTNode$DepGraphNode)" + 
                                        attr.attributeSignature() + "_handler.remove(_parameters);");
            stream.println(ind(3) +   "handler.throwAway();");
            stream.println(ind(3) +   "handler.notifyDependencies();");
          } else {
            stream.println(ind(3) + attr.attributeSignature() + "_handler.notifyDependencies();");
          }
          if (!name().equals("ASTNode"))
            stream.println(ind(3) +   "super.reactToDependencyChange(attrID, _parameters);");
        } 
        if (ASTNode.incrementalLevelAttr) {
          stream.println(ind(3) + attr.attributeSignature() + "_handler.notifyDependencies();");
          stream.println(ind(3) +   "super.reactToDependencyChange(attrID);");
        }
      
        stream.println(ind(3) +   "return;");
        stream.println(ind(2) + "}");      // end match statement
        first = false;
      }  
    }
  }

  // ES_2011-09-20: Code generation for incremental evaluation, 
  public void ASTDecl.jjtGenIncrementalReactToASTChange(PrintWriter stream) {

    /*
    if (ASTNode.incrementalDebug) {

      // method: inc_clearDepsInTree
      stream.println(ind + "public void " + name() + ".inc_clearDepsInTree() {");
      if (name().equals("ASTNode")) {
        if (ASTNode.incrementalLevelParam) {
        stream.println(ind(2) + "getParent_handler.clearDependants();");
        stream.println(ind(2) + "numChildren_handler.clearDependants();");
        stream.println(ind(2) + "for (int i = 0; i < numChildren; i++) {");
        stream.println(ind(3) +   "if (!childIsNTA(i) && getChild_handler[i].hasDependants()) {");
        stream.println(ind(4) +     "getChildNoTransform(i).inc_clearDepsInTree();");
        stream.println(ind(4) +     "getChild_handler[i].clearDependants();");
        stream.println(ind(3) +   "}");
        stream.println(ind(2) + "}");
        }
        if (ASTNode.incrementalLevelAttr) {
        stream.println(ind(2) + "getParent_handler.clearDependants();");
        stream.println(ind(2) + "numChildren_handler.clearDependants();");
        stream.println(ind(2) + "if (getChild_handler.hasDependants()) {");
        stream.println(ind(3) +   "getChild_handler.clearDependants();");
        stream.println(ind(3) +   "for (int i = 0; i < getNumChildNoTransform(); i++) {");
        stream.println(ind(4) +     "getChildNoTransform(i).inc_clearDepsInTree();");
        stream.println(ind(3) +   "}");
        stream.println(ind(2) + "}");
        }
        if (ASTNode.incrementalLevelNode) {
        stream.println(ind(2) + "handler.clearDependants();");
        stream.println(ind(2) + "for (int i = 0; i < getNumChildNoTransform(); i++) {");
        stream.println(ind(3) +   "getChildNoTransform(i).inc_clearDepsInTree();");
        stream.println(ind(2) + "}");
        }
      } else {
        stream.println(ind(2) + "super.inc_clearDepsInTree();");
        if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
        // tokens
        for (int c = 0; c < getNumComponents(); c++) {
           Components comp = getComponents(c);
           if (!(comp instanceof TokenComponent)) continue;
          stream.println(ind(2) + "if (get" + ((TokenComponent)comp).getTokenId().getID() + "_handler != null) {");
          stream.println(ind(3) +   "get" + ((TokenComponent)comp).getTokenId().getID() + "_handler.clearDependants();");
           stream.println(ind(2) + "}");
        }
        }
        // collect attributes: syn then inh
        ArrayList list = new ArrayList();
        for(int k = 0; k < getNumSynEq(); k++) {
          AttrDecl attr = getSynEq(k).decl();
          if (attr != null && (attr.getLazy() || attr.isCircular())) 
            list.add(attr);
        }
        for(int k = 0; k < getNumInhDecl(); k++) {
          AttrDecl attr = getInhDecl(k);
          if (attr != null && (attr.getLazy() || attr.isCircular())) 
            list.add(attr);
        }
        // attributes
        for(Iterator itr = list.iterator(); itr.hasNext();) {
          AttrDecl attr = (AttrDecl)itr.next();
          if (ASTNode.incrementalLevelParam) {
            if (attr.getNumParameter() > 0) {
            stream.println(ind(2) + "for (java.util.Iterator itr = " + attr.attributeSignature() + 
                                    "_handler.values().iterator(); itr.hasNext();) {");
            stream.println(ind(3) +   "ASTNode$DepGraphNode handler = (ASTNode$DepGraphNode)itr.next();");
            stream.println(ind(3) +   "handler.clearDependants();");
            stream.println(ind(2) + "}");
            } else {
            stream.println(ind(2) + "if (" + attr.attributeSignature() + "_handler != null) {");
            stream.println(ind(3) +   attr.attributeSignature() + "_handler.clearDependants();");
            stream.println(ind(2) + "}");
            }
          }
          if (ASTNode.incrementalLevelAttr) {
            stream.println(ind(2) + "if (" + attr.attributeSignature() + "_handler != null) {");
            stream.println(ind(3) +   attr.attributeSignature() + "_handler.clearDependants();");
             stream.println(ind(2) + "}");
          }
        }    
      stream.println(ind + "}");  // end method: inc_clearDepsInTree
    }
    */


    // method: inc_notifyForRemove
    if (name().equals("ASTNode")) {  
      stream.println(ind + "public void ASTNode.inc_notifyForRemove() {");
      if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
        stream.println(ind(2) + "getParent_handler.notifyDependencies();");
      }
      if (ASTNode.incrementalLevelNode) {
        stream.println(ind(2) + "handler.flushRegion();");
      }
      if (ASTNode.incrementalLevelRegion) {
        stream.println(ind(2) + "handler().flushRegion();");
      }
      stream.println(ind + "}"); 
    } 
    // end method: inc_notifyForRemove

  }



  // ES_2011-11-28: Code generation for incremental evaluation, state handling
  public void ASTDecl.jjtGenIncrementalState(PrintWriter stream) {

    // states
    if (name().equals("ASTNode")) {
    stream.println(ind + "public static final int ASTNode.inc_CREATED = 0;");  
    stream.println(ind + "public static final int ASTNode.inc_CLONED = 1;");  
    stream.println(ind + "public static final int ASTNode.inc_LIVE = 2;");  
    stream.println(ind + "public static final int ASTNode.inc_GARBAGE = 3;");  
    stream.println(ind + "public int ASTNode.inc_state = inc_CREATED;");  
    }

    // Collect attributes: syn then inh
    ArrayList list = new ArrayList();
    for(int k = 0; k < getNumSynEq(); k++) {
      AttrDecl attr = getSynEq(k).decl();
      if (attr != null && (attr.getLazy() || attr.isCircular())) 
        list.add(attr);
    }
    for(int k = 0; k < getNumInhDecl(); k++) {
      AttrDecl attr = getInhDecl(k);
      if (attr != null && (attr.getLazy() || attr.isCircular())) 
        list.add(attr);
    }


    // Method: inc_changeState
    stream.println(ind + "public void " + name() + ".inc_changeState(int newState) {");
    if (name().equals("ASTNode")) {
      stream.println(ind(2) + "inc_state = newState;");
      if (ASTNode.incrementalLevelParam) {
        stream.println(ind(2) + "getParent_handler.changeState(newState);");
        stream.println(ind(2) + "numChildren_handler.changeState(newState);");
        stream.println(ind(2) + "for (int i = 0; children != null && i < children.length; i++) {");
        stream.println(ind(3) +   "ASTNode child = children[i];");
        stream.println(ind(3) +   "if (getChild_handler[i] != null)");
        stream.println(ind(4) +     "getChild_handler[i].changeState(newState);");
        stream.println(ind(3) +   "if (child != null) child.inc_changeState(newState);");
        stream.println(ind(2) + "}");
      }
      if (ASTNode.incrementalLevelAttr) {
        stream.println(ind(2) + "getParent_handler.changeState(newState);");
        stream.println(ind(2) + "numChildren_handler.changeState(newState);");
        stream.println(ind(2) + "getChild_handler.changeState(newState);");
        stream.println(ind(2) + "for (int i = 0; children != null && i < children.length; i++) {");
        stream.println(ind(3) +   "ASTNode child = children[i];");
        stream.println(ind(3) +   "if (child != null) child.inc_changeState(newState);");
        stream.println(ind(2) + "}");
      }
      if (ASTNode.incrementalLevelNode) {
        stream.println(ind(2) + "handler.changeState(newState);");
        stream.println(ind(2) + "for (int i = 0; children != null && i < children.length; i++) {");
        stream.println(ind(3) +   "ASTNode child = children[i];");
        stream.println(ind(3) +   "if (child != null) child.inc_changeState(newState);");
        stream.println(ind(2) + "}");
      }
      if (ASTNode.incrementalLevelRegion) {
        stream.println(ind(2) + "if (isRegionRoot()) handler().changeState(newState);");
        stream.println(ind(2) + "for (int i = 0; children != null && i < children.length; i++) {");
        stream.println(ind(3) +   "ASTNode child = children[i];");
        stream.println(ind(3) +   "if (child != null) child.inc_changeState(newState);");
        stream.println(ind(2) + "}");
      }
    } else {
      stream.println(ind(2) + "super.inc_changeState(newState);");
      if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
        // tokens
        for (int c = 0; c < getNumComponents(); c++) {
           Components comp = getComponents(c);
           if (comp instanceof TokenComponent) {
            stream.println(ind(2) + "if (get" + ((TokenComponent)comp).getTokenId().getID() + "_handler != null) {");
            stream.println(ind(3) +   "get" + ((TokenComponent)comp).getTokenId().getID() + "_handler.changeState(newState);");
            stream.println(ind(2) + "}");

           }
         }
      }
      // attributes
      for(Iterator itr = list.iterator(); itr.hasNext();) {
        AttrDecl attr = (AttrDecl)itr.next();
        // handlers
        if (ASTNode.incrementalLevelParam) {
          if (attr.getNumParameter() > 0) {
            stream.println(ind(2) + "for (java.util.Iterator itr = " + attr.attributeSignature() + 
                                  "_handler.values().iterator(); itr.hasNext();) {");
            stream.println(ind(3) +   "ASTNode$DepGraphNode handler = (ASTNode$DepGraphNode)itr.next();");
            stream.println(ind(3) +   "handler.changeState(newState);");
            stream.println(ind(2) + "}");
          } else {
            stream.println(ind(2) + "if (" + attr.attributeSignature() + "_handler != null) {");
            stream.println(ind(3) +   attr.attributeSignature() + "_handler.changeState(newState);");
            stream.println(ind(2) + "}");
          }
        }
        if (ASTNode.incrementalLevelAttr) {
          stream.println(ind(2) + "if (" + attr.attributeSignature() + "_handler != null) {");
          stream.println(ind(3) +   attr.attributeSignature() + "_handler.changeState(newState);");
          stream.println(ind(2) + "}");
        }
        // values for NTAs
        if ((attr.isNTA() || attr.getNTA()) && !attr.isPrimitive() && 
            !(attr.type().equals("String") || attr.type().equals("java.lang.String"))) {
          if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr || 
              ASTNode.incrementalLevelNode || ASTNode.incrementalLevelRegion) {
            if (attr.getNumParameter() > 0) {
              stream.println(ind(2) + "if (" + attr.attributeSignature() + "_list != null) {");
              stream.println(ind(3) +   attr.attributeSignature() + "_list.inc_changeState(newState);");
              stream.println(ind(2) + "}");
            } else {
              stream.println(ind(2) + "if (" + attr.attributeSignature() + "_computed && (" +
                                      attr.attributeSignature() + "_value instanceof ASTNode)) {");
              stream.println(ind(3) + attr.attributeSignature() + "_value.inc_changeState(newState);");
              stream.println(ind(2) + "}");
            }
          }
        }
      }    
    }
    stream.println(ind + "}");    // end method: inc_changeState



    // method: inc_throwAway
    stream.println(ind + "public void " + name() + ".inc_throwAway() {");
    stream.println(ind(2) + "inc_state = inc_GARBAGE;");
    if (name().equals("ASTNode")) {
      if (ASTNode.incrementalLevelParam) {
        stream.println(ind(2) + "getParent_handler.throwAway();");
        stream.println(ind(2) + "numChildren_handler.throwAway();");
        stream.println(ind(2) + "for (int i = 0; children != null && i < children.length; i++) {");
        stream.println(ind(3) +   "ASTNode child = children[i];");
        stream.println(ind(3) +   "if (getChild_handler[i] != null)");
        stream.println(ind(4) +     "getChild_handler[i].throwAway();");
        stream.println(ind(3) +   "if (child != null) child.inc_throwAway();");
        stream.println(ind(3) +   "if (init_children != null && i < init_children.length && init_children[i] != null) {");
        stream.println(ind(4) +     "init_children[i].inc_throwAway();");
        stream.println(ind(3) +   "}");
        stream.println(ind(2) + "}");
      }
      if (ASTNode.incrementalLevelAttr) {
        stream.println(ind(2) + "getParent_handler.throwAway();");
        stream.println(ind(2) + "numChildren_handler.throwAway();");
        stream.println(ind(2) + "getChild_handler.throwAway();");
        stream.println(ind(2) + "for (int i = 0; children != null && i < children.length; i++) {");
        stream.println(ind(3) +   "ASTNode child = children[i];");
        stream.println(ind(3) +   "if (child != null) child.inc_throwAway();");
        stream.println(ind(3) +   "if (init_children != null && i < init_children.length && init_children[i] != null) {");
        stream.println(ind(4) +     "init_children[i].inc_throwAway();");
        stream.println(ind(3) +   "}");
        stream.println(ind(2) + "}");
      }
      if (ASTNode.incrementalLevelNode) {
        stream.println(ind(2) + "handler.throwAway();");
        stream.println(ind(2) + "for (int i = 0; children != null && i < children.length; i++) {");
        stream.println(ind(3) +   "ASTNode child = children[i];");
        stream.println(ind(3) +   "if (child != null) child.inc_throwAway();");
        stream.println(ind(3) +   "if (init_children != null && i < init_children.length && init_children[i] != null) {");
        stream.println(ind(4) +     "init_children[i].inc_throwAway();");
        stream.println(ind(3) +   "}");
        stream.println(ind(2) + "}");
      }
      if (ASTNode.incrementalLevelRegion) {
        stream.println(ind(2) + "if (isRegionRoot()) handler().throwAway();");
        stream.println(ind(2) + "for (int i = 0; children != null && i < children.length; i++) {");
        stream.println(ind(3) +   "ASTNode child = children[i];");
        stream.println(ind(3) +   "if (child != null) child.inc_throwAway();");
        stream.println(ind(3) +   "if (init_children != null && i < init_children.length && init_children[i] != null) {");
        stream.println(ind(4) +     "init_children[i].inc_throwAway();");
        stream.println(ind(3) +   "}");
        stream.println(ind(2) + "}");
      }
    } else {
      stream.println(ind(2) + "super.inc_throwAway();");
      if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
        // tokens
        for (int c = 0; c < getNumComponents(); c++) {
           Components comp = getComponents(c);
           if (comp instanceof TokenComponent) {
            stream.println(ind(2) + "if (get" + ((TokenComponent)comp).getTokenId().getID() + "_handler != null) {");
            stream.println(ind(3) +   "get" + ((TokenComponent)comp).getTokenId().getID() + "_handler.throwAway();");
            stream.println(ind(2) + "}");
           }
         }
      }
      // attributes
      for(Iterator itr = list.iterator(); itr.hasNext();) {
        AttrDecl attr = (AttrDecl)itr.next();
        // handlers
        if (ASTNode.incrementalLevelParam) {
          if (attr.getNumParameter() > 0) {
            stream.println(ind(2) + "for (java.util.Iterator itr = " + attr.attributeSignature() + 
                                  "_handler.values().iterator(); itr.hasNext();) {");
            stream.println(ind(3) +   "ASTNode$DepGraphNode handler = (ASTNode$DepGraphNode)itr.next();");
            stream.println(ind(3) +   "handler.throwAway();");
            stream.println(ind(2) + "}");
          } else {
            stream.println(ind(2) + "if (" + attr.attributeSignature() + "_handler != null) {");
            stream.println(ind(3) +   attr.attributeSignature() + "_handler.throwAway();");
            stream.println(ind(2) + "}");
          }
        }
        if (ASTNode.incrementalLevelAttr) {
          stream.println(ind(2) + "if (" + attr.attributeSignature() + "_handler != null) {");
          stream.println(ind(3) +   attr.attributeSignature() + "_handler.throwAway();");
          stream.println(ind(2) + "}");
        }
        // values for NTAs
        if ((attr.isNTA() || attr.getNTA()) && !attr.isPrimitive() && 
            !(attr.type().equals("String") || attr.type().equals("java.lang.String"))) {
          if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr || 
              ASTNode.incrementalLevelNode || ASTNode.incrementalLevelRegion) {
            if (attr.getNumParameter() > 0) {
              stream.println(ind(2) + "if (" + attr.attributeSignature() + "_list != null) {");
              stream.println(ind(3) +   attr.attributeSignature() + "_list.inc_throwAway();");
              stream.println(ind(2) + "}");
            } else {
              stream.println(ind(2) + "if (" + attr.attributeSignature() + "_computed && (" +
                                      attr.attributeSignature() + "_value instanceof ASTNode)) {");
              stream.println(ind(3) + attr.attributeSignature() + "_value.inc_throwAway();");
              stream.println(ind(2) + "}");
            }
          }
        }
      }    
    }
    stream.println(ind + "}");    
    // end method: inc_throwAway

    /*
    // method: inc_cleanUpGarbage
    stream.println(ind + "public void " + name() + ".inc_cleanUpGarbage() {");
    if (name().equals("ASTNode")) {
      if (ASTNode.incrementalLevelParam) {
        stream.println(ind(2) + "getParent_handler.cleanUpGarbage();");
        stream.println(ind(2) + "numChildren_handler.cleanUpGarbage);");
        stream.println(ind(2) + "for (int i = 0; children != null && i < children.length; i++) {");
        stream.println(ind(3) +   "ASTNode child = children[i];");
        stream.println(ind(3) +   "if (getChild_handler[i] != null) getChild_handler[i].cleanUpGarbage();");
        stream.println(ind(3) +   "if (child != null) child.inc_cleanUpGarbage();");
        stream.println(ind(3) +   "if (init_children != null && i < init_children.length && init_children[i] != null) {");
        stream.println(ind(4) +     "init_children[i].inc_cleanUpGarbage();");
        stream.println(ind(3) +   "}");
        stream.println(ind(2) + "}");
      }
      if (ASTNode.incrementalLevelAttr) {
        stream.println(ind(2) + "getParent_handler.cleanUpGarbage();");
        stream.println(ind(2) + "numChildren_handler.cleanUpGarbage();");
        stream.println(ind(2) + "getChild_handler.cleanUpGarbage();");
        stream.println(ind(2) + "for (int i = 0; children != null && i < children.length; i++) {");
        stream.println(ind(3) +   "ASTNode child = children[i];");
        stream.println(ind(3) +   "if (child != null) child.inc_cleanUpGarbage();");
        stream.println(ind(3) +   "if (init_children != null && i < init_children.length && init_children[i] != null) {");
        stream.println(ind(4) +     "init_children[i].inc_cleanUpGarbage();");
        stream.println(ind(3) +   "}");
        stream.println(ind(2) + "}");
      }
      if (ASTNode.incrementalLevelNode) {
        stream.println(ind(2) + "handler.cleanUpGarbage();");
        stream.println(ind(2) + "for (int i = 0; children != null && i < children.length; i++) {");
        stream.println(ind(3) +   "ASTNode child = children[i];");
        stream.println(ind(3) +   "if (child != null) child.inc_cleanUpGarbage();");
        stream.println(ind(3) +   "if (init_children != null && i < init_children.length && init_children[i] != null) {");
        stream.println(ind(4) +     "init_children[i].inc_cleanUpGarbage();");
        stream.println(ind(3) +   "}");
        stream.println(ind(2) + "}");
      }
    } else {
      stream.println(ind(2) + "super.inc_cleanUpGarbage();");
      if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
        // tokens
        for (int c = 0; c < getNumComponents(); c++) {
           Components comp = getComponents(c);
           if (comp instanceof TokenComponent) {
            stream.println(ind(2) + "if (get" + ((TokenComponent)comp).getTokenId().getID() + "_handler != null) {");
            stream.println(ind(3) +   "get" + ((TokenComponent)comp).getTokenId().getID() + "_handler.cleanUpGarbage();");
            stream.println(ind(2) + "}");
           }
         }
      }
      // attributes
      for(Iterator itr = list.iterator(); itr.hasNext();) {
        AttrDecl attr = (AttrDecl)itr.next();
        if (ASTNode.incrementalLevelParam) {
          if (attr.getNumParameter() > 0) {
            stream.println(ind(2) + "for (java.util.Iterator itr = " + attr.attributeSignature() + 
                                  "_handler.values().iterator(); itr.hasNext();) {");
            stream.println(ind(3) +   "ASTNode$DepGraphNode handler = (ASTNode$DepGraphNode)itr.next();");
            stream.println(ind(3) +   "handler.cleanUpGarbage();");
            if ((attr.isNTA() || attr.getNTA()) && !attr.isPrimitive() && 
                !(attr.type().equals("String") || attr.type().equals("java.lang.String"))) {
              stream.println(ind(3) + "if (" + attr.attributeSignature() + "_computed && (" +
                                        attr.attributeSignature() + "_value instanceof ASTNode)) {");
              stream.println(ind(4) + attr.attributeSignature() + "_value.inc_cleanUpGarbage();");
              stream.println(ind(3) + "}");
            }
            stream.println(ind(2) + "}");
          } else {
            stream.println(ind(2) + "if (" + attr.attributeSignature() + "_handler != null) {");
            stream.println(ind(3) +   attr.attributeSignature() + "_handler.cleanUpGarbage();");
            if ((attr.isNTA() || attr.getNTA()) && !attr.isPrimitive() && 
                !(attr.type().equals("String") || attr.type().equals("java.lang.String"))) {
              stream.println(ind(3) + "if (" + attr.attributeSignature() + "_computed && (" +
                                        attr.attributeSignature() + "_value instanceof ASTNode)) {");
              stream.println(ind(4) + attr.attributeSignature() + "_value.inc_cleanUpGarbage();");
              stream.println(ind(3) + "}");
            }
            stream.println(ind(2) + "}");
          }
        }
        if (ASTNode.incrementalLevelAttr) {
          stream.println(ind(2) + "if (" + attr.attributeSignature() + "_handler != null) {");
          stream.println(ind(3) +   attr.attributeSignature() + "_handler.cleanUpGarbage();");
          stream.println(ind(2) + "}");
        }
        if (ASTNode.incrementalLevelAttr || ASTNode.incrementalLevelNode) {
          if ((attr.isNTA() || attr.getNTA()) && !attr.isPrimitive() && 
              !(attr.type().equals("String") || attr.type().equals("java.lang.String"))) {
            if (attr.getNumParameter() > 0) {
              stream.println(ind(2) + "if (" + attr.attributeSignature() + "_list != null) {");
              stream.println(ind(3) +   attr.attributeSignature() + "_list.inc_cleanUpGarbage();");
              stream.println(ind(2) + "}");
            } else {
              stream.println(ind(2) + "if (" + attr.attributeSignature() + "_computed && (" +
                                      attr.attributeSignature() + "_value instanceof ASTNode)) {");
              stream.println(ind(3) + attr.attributeSignature() + "_value.inc_cleanUpGarbage();");
              stream.println(ind(2) + "}");
            }
          }
        }
      }    
    }
    stream.println(ind + "}");    
    // end method: inc_cleanUpGarbage
    */
  } // end: jjtGenIncrementalState


  // ES_2011-12-05: Regions for incremental evaluation
  public void ASTDecl.jjtGenIncrementalRegions(PrintWriter stream) {

    // method: isRegionRoot()
    if (ASTNode.incrementalLevelNode) {
      if (name().equals("ASTNode")) {
        stream.println(ind + "public boolean ASTNode.isRegionRoot() {");
        stream.println(ind(2) + "return true;");
        stream.println(ind + "}"); 
      }
    }
    if (ASTNode.incrementalLevelRegion) {
      stream.println(ind + "public boolean " + name() + ".isRegionRoot() {");
      if (isRegionRoot())
        stream.println(ind(2) + "return true;");
      else {
        if (name().equals("ASTNode")) {
          stream.println(ind(2) + "return false;");
        } else { 
          stream.println(ind(2) + "return super.isRegionRoot();");
        }
      }
      stream.println(ind + "}"); 
    }
    // method end: isRegionRoot()

    // method: regionRoot()
    if (ASTNode.incrementalLevelRegion) {
      if (name().equals("ASTNode")) {
        if (isRegionRoot()) {
          stream.println(ind + "public ASTNode " + name() + ".regionRoot() {");
          stream.println(ind(2) + "return this;");
          stream.println(ind + "}"); 
        } else {
          stream.println(ind + "public ASTNode " + name() + ".regionRoot() {");
          stream.println(ind(2) + "return parent != null ? parent.regionRoot() : null;");
          stream.println(ind + "}"); 
        }
      } else {
      if (isRegionRoot()) {
        stream.println(ind + "public ASTNode " + name() + ".regionRoot() {");
        stream.println(ind(2) + "return this;");
        stream.println(ind + "}"); 
      } else {
        stream.println(ind + "public ASTNode " + name() + ".regionRoot() {");
        stream.println(ind(2) + "return super.regionRoot();");
        stream.println(ind + "}"); 
      }
      }
    }
    // method end: regionRoot()

    // method: handler()
    if (ASTNode.incrementalLevelRegion) {
      if (isRegionRoot()) {
        stream.println(ind + "public ASTNode$DepGraphNode " + name() + ".handler() {");
        stream.println(ind(2) + "return handler;");
        stream.println(ind + "}"); 
      } else {
        stream.println(ind + "public ASTNode$DepGraphNode " + name() + ".handler() {");
        if (name().equals("ASTNode")) {
          stream.println(ind(2) + "ASTNode root = regionRoot();");
          stream.println(ind(2) + "return root != null ? root.handler() : null;");
        } else {
          stream.println(ind(2) + "ASTNode$DepGraphNode h = super.handler();");
          stream.println(ind(2) + "if (h != null) return h;");
          stream.println(ind(2) + "ASTNode root = regionRoot();");
          stream.println(ind(2) + "return root != null ? root.handler() : null;");
        }
        stream.println(ind + "}"); 
      }
    }
    if (ASTNode.incrementalLevelNode) {
      if (name().equals("ASTNode")) {
        stream.println(ind + "public ASTNode$DepGraphNode ASTNode.handler() {");
        stream.println(ind(2) + "return handler;");
        stream.println(ind + "}"); 
      }
    }
    // method end: handler()

    // method: getParent() -- overloaded for region tracking
    if (ASTNode.incrementalLevelRegion) {
      if (isRegionRoot() && !name().equals("ASTNode")) {
        stream.println(ind + "public ASTNode " + name() + ".getParent() {");
        stream.println(ind(2) + "// region root");
        stream.println(ind(2) + "ASTNode parent = super.getParent();");
        stream.println(ind(2) + "if (state().IN_COMPUTATION > 0 && parent != null)");
        stream.println(ind(3) +   "parent.handler().addDependant(handler);");
        stream.println(ind(2) + "return parent;");
        stream.println(ind + "}");          
      }
    }
    // end method: getParent() -- overloaded for region tracking

    // method: getChild(int) -- overloaded for region tracking
    if (ASTNode.incrementalLevelRegion) {
//      stream.println(ind + "private boolean " + name() + ".IS_REGION_LEAF = " + isRegionLeaf() + ";");
//      stream.println(ind + "private boolean " + name() + ".IS_REGION_ROOT = " + isRegionRoot() + ";");

      if (isRegionLeaf()) {
        if (name().equals("List") || name().equals("Opt")) {
          if(ASTNode.java5) {
            stream.println(ind + "/**");
            stream.println(ind + " * @apilevel low-level");
            stream.println(ind + " */");
            stream.println(ind + "@SuppressWarnings(\"cast\") public T " + name() + ".getChild(int i) {");
            stream.println(ind(2) + "// region leaf");
            stream.println(ind(2) + "ASTNode child = super.getChild(i);");
            stream.println(ind(2) + "if (state().IN_COMPUTATION > 0 && child.isRegionRoot()) {");
            stream.println(ind(3) +   "child.handler().addDependant(handler());");
            stream.println(ind(2) + "}");
            stream.println(ind(2) + "return (T)child;");
            stream.println(ind + "}");    
            stream.println(ind + "/**");
            stream.println(ind + " * @apilevel low-level");
            stream.println(ind + " */");
            stream.println(ind + "@SuppressWarnings(\"cast\") public T " + name() + ".getChildNoTransform(int i) {");
            stream.println(ind(2) + "// region leaf");
            stream.println(ind(2) + "ASTNode child = super.getChildNoTransform(i);");
            stream.println(ind(2) + "if (state().IN_COMPUTATION > 0 && child.isRegionRoot()) {");
            stream.println(ind(3) +   "child.handler().addDependant(handler());");
            stream.println(ind(2) + "}");
            stream.println(ind(2) + "return (T)child;");
            stream.println(ind + "}");    
          } else {
            stream.println(ind + "/**");
            stream.println(ind + " * @apilevel low-level");
            stream.println(ind + " */");
            stream.println(ind + "public ASTNode " + name() + ".getChild(int i) {");
            stream.println(ind(2) + "// region leaf");
            stream.println(ind(2) + "ASTNode child = super.getChild(i);");
            stream.println(ind(2) + "if (state().IN_COMPUTATION > 0 && child.isRegionRoot()) {");
            stream.println(ind(3) +   "child.handler().addDependant(handler());");
            stream.println(ind(2) + "}");
            stream.println(ind(2) + "return child;");
            stream.println(ind + "}");
            stream.println(ind + "/**");
            stream.println(ind + " * @apilevel low-level");
            stream.println(ind + " */");
            stream.println(ind + "public ASTNode " + name() + ".getChildNoTransform(int i) {");
            stream.println(ind(2) + "// region leaf");
            stream.println(ind(2) + "ASTNode child = super.getChildNoTransform(i);");
            stream.println(ind(2) + "if (state().IN_COMPUTATION > 0 && child.isRegionRoot()) {");
            stream.println(ind(3) +   "child.handler().addDependant(handler());");
            stream.println(ind(2) + "}");
            stream.println(ind(2) + "return child;");
            stream.println(ind + "}");
          }
        }
        else if (!name().equals("ASTNode")) {
          stream.println(ind + "/**");
          stream.println(ind + " * @apilevel low-level");
          stream.println(ind + " */");
          stream.println(ind + "public ASTNode " + name() + ".getChild(int i) {");
          stream.println(ind(2) + "// region leaf");
          stream.println(ind(2) + "ASTNode child = super.getChild(i);");
          stream.println(ind(2) + "if (state().IN_COMPUTATION > 0 && child.isRegionRoot()) {");
          stream.println(ind(3) +   "child.handler().addDependant(handler());");
          stream.println(ind(2) + "}");
          stream.println(ind(2) + "return child;");
          stream.println(ind + "}");
          stream.println(ind + "/**");
          stream.println(ind + " * @apilevel low-level");
          stream.println(ind + " */");
          stream.println(ind + "public ASTNode " + name() + ".getChildNoTransform(int i) {");
          stream.println(ind(2) + "// region leaf");
          stream.println(ind(2) + "ASTNode child = super.getChildNoTransform(i);");
          stream.println(ind(2) + "if (state().IN_COMPUTATION > 0 && child.isRegionRoot()) {");
          stream.println(ind(3) +   "child.handler().addDependant(handler());");
          stream.println(ind(2) + "}");
          stream.println(ind(2) + "return child;");
          stream.println(ind + "}");
        }
      }
    }
    // end method: getChild(int) -- overloaded for region tracking

    // TODO revisit this method
/*
    // method: removeChild(int) -- overloaded for region tracking
    if (ASTNode.incrementalLevelRegion) {
      if (isRegionLeaf() && !name().equals("ASTNode")) {
        stream.println(ind + "public void " + name() + ".removeChild(int index) {");
        stream.println(ind(2) + "// region leaf");
        stream.println(ind(2) + "ASTNode child = getChild(index);");
        stream.println(ind(2) + "if (child.isRegionRoot()) {");
        stream.println(ind(3) +   "ASTNode$DepGraphNode handler = handler();");
        stream.println(ind(3) +   "if (handler != null) handler.flushRegion();");
        stream.println(ind(2) + "}");
        stream.println(ind(2) + "super.removeChild(index);");
        stream.println(ind + "}");
      }
    }
    // end method: removeChild(int) -- overloaded for region tracking

    // TODO revisit this method
    // method: insertChild(ASTNode,int) -- overloaded for region tracking
    if (ASTNode.incrementalLevelRegion) {
      if (isRegionLeaf() && !name().equals("ASTNode")) {
        stream.println("    public void " + name() + ".insertChild(ASTNode node, int index) {");
        stream.println("      // region leaf");
        stream.println("      if (node.isRegionRoot()) {");
        stream.println(ind(3) +   "ASTNode$DepGraphNode handler = handler();");
        stream.println(ind(3) +   "if (handler != null) handler.flushRegion();");
        stream.println("      }");
        stream.println("      super.insertChild(node, index);");
        stream.println("    }");
      }        
    }
    // end method: insertChild(ASTNode,int) -- overloaded for region tracking
*/

  } // end: jjtGenIncrementalRegions
  

  // ES_2011-09-20: Debug code generation for incremental evaluation
  public void ASTDecl.jjtGenIncrementalDebug(PrintWriter stream) {

    // method: relativeNodeID()          

    if (name().equals("ASTNode")) {
      stream.println(ind + "public String ASTNode.relativeNodeID() {");
      stream.println(ind(2) + "String path = \"\";");
      stream.println(ind(2) + "ASTNode node = this;");
      stream.println(ind(2) + "while (node != null) {");
      stream.println(ind(3) +   "ASTNode parent = node.parent;");
      stream.println(ind(3) +   "int index = -1;");
      stream.println(ind(3) +   "if (parent != null) {");
      stream.println(ind(4) +     "for (int i = 0; parent.children != null && i < parent.children.length; i++) {");
      stream.println(ind(5) +       "if (parent.children[i] != null && parent.children[i] == node && !parent.childIsNTA(i)) {");
      stream.println(ind(6) +         "index = i;");
      stream.println(ind(6) +         "break;");
      stream.println(ind(5) +       "}");
      stream.println(ind(4) +     "}");
      stream.println(ind(3) +   "}");
      stream.println(ind(3) +   "String pathEntry = node.getClass().getSimpleName();");
      stream.println(ind(3) +   "if (index > -1) pathEntry += \"[\" + index + \"]\";");
      stream.println(ind(3) +   "path = path.length() == 0 ? pathEntry : pathEntry + \"/\" + path;");
      stream.println(ind(3) +   "node = parent;");
      stream.println(ind(2) + "}");
      stream.println(ind(2) + "return path;");
/*
      stream.println(ind(2) + "ASTNode parent = this.parent;");
      stream.println(ind(2) + "StringBuffer buf = new StringBuffer();");
      stream.println(ind(2) + "int index = -1;");
      stream.println(ind(2) + "if (parent != null) {");
      stream.println(ind(3) +   "buf.append(parent.relativeNodeID() + \"/\");");
      stream.println(ind(3) +   "for (int i = 0; parent.children != null && i < parent.children.length; i++) {");
      stream.println(ind(4) +     "if (parent.children[i] != null && " + 
                                        "parent.children[i] == this && " + 
                                        "!parent.childIsNTA(i)) {");
      stream.println(ind(5) +       "index = i;");
      stream.println(ind(5) +       "break;");
      stream.println(ind(4) +     "}");
      stream.println(ind(3) +   "}");
      stream.println(ind(2) + "}");
      stream.println(ind(2) + "buf.append(getClass().getSimpleName());");
      stream.println(ind(2) + "if (index > -1) {");
      stream.println(ind(3) +   "buf.append(\"[\" + index + \"]\");");
      stream.println(ind(2) + "}");
      stream.println(ind(2) + "return buf.toString();");
*/
      stream.println(ind + "}");
    }

    // end method: relativeNodeID()          
    
    // method: printParamList(List)
    if (name().equals("ASTNode")) {
      stream.println(ind + "protected String ASTNode.printParamList(java.util.List paramList) {");
      stream.println(ind(2) + "StringBuffer buf = new StringBuffer();");
      stream.println(ind(2) + "for (java.util.Iterator itr = paramList.iterator(); itr.hasNext();) {");
      stream.println(ind(3) +   "Object o = itr.next();");
      stream.println(ind(3) +   "if (o instanceof ASTNode) {");
      stream.println(ind(4) +     "buf.append(((ASTNode)o).relativeNodeID());");
      stream.println(ind(3) +   "} else {");
      stream.println(ind(4) +     "buf.append(o.toString());");
      stream.println(ind(3) +   "}");
      stream.println(ind(3) +   "buf.append(\",\");");
      stream.println(ind(2) + "}");
      stream.println(ind(2) + "return buf.toString();");
      stream.println(ind + "}");    
    } // end method: printParamList(List)
        
    // method: printValue(Object value) 
    if (name().equals("ASTNode")) {
      stream.println(ind + "protected String ASTNode.printValue(Object value) {");
      stream.println(ind(2) + "if (value == null)");
      stream.println(ind(3) +   "return \"null\";");
      stream.println(ind(3) + "if (value instanceof ASTNode && ((ASTNode)value).inc_state == inc_GARBAGE)");
      stream.println(ind(4) +   "throw new Error(\"Cached value is garbage\");");
      stream.println(ind(2) + "return value.toString();");
      stream.println(ind + "}");    
    } // end method: printValue(Object)
    

    // method: dumpCachedValues()
    stream.println(ind + "public void " + name() + ".dumpCachedValues() {");
    if (name().equals("ASTNode")) {
      // rewrite code
      stream.println(ind(2) + "for (int k = 0; rewritten_children != null && k < rewritten_children.length; k++) {");
      stream.println(ind(3) +   "if (rewritten_children[k]) {");
      stream.println(ind(4) +     "System.out.println(children[k].relativeNodeID() + " + 
                                      "\" rewritten, initial=\" + " +
                                  "(init_children[k] != null ? init_children[k].relativeNodeID():null));");
      stream.println(ind(3) +   "}");
      stream.println(ind(2) + "}");
     //
    }
    for(int k = 0; k < getNumSynEq(); k++) {
      AttrEq attrEq = getSynEq(k);
      AttrDecl attr = attrEq.decl();
      String u = attr.dumpCache();
      u = u.replaceAll("#NAME#", attr.attributeSignature());
      stream.println(u);
    }
    for(int k = 0; k < getNumInhDecl(); k++) {
      InhDecl attr = getInhDecl(k);
      String u = attr.dumpCache();
      u = u.replaceAll("#NAME#", attr.attributeSignature());
      stream.println(u);
    }
    stream.println(ind(2) + "// TODO: dump collection values");
    if (!name().equals("ASTNode")) {
      stream.println(ind(2) + "super.dumpCachedValues();");
    }
    stream.println(ind + "}");     
    // end method: dumpCachedValues()     
      

    // method: dumpDependencies()
    stream.println(ind + "public void " + name() + ".dumpDependencies() {");
    if (name().equals("ASTNode")) {
      if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
        stream.println(ind(2) + "getParent_handler.dumpDeps();");
        stream.println(ind(2) + "numChildren_handler.dumpDeps();");
        if (ASTNode.incrementalLevelParam) {
          stream.println(ind(2) + "for (int k = 0; getChild_handler != null && k < getChild_handler.length; k++) {");
          stream.println(ind(3) +   "if (getChild_handler[k] != null) {");
          stream.println(ind(4) +     "getChild_handler[k].dumpDeps();");
          stream.println(ind(3) +   "}");
          stream.println(ind(2) + "}");
        }
        if (ASTNode.incrementalLevelAttr) {
          stream.println(ind(2) + "getChild_handler.dumpDeps();");
        }
      }
      if (ASTNode.incrementalLevelNode) {
        stream.println(ind(2) + "handler.dumpDeps();");
      }
    } 
    if (ASTNode.incrementalLevelRegion && isRegionRoot()) {
      stream.println(ind(2) + "handler.dumpDeps();");
    }
    // collect attributes
    ArrayList list = new ArrayList();
    for(int k = 0; k < getNumSynEq(); k++) {
       AttrDecl attr = getSynEq(k).decl();
       if (attr.getLazy() || attr.isCircular()) 
        list.add(attr);
    }
    for(int k = 0; k < getNumInhDecl(); k++) {
      InhDecl attr = getInhDecl(k);
       if (attr.getLazy() || attr.isCircular()) 
        list.add(attr);
    }
    // tokens
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
      for(Iterator iter = getComponents(); iter.hasNext(); ) {
        Components c = (Components)iter.next();
         if (c instanceof TokenComponent && !c.isNTA()) {
          stream.println(ind(2) + "if (get" + ((TokenComponent)c).getTokenId().getID() + "_handler != null) {");
          stream.println(ind(3) +   "get" + ((TokenComponent)c).getTokenId().getID() + "_handler.dumpDeps();");
          stream.println(ind(2) + "}");
         }
       }
    }
    // attributes
    for(Iterator itr = list.iterator(); itr.hasNext();) {
      AttrDecl attr = (AttrDecl)itr.next();
      // handlers
      if (ASTNode.incrementalLevelParam) {
        if (attr.getNumParameter() > 0) {
          stream.println(ind(2) + "for (java.util.Iterator itr = " + attr.attributeSignature() + 
                                "_handler.values().iterator(); itr.hasNext();) {");
          stream.println(ind(3) +   "ASTNode$DepGraphNode handler = (ASTNode$DepGraphNode)itr.next();");
          stream.println(ind(3) +   "handler.dumpDeps();");
          stream.println(ind(2) + "}");
        } else {
          stream.println(ind(2) + "if (" + attr.attributeSignature() + "_handler != null) {");
          stream.println(ind(3) +   attr.attributeSignature() + "_handler.dumpDeps();");
          stream.println(ind(2) + "}");
        }
      }
      if (ASTNode.incrementalLevelAttr) {
        stream.println(ind(2) + "if (" + attr.attributeSignature() + "_handler != null) {");
         stream.println(ind(3) +   attr.attributeSignature() + "_handler.dumpDeps();");
         stream.println(ind(2) + "}");
      }
      if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
        // values for NTAs
        if ((attr.isNTA() || attr.getNTA()) && !attr.isPrimitive() && 
            !(attr.type().equals("String") || attr.type().equals("java.lang.String"))) {
          if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr || ASTNode.incrementalLevelNode) {
            if (attr.getNumParameter() > 0) {
              stream.println(ind(2) + "if (" + attr.attributeSignature() + "_list != null) {");
              stream.println(ind(3) +   attr.attributeSignature() + "_list.dumpDependencies();");
              stream.println(ind(2) + "}");
            } else {
              stream.println(ind(2) + "if (" + attr.attributeSignature() + "_computed && (" +
                                      attr.attributeSignature() + "_value instanceof ASTNode)) {");
              stream.println(ind(3) + attr.attributeSignature() + "_value.dumpDependencies();");
              stream.println(ind(2) + "}");
            }
          }
        }
      }
    }
    stream.println(ind(2) + "// TODO: dump collection values");
    // super call
    if (!name().equals("ASTNode")) {
      if (ASTNode.incrementalLevelRegion) {
        if (!isRegionRoot()) 
          stream.println(ind(2) + "super.dumpDependencies();");
      } else {
          stream.println(ind(2) + "super.dumpDependencies();");
      }
    }
    stream.println(ind + "}");  
    // end method: dumpDependencies()


    // start method: dumpDepsInTree() 
    stream.println(ind + "public void " + name() + ".dumpDepsInTree() {");
    stream.println(ind(2) + "dumpDependencies();");
    stream.println(ind(2) + "for (int i = 0; children != null && i < children.length; i++) {");
    stream.println(ind(3) +   "ASTNode child = children[i];");
    stream.println(ind(3) +   "if (child == null)");
    stream.println(ind(4) +     "continue;");
    stream.println(ind(3) +   "child.dumpDepsInTree();");
    stream.println(ind(2) + "}");
    // attributes
    for(Iterator itr = list.iterator(); itr.hasNext();) {
      AttrDecl attr = (AttrDecl)itr.next();
      // values for NTAs
      if ((attr.isNTA() || attr.getNTA()) && !attr.isPrimitive() && 
         !(attr.type().equals("String") || attr.type().equals("java.lang.String"))) {
        if (attr.getNumParameter() > 0) {
          stream.println(ind(2) + "if (" + attr.attributeSignature() + "_list != null) {");
          stream.println(ind(3) +   attr.attributeSignature() + "_list.dumpDepsInTree();");
          stream.println(ind(2) + "}");
        } else {
          stream.println(ind(2) + "if (" + attr.attributeSignature() + "_computed && (" +
                                   attr.attributeSignature() + "_value instanceof ASTNode)) {");
          stream.println(ind(3) + attr.attributeSignature() + "_value.dumpDepsInTree();");
          stream.println(ind(2) + "}");
        }                  
      }
    }
    stream.println(ind + "}");
    // end method: dumpDepsInTree()

  }

  // ES_2011-09-06: Code generation for incremental evaluation, dependency node class / handler class
  public void Grammar.jjtGenASTNode$DepGraphNode(PrintWriter stream, String parserName) {
    // class: ASTNode$DepGraphNode
    stream.println("  static public class ASTNode$DepGraphNode {");

    if (ASTNode.incrementalTrack) {
    stream.println("    public static int trackedReads = 0;");
    stream.println("    public static int trackedComputes = 0;");
    stream.println("    public static int trackedFlushes = 0;");
    stream.println("    public void trackChange() {");
    stream.println("      System.out.println(\"change(\" + this + \")\");");
    stream.println("    }");
    stream.println("    public static void resetTrackingCounters() {");
    stream.println("      trackedReads = 0;");
    stream.println("      trackedComputes = 0;");
    stream.println("      trackedFlushes = 0;");
    stream.println("    }");
    stream.println("    public static String getTrackingResult() {");
    stream.println("      return \"#reads = \" + trackedReads + \", #computes = \" + trackedComputes + \", #flushes = \" + trackedFlushes;");
    stream.println("    }");
    }

    // add listeners/dependencies from another handler, used in rewrites
    stream.println("    public void transferSetsFrom(ASTNode$DepGraphNode node) {");
    stream.println("      if (node == null || this == node)");
    stream.println("        return;");
    stream.println("      for (ASTNode$DepGraphNode l : node.fListenerSet) {");
    stream.println("        if (!l.isGarbage()) {");
    stream.println("          this.addDependant(l);");
    stream.println("        }");
    stream.println("      }");
    stream.println("      node.clearDependencies();");
    stream.println("      node.clearDependants();");
    stream.println("      node.throwAway();");
    stream.println("    }");
    stream.println("    public void transferDependenciesFrom(ASTNode$DepGraphNode node) {");
    stream.println("      if (node == null || this == node)");
    stream.println("        return;");
    stream.println("      for (ASTNode$DepGraphNode l : node.fDependencySet) {");
    stream.println("        l.addDependant(this);");
    stream.println("      }");
    if (ASTNode.incrementalPropLimit) {
      stream.println("      setCacheInDependent(node.cacheInDependent);");
    }
    stream.println("      node.clearDependencies();");
//    stream.println("      node.clearDependants();");
    stream.println("    }");
    // state
    stream.println("    protected int fState = ASTNode.inc_CREATED;");
    stream.println("    public void changeState(int newState) {");
    stream.println("      fState = newState;");
    stream.println("    }");
    stream.println("    public void throwAway() {");
    stream.println("      fState = ASTNode.inc_GARBAGE;");
    //stream.println("      clearDependants();");
    stream.println("    }");
    stream.println("    public void keepAlive() {");
    stream.println("      fState = ASTNode.inc_LIVE;");
    stream.println("    }");
    stream.println("    public boolean isGarbage() {");
    stream.println("      return fState == ASTNode.inc_GARBAGE;");
    stream.println("    }");
    stream.println("    public boolean isCreated() {");
    stream.println("      return fState == ASTNode.inc_CREATED;");
    stream.println("    }");
    stream.println("    public boolean isCloned() {");
    stream.println("      return fState == ASTNode.inc_CLONED;");
    stream.println("    }");
    stream.println("    public boolean isLive() {");
    stream.println("      return fState == ASTNode.inc_LIVE;");
    stream.println("    }");
    // clean up
    stream.println("    public boolean visitedDuringCleanup = false;");
    stream.println("    public static int nbr_cleanup = 0;");
    stream.println("    public void cleanUpGarbage() {");
    stream.println("      visitedDuringCleanup = true;");
    stream.println("      nbr_cleanup++;");
    stream.println("      // Clean up garbage");
    stream.println("      java.util.Iterator<ASTNode$DepGraphNode> itr = fListenerSet.iterator();");
    stream.println("      while (itr.hasNext()) {");
    stream.println("        ASTNode$DepGraphNode cur = itr.next();");
    stream.println("        if (cur.isGarbage()) {");
    stream.println("          itr.remove();");
    stream.println("        }");
    stream.println("      }");
    stream.println("    }");
    /*
    stream.println("    public static LinkedList<ASTNode$DepGraphNode> createdHandlers = new LinkedList<ASTNode$DepGraphNode>();");
    stream.println("    public static void doCleanUp() {");
    stream.println("      Iterator itr = createdHandlers.iterator();");
    stream.println("      while (itr.hasNext()) {");
    stream.println("        ASTNode$DepGraphNode node = (ASTNode$DepGraphNode)itr.next();");
    stream.println("        if (node.isGarbage() || node.isCreated())");
    stream.println("          itr.remove();");
    stream.println("        else node.cleanUpGarbage();");
    stream.println("      }");
    stream.println("    }");
    */
    // level: node, attr, param all need a node to store the dependency node in
    stream.println("    public ASTNode fNode;");
    // level: param needs both an attr ID and a param ID
    if (ASTNode.incrementalLevelParam) {
      stream.println("    public String fAttrID;");
      stream.println("    protected Object fParams;");
      stream.println("    public ASTNode$DepGraphNode(ASTNode node, String attrID, Object params) {");
      stream.println("      fNode = node;");
      stream.println("      fAttrID = attrID;");
      stream.println("      fParams = params;");
      stream.println("      fState = node.inc_state;");
      //stream.println("      createdHandlers.add(this);");
      stream.println("    }");
      stream.println("    public ASTNode$DepGraphNode(ASTNode$DepGraphNode handler, ASTNode node) {");
      stream.println("      fNode = node;");
      stream.println("      fAttrID = handler.fAttrID;");
      stream.println("      fParams = handler.fParams;");
      stream.println("      fState = node.inc_state;");
      //stream.println("      createdHandlers.add(this);");
      stream.println("    }");
      stream.println("    public void setParams(Object params) {");
      stream.println("      fParams = params;");
      stream.println("    }");
      if (ASTNode.incrementalPropLimit) {
      stream.println("    public boolean cacheInDependent = false;");
      stream.println("    public ASTNode$DepGraphNode(ASTNode node, String attrID, Object params, boolean cacheInDependent) {");
      stream.println("      this(node, attrID, params);");
      stream.println("      this.cacheInDependent = cacheInDependent;");
      stream.println("    }");
      stream.println("    public boolean isCacheInDependent() {");
      stream.println("      return cacheInDependent;");
      stream.println("    }");
      stream.println("    public void setCacheInDependent(boolean b) {");
      stream.println("      cacheInDependent = b;");
      stream.println("    }");
      stream.println("    public boolean noCacheRead = true;");
      }
    }
    // level: attr also needs an attr ID 
    if (ASTNode.incrementalLevelAttr) {
      stream.println("    public String fAttrID;");
      stream.println("    public ASTNode$DepGraphNode(ASTNode node, String attrID) {");
      stream.println("      fNode = node;");
      stream.println("      fAttrID = attrID;");
      stream.println("      fState = node.inc_state;");
      //stream.println("      createdHandlers.add(this);");
      stream.println("    }");
      stream.println("    public ASTNode$DepGraphNode(ASTNode$DepGraphNode handler, ASTNode node) {");
      stream.println("      fNode = node;");
      stream.println("      fAttrID = handler.fAttrID;");
      stream.println("      fState = node.inc_state;");
      //stream.println("      createdHandlers.add(this);");
      stream.println("    }");
    }
    // level: node, region
    if (ASTNode.incrementalLevelNode || ASTNode.incrementalLevelRegion) {
      stream.println("    public ASTNode$DepGraphNode(ASTNode node) {");
      stream.println("      fNode = node;");
      stream.println("      fState = node.inc_state;");
      //stream.println("      createdHandlers.add(this);");
      stream.println("    }");    
      stream.println("    public ASTNode$DepGraphNode(ASTNode$DepGraphNode handler, ASTNode node) {");
      stream.println("      fNode = node;");
      stream.println("      fState = node.inc_state;");
      //stream.println("      createdHandlers.add(this);");
      stream.println("    }");
    }
    if (ASTNode.incrementalLevelNode || ASTNode.incrementalLevelRegion || ASTNode.incrementalLevelAttr) {

      stream.println("    public void flushRegion() {");
      stream.println("      // Remove dependencies");
      stream.println("      java.util.HashSet<ASTNode$DepGraphNode> k = fDependencySet;");
      stream.println("      fDependencySet = new java.util.HashSet<ASTNode$DepGraphNode>(4);");
      stream.println("      for (ASTNode$DepGraphNode node : k) {");
      stream.println("        node.removeDependant(this);");
      stream.println("      }");
      if (ASTNode.incrementalLevelAttr) 
        stream.println("          fNode.reactToDependencyChange(fAttrID);");
      if (ASTNode.incrementalLevelNode || ASTNode.incrementalLevelRegion)
        stream.println("          fNode.reactToDependencyChange();");
      stream.println("    }");          
    }
    // behavior generic for any kind of dependency region
    stream.println("    public java.util.HashSet<ASTNode$DepGraphNode> fListenerSet = " +
                   "new java.util.HashSet<ASTNode$DepGraphNode>(4);");
    stream.println("    public boolean hasDependants() {");
    stream.println("        return !fListenerSet.isEmpty();");
    stream.println("    }");
    stream.println("    public java.util.HashSet<ASTNode$DepGraphNode> fDependencySet = " +
                   "new java.util.HashSet<ASTNode$DepGraphNode>(4);");
    stream.println("    public void clearDependants() {");
    stream.println("      for (ASTNode$DepGraphNode node : fListenerSet) {");
    stream.println("        node.removeDependency(this);");
    stream.println("      }");
    stream.println("      fListenerSet.clear();");
    stream.println("    }");
    stream.println("    public void clearDependencies() {");
    stream.println("      for (ASTNode$DepGraphNode node : fDependencySet) {");
    stream.println("        node.removeDependant(this);");
    stream.println("      }");
    stream.println("      fDependencySet.clear();");
    stream.println("    }");
    stream.println("    public void addDependency(ASTNode$DepGraphNode node) {");
//    stream.println("      if (node != this) {");
    stream.println("      fDependencySet.add(node);");
//    stream.println("      }");
    stream.println("    }");
    stream.println("    public void removeDependency(ASTNode$DepGraphNode node) {");
//    stream.println("      if (node != this) {");
    stream.println("      fDependencySet.remove(node);");
//    stream.println("      }");
    stream.println("    }");
    stream.println("    public void addDependant(ASTNode$DepGraphNode node) {");
//    stream.println("      if (node != this) {");
    stream.println("      fListenerSet.add(node);");
    stream.println("      node.addDependency(this);");
//    stream.println("      }");
    stream.println("    }");
    stream.println("    public void removeDependant(ASTNode$DepGraphNode node) {");
//    stream.println("      if (node != this) {");
    stream.println("      fListenerSet.remove(node);");
    stream.println("    }");
    //}
    stream.println("    private boolean visited = false;");
    stream.println("    public void notifyDependencies() {");
    stream.println("      // Notify and remove listeners");
    stream.println("      if (!visited) {");
    stream.println("        visited = true;");
    stream.println("        java.util.HashSet<ASTNode$DepGraphNode> k = fListenerSet;");
    stream.println("        fListenerSet = new java.util.HashSet<ASTNode$DepGraphNode>(4);");
    stream.println("        for (ASTNode$DepGraphNode node : k) {");
    stream.println("          if (!node.isGarbage())");
    stream.println("            node.dependencyChanged();");
    stream.println("          node.removeDependency(this);");
    stream.println("        }");
    stream.println("        visited = false;");
    stream.println("      }");
    stream.println("    }");
    // React to change
    stream.println("    private boolean visitedChange = false;");
    stream.println("    public void dependencyChanged() {");
    stream.println("      if (!visitedChange) {");
    stream.println("        visitedChange = true;");
    if (ASTNode.incrementalTrack) {
    stream.println("        trackedFlushes++;");
    stream.println("        System.out.println(\"not(\" + this + \")\");");
    }
    if (ASTNode.incrementalLevelParam && ASTNode.incrementalPropLimit) {
    stream.println("        if (noCacheRead && !fNode.inc_valueAffected(fAttrID, fParams)) {");
    stream.println("        } else {");
    }
    stream.println("        if (!fDependencySet.isEmpty()) {");
    stream.println("          // Remove dependencies");
    stream.println("          java.util.HashSet<ASTNode$DepGraphNode> k = fDependencySet;");
    stream.println("          fDependencySet = new java.util.HashSet<ASTNode$DepGraphNode>(4);");
    stream.println("          for (ASTNode$DepGraphNode node : k) {");
    stream.println("            node.removeDependant(this);");
    stream.println("          }");
    if (ASTNode.incrementalLevelParam)
    stream.println("          fNode.reactToDependencyChange(fAttrID, fParams);");
    if (ASTNode.incrementalLevelAttr) 
    stream.println("          fNode.reactToDependencyChange(fAttrID);");
    if (ASTNode.incrementalLevelNode || ASTNode.incrementalLevelRegion)
    stream.println("          fNode.reactToDependencyChange();");
    stream.println("        }");
    if (ASTNode.incrementalLevelParam && ASTNode.incrementalPropLimit) {
      stream.println("        }");
    }
    stream.println("        visitedChange = false;");
    stream.println("      }");
    stream.println("    }");
    // Debugging methods:
    if (ASTNode.incrementalDebug) {
      stream.println("    private int dumpDependents_visited = 0;");
      stream.println("    public void dumpDependents(boolean changed, int visited) {");
      stream.println("      if (visited != dumpDependents_visited) {");
      stream.println("        dumpDependents_visited = visited;");
      stream.println("        if (changed) {");
      stream.println("          System.out.println(\"change(\" + this + \")\");");
      stream.println("        } else {");
      stream.println("          System.out.println(\"dep-change(\" + this + \")\");");
      stream.println("         }");
      stream.println("        class Entry implements Comparable<Entry> {");
      stream.println("          public String id;");
      stream.println("          public ASTNode$DepGraphNode node;");
      stream.println("          public Entry(String id, ASTNode$DepGraphNode node) {");
      stream.println("            this.id = id; this.node = node;");
      stream.println("          }");
      stream.println("          public int compareTo(Entry e) {");
      stream.println("            return id.compareTo(e.id);");
      stream.println("          }");
      stream.println("        }");
      stream.println("        java.util.TreeSet<Entry> sorted = new java.util.TreeSet<Entry>();");
      stream.println("        for (ASTNode$DepGraphNode node : fListenerSet) {");
      stream.println("          sorted.add(new Entry(node.toString(), node));");
      stream.println("        }");
      stream.println("        for (Entry e : sorted) {");
      stream.println("          e.node.dumpDependents(false, visited);");
      stream.println("        }");
      stream.println("      }");
      stream.println("    }");
      stream.println("    public void dumpDeps() {");
      stream.println("      java.util.TreeSet<String> sorted = new java.util.TreeSet<String>();");
      stream.println("      for (ASTNode$DepGraphNode node : fListenerSet) {");
      stream.println("        sorted.add(node.toString());");
      stream.println("      }");
      stream.println("      for (String s : sorted) {");
      stream.println("        System.out.println(\"dep(\" + s + \" -> \" + this + \")\");");
      stream.println("      }");
      stream.println("    }");
      stream.println("    public String toString() {");
      if (ASTNode.incrementalLevelParam) 
        stream.println("      return fNode.relativeNodeID() + \":\" + fAttrID + " +
            "(fParams != null ? (\"[\" + (fParams instanceof ASTNode ? " +
            "((ASTNode)fParams).relativeNodeID() : fParams) + \"]\") : \"\");");
      if (ASTNode.incrementalLevelAttr)
        stream.println("      return fNode.relativeNodeID() + \":\" + fAttrID;");
      if (ASTNode.incrementalLevelNode || ASTNode.incrementalLevelRegion)
        stream.println("      return fNode.relativeNodeID();");
      stream.println("    }");
    }
    stream.println("  }"); // End ASTNode$DepGraphNode
  }

}
