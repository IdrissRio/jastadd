aspect IncrementalEval {
  // ES_2011-10-05: Code generation for incremental evaluation, enter construction
  public String ASTDecl.genIncrementalConstructorStartConstruction() {
    return ind(2) + "state().enterConstruction();\n";
  }

  // ES_2011-10-05: Code generation for incremental evaluation, end construction
  public String ASTDecl.genIncrementalConstructorEndConstruction() {
    return ind(2) + "state().exitConstruction();\n";
  }

  // ES_2011-12-11: Code generation for incremental evaluation, track creation
  public String ASTDecl.genIncrementalTrackCreation() {
    if (ASTNode.incrementalLevelNode) {
      //return ind(2) + "state().addHandlerDepTo(handler);\n";
    }
    return "";
  }

  // ES_2011-11-23: Code generation for incremental evaluation, enter construction
  public String ListComponents.genIncrementalConstructorStartConstruction() {
    return ind(2) + "state().enterConstruction();\n";
  }

  // ES_2011-11-23: Code generation for incremental evaluation, end construction
  public String ListComponents.genIncrementalConstructorEndConstruction() {
    return ind(2) + "state().exitConstruction();\n";
  }

  // ES_2011-11-23: Code generation for incremental evaluation, enter construction
  public String OptionalComponent.genIncrementalConstructorStartConstruction() {
    return ind(2) + "state().enterConstruction();\n";
  }

  // ES_2011-11-23: Code generation for incremental evaluation, end construction
  public String OptionalComponent.genIncrementalConstructorEndConstruction() {
    return ind(2) + "state().exitConstruction();\n";
  }

  // ES_2011-11-23: Code generation for incremental evaluation, enter construction
  public String AggregateComponents.genIncrementalConstructorStartConstruction() {
    return ind(2) + "state().enterConstruction();\n";
  }

  // ES_2011-11-23: Code generation for incremental evaluation, end construction
  public String AggregateComponents.genIncrementalConstructorEndConstruction() {
    return ind(2) + "state().exitConstruction();\n";
  }

  // ES_2011-09-20: Code generation for incremental evaluation, evaluation stack
  public void Grammar.jjtGenIncrementalEvaluationStack(PrintWriter stream) {
    if (ASTNode.incrementalLevelRegion) {
    stream.println(ind + "public int IN_COMPUTATION = 0;");
    }
    stream.println(ind + "protected java.util.Stack handlerAttrStack = new java.util.Stack();");
//    stream.println(ind + "protected java.util.Stack handlerRewriteStack = new java.util.Stack();");
    stream.println(ind + "public void addHandlerDepTo(ASTNode$DepGraphNode handler) {");
    stream.println(ind(2) + "if (!IN_ATTR_STORE_EVAL || handler == null) {");
//    stream.println(ind(2) + "if (!IN_ATTR_STORE_EVAL && !IN_REWRITE_EVAL || handler == null) {");
    stream.println(ind(3) +   "return;");
    stream.println(ind(2) + "}");
    if (ASTNode.incrementalTrack) {
    stream.println(ind(2) + "ASTNode$DepGraphNode.trackedReads++;");
    }
    stream.println(ind(2) + "java.util.Stack handlerStack = handlerAttrStack;");
//    stream.println(ind(2) + "if (IN_REWRITE_EVAL) ");
//    stream.println(ind(3) +   "handlerStack = handlerRewriteStack;");
    stream.println(ind(2) + "if (!handlerStack.isEmpty()) {");
    stream.println(ind(3) +   "//throw new Error(\"Handler stack is empty at addition of dependency!\");");
    stream.println(ind(3) +   "ASTNode$DepGraphNode top = (ASTNode$DepGraphNode)handlerStack.peek();");
    stream.println(ind(3) +   "handler.addDependant(top);");
    if (ASTNode.incrementalPropLimit) {
    stream.println(ind(3) +   "if (!handler.cacheInDependent)");
    stream.println(ind(4) +     "top.noCacheRead = false;");
    }
    stream.println(ind(2) + "}");
    stream.println(ind + "}");
    stream.println(ind + "public boolean IN_ATTR_STORE_EVAL = false;");
    stream.println(ind + "public void enterAttrStoreEval(ASTNode$DepGraphNode handler) {"); 
    if (ASTNode.incrementalTrack) {
    stream.println(ind(2) + "ASTNode$DepGraphNode.trackedComputes++;");
    }
//    stream.println(ind(2) + "if (!IN_REWRITE_EVAL) {");
    stream.println(ind(3) +   "IN_ATTR_STORE_EVAL = true;");
    stream.println(ind(3) +   "//System.out.println(\"attr eval stack enter: \" + handler.fAttrID);");
    stream.println(ind(3) +   "pushHandler(handlerAttrStack, handler);");
//    stream.println(ind(2) + "}");
    stream.println(ind + "}"); 
    stream.println(ind + "public void exitAttrStoreEval(ASTNode$DepGraphNode handler) {"); 
//    stream.println(ind(2) + "if (!IN_REWRITE_EVAL) {");
    stream.println(ind(3) +   "popHandler(handlerAttrStack, handler);");
    stream.println(ind(3) +   "//System.out.println(\"attr eval stack exit: \" + handler.fAttrID);");
    stream.println(ind(3) +   "IN_ATTR_STORE_EVAL = !handlerAttrStack.isEmpty();");
//    stream.println(ind(2) + "}");
    stream.println(ind + "}"); 
//    stream.println(ind + "public boolean IN_REWRITE_EVAL = false;");
    stream.println(ind + "public void enterRewriteEval(ASTNode$DepGraphNode handler) {"); 
    stream.println(ind(2) + "enterAttrStoreEval(handler);");
//    if (ASTNode.incrementalTrack) {
//    stream.println(ind(2) + "ASTNode$DepGraphNode.trackedComp++;");
//    }
//    stream.println(ind(2) + "IN_REWRITE_EVAL = true;");
//    stream.println(ind(2) + "pushHandler(handlerRewriteStack, handler);");
    stream.println(ind + "}"); 
    stream.println(ind + "public void exitRewriteEval(ASTNode$DepGraphNode handler) {"); 
    stream.println(ind(2) + "exitAttrStoreEval(handler);");
//    stream.println(ind(2) + "if (IN_REWRITE_EVAL) {");
//    stream.println(ind(3) +   "popHandler(handlerRewriteStack, handler);");
//    stream.println(ind(3) +   "IN_REWRITE_EVAL = !handlerRewriteStack.isEmpty();");
//    stream.println(ind(2) + "}");
    stream.println(ind + "}"); 
    stream.println(ind + "public boolean IN_CONSTRUCTION = false;");
    stream.println(ind + "private int inc_constructionCount = 0;");
    stream.println(ind + "public void enterConstruction() {"); 
    stream.println(ind(2) + "IN_CONSTRUCTION = true;");
    stream.println(ind(2) + "inc_constructionCount++;");
    stream.println(ind + "}"); 
    stream.println(ind + "public void exitConstruction() {"); 
    stream.println(ind(2) + "inc_constructionCount--;");
    stream.println(ind(2) + "if (inc_constructionCount == 0)");
    stream.println(ind(3) +   "IN_CONSTRUCTION = false;");
    stream.println(ind + "}"); 
    stream.println(ind + "protected void pushHandler(java.util.Stack stack, ASTNode$DepGraphNode handler) {");
    if (ASTNode.incrementalPropLimit) {
    stream.println(ind(2) + "// assume that evaluation will be clean from cached values");
    stream.println(ind(2) + "handler.noCacheRead = true;");
    }
    stream.println(ind(2) + "stack.push(handler);");
    stream.println(ind + "}");        
    stream.println(ind + "protected ASTNode$DepGraphNode popHandler(java.util.Stack stack, ASTNode$DepGraphNode handler) {");
    stream.println(ind(2) + "if (stack.isEmpty())");
    stream.println(ind(3) +   "throw new Error(\"Handler stack is empty at exit!\");");
    stream.println(ind(2) + "ASTNode$DepGraphNode h = (ASTNode$DepGraphNode)stack.pop();");
    // Skip this for now, deal with transitive dependencies later
    //if (ASTNode.incrementalPropLimit) {
    //stream.println(ind(2) + "h.setCacheInDependent(h.noCacheRead);");
    //stream.println(ind(2) + "if (!stack.isEmpty()) {");
    //stream.println(ind(3) +   "ASTNode$DepGraphNode top = (ASTNode$DepGraphNode)stack.peek();");
    //stream.println(ind(3) +   "top.noCacheRead &= h.noCacheRead;");
    //stream.println(ind(2) + "}");
    //}
    stream.println(ind(2) + "if (h != handler)");
    stream.println(ind(3) +   "throw new Error(\"Top of handler stack does not match at pop!\");");
//    stream.println(ind(3) +   "throw new Error(\"Top of handler stack does not match at pop! [\" + handler.fAttrID + \"]\");");
    stream.println(ind(2) + "return h;");
    stream.println(ind + "}");
  }

  // ES_2011-12-10: Code generation for incremental evaluation, tracking rewrites
  public void ASTDecl.jjtGenIncrementalTrackRewrite5(PrintWriter stream) {
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(4) + "that.state().enterRewriteEval(node.handler);");
    }
    if (ASTNode.incrementalLevelRegion) {
      //stream.println(ind(4) + "that.state().IN_REWRITE_EVAL = true;");
      stream.println(ind(4) + "that.state().IN_COMPUTATION++;");
    }
  }

  // ES_2011-12-10: Code generation for incremental evaluation, tracking rewrites
  public void ASTDecl.jjtGenIncrementalTrackRewrite6(PrintWriter stream) {
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(4) + "that.state().exitRewriteEval(oldNode.handler);");
    }
    if (ASTNode.incrementalLevelRegion) {
      stream.println(ind(4) + "that.state().IN_COMPUTATION--;");
      //stream.println(ind(4) + "that.state().IN_REWRITE_EVAL = false;");
    }
  }

  // ES_2011-12-10: Code generation for incremental evaluation, tracking rewrites
  public void ASTDecl.jjtGenIncrementalTrackRewrite7(PrintWriter stream) {
    if (ASTNode.incrementalLevelNode || ASTNode.incrementalLevelRegion || 
          ASTNode.incrementalLevelAttr || ASTNode.incrementalLevelParam) {
      stream.println(ind(5) + "ASTNode initial = that.init_children[i];");
    }
  }

  // ES_2011-12-10: Code generation for incremental evaluation, tracking rewrites
  public void ASTDecl.jjtGenIncrementalTrackRewrite8(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(6) + "oldNode.inc_flush_subtree(that.getChild_handler[i]);");
      stream.println(ind(5) + "that.init_children[i] = initial;");
    }
    if (ASTNode.incrementalLevelAttr) {
      stream.println(ind(6) + "oldNode.inc_flush_subtree(that.getChild_handler);");
      stream.println(ind(5) + "that.init_children[i] = initial;");
    }
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(6) + "oldNode.inc_flush_subtree(node.handler());");
      stream.println(ind(5) + "that.init_children[i] = initial;");
    }
    if (ASTNode.incrementalLevelRegion) {
      stream.println(ind(5) + "if (node.isRegionRoot()) {");
      stream.println(ind(6) +   "oldNode.inc_flush_subtree(node.handler());");
      stream.println(ind(5) + "}");
      stream.println(ind(5) + "that.init_children[i] = initial;");
    }
  }

  // ES_2011-12-12_ Code generation for incremental evalutaion, crossing between regions
  public void ASTDecl.jjtGenIncrementalTrackRewrite9(PrintWriter stream) {
    if (ASTNode.incrementalLevelRegion) {
      if (isRegionRoot()) {
        stream.println(ind(2) + "ASTNode child = ASTNode.getChild(this, i);");
        stream.println(ind(2) + "if (state().IN_COMPUTATION > 0) {");
        stream.println(ind(3) +   "child.handler().addDependant(handler);");
        stream.println(ind(2) + "}");
        stream.println(ind(2) + "return (T)child;");
      } else {
        stream.println(ind(2) + "return (T)ASTNode.getChild(this, i);");
      }
    } else {
      stream.println(ind(2) + "return (T)ASTNode.getChild(this, i);");
    }
  }

  // ES_2011-12-12_ Code generation for incremental evalutaion, crossing between regions
  public void ASTDecl.jjtGenIncrementalTrackRewrite10(PrintWriter stream) {
    if (ASTNode.incrementalLevelRegion) {
      if (isRegionRoot()) {
        stream.println(ind(2) + "ASTNode child = ASTNode.getChild(this, i);");
        stream.println(ind(2) + "if (state().IN_COMPUTATION > 0) {");
        stream.println(ind(3) +   "child.handler().addDependant(handler);");
        stream.println(ind(2) + "}");
        stream.println(ind(2) + "return child;");
      } else {
        stream.println(ind(2) + "return ASTNode.getChild(this, i);");
      }
    } else {
      stream.println(ind(2) + "return ASTNode.getChild(this, i);");
    }
  }

  // JO 2013-02-05 Incremental code gen
  public void ASTDecl.genIncrementalTrackRewrite12(PrintWriter stream) {
    stream.println(ind(2) + "if (state().IN_COMPUTATION > 0) {");
    stream.println(ind(3) +   "node.handler().addDependant(handler);");
    stream.println(ind(2) + "}");
  }

  // ES_2011-09-20: Code generation for incremental evaluation, tracking rewrites
  public void ASTDecl.jjtGenIncrementalTrackRewrite1(PrintWriter stream) {
    if (!ASTNode.fullFlush) {
    stream.println(ind(2) + "if(that.init_children == null) {");
    stream.println(ind(3) +   "that.init_children = new ASTNode[that.children.length];");
    stream.println(ind(3) +   "that.rewritten_children = new boolean[that.children.length];");
    stream.println(ind(2) + "}");
    stream.println(ind(2) + "if(!node.inc_hasEnclosingRewrittenNode()) {");
    stream.println(ind(3) +   "that.init_children[i] = node.fullCopy();");
    stream.println(ind(3) +   "that.rewritten_children[i] = true;");
    stream.println(ind(2) + "}");
    }
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(2) + "that.state().enterRewriteEval(that.getChild_handler[i]);");
    }
    if (ASTNode.incrementalLevelAttr) {
      stream.println(ind(2) + "that.state().enterRewriteEval(that.getChild_handler);");
    }
  }

  // ES_2011-09-20: Code generation for incremental evaluation, tracking rewrites
  public void ASTDecl.jjtGenIncrementalTrackRewrite2(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(2) + "that.state().exitRewriteEval(that.getChild_handler[i]);");
    }
    if (ASTNode.incrementalLevelAttr) {
      stream.println(ind(2) + "that.state().exitRewriteEval(that.getChild_handler);");
    }
  }

  // ES_2011-09-30: Code generation for incremental evaluation, tracking rewrites
  public void ASTDecl.jjtGenIncrementalTrackRewrite3(PrintWriter stream) {
    if (!ASTNode.fullFlush) {
    stream.println(ind(4) + "if (rewriteState == ASTNode$State.REWRITE_CHANGE) {");
    stream.println(ind(5) +   "that.rewritten_children[i] = true;");
    stream.println(ind(4) + "}");
    }
  }

  // ES_2011-10-05: Code generation for incremental evaluation, tracking getChild
  public void ASTDecl.jjtGenIncrementalTrackRewrite4(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(3) + "if (that.getChild_handler[i] == null) {");
      if (ASTNode.incrementalPropLimit) {
      stream.println(ind(4) +   "that.getChild_handler[i] = new ASTNode$DepGraphNode(that, \"getChild\", new Integer(i), !node.mayHaveRewrite());");
      } else {
      stream.println(ind(4) +   "that.getChild_handler[i] = new ASTNode$DepGraphNode(that, \"getChild\", new Integer(i));");
      }
      stream.println(ind(3) + "}");
      stream.println(ind(3) + "that.state().addHandlerDepTo(that.getChild_handler[i]);");
    }
    if (ASTNode.incrementalLevelAttr) {
      stream.println(ind(2) + "that.state().addHandlerDepTo(that.getChild_handler);");  
    }
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(2) + "if (node != null) {");
      stream.println(ind(3) + "  that.state().addHandlerDepTo(node.handler);");
      stream.println(ind(2) + "}");
    }
  }

  // ES_2011-12-12: Code generation for incremental evaluation, tracking getChild
  public void ASTDecl.jjtGenIncrementalTrackRewrite11(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(3) + "if (that.getChild_handler[i] == null) {");
      if (ASTNode.incrementalPropLimit) {
      stream.println(ind(4) +   "that.getChild_handler[i] = new ASTNode$DepGraphNode(that, \"getChild\", new Integer(i), !node.mayHaveRewrite());");
      } else {
      stream.println(ind(4) +   "that.getChild_handler[i] = new ASTNode$DepGraphNode(that, \"getChild\", new Integer(i));");
      }
      stream.println(ind(3) + "}");
      stream.println(ind(3) + "that.state().addHandlerDepTo(that.getChild_handler[i]);");
    }
    if (ASTNode.incrementalLevelAttr) {
      stream.println(ind(2) + "that.state().addHandlerDepTo(that.getChild_handler);");  
    }
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(2) + "if (node != null) {");
      stream.println(ind(3) + "  that.state().addHandlerDepTo(node.handler);");
      // rewrite is evaluated in "that" and may use attributes in that node, but this is not tracked. 
      // The possibility of a dependency requires one.
      stream.println(ind(3) + "  that.handler.addDependant(node.handler);");
      stream.println(ind(2) + "}");
    }
    if (ASTNode.incrementalLevelRegion) {
      // rewrite is evaluated in "that" and may use attributes in that node, but this is not tracked. 
      // The possibility of a dependency requires one.
      stream.println(ind(2) + "if (node != null && node.isRegionRoot()) {");
      stream.println(ind(3) +   "that.handler().addDependant(node.handler());");
      stream.println(ind(3) +   "node.handler().addDependant(that.handler());");
      stream.println(ind(2) + "}");
    }
  }

  // ES_2011-12-13: Code generation for incremental evaluation, name getChildNoTransform
  public void ASTDecl.jjtGenIncrementalTrackGetChildNoTransformName1(PrintWriter stream) {
      stream.println(ind + "public ASTNode ASTNode.getChildNoTransform(int i) {");
  }

  // ES_2011-12-13: Code generation for incremental evaluation, name getChildNoTransform
  public void ASTDecl.jjtGenIncrementalTrackGetChildNoTransformName2(PrintWriter stream) {
      stream.println(ind + "public T ASTNode.getChildNoTransform(int i) {");
  }

  // ES_2011-09-20: Code generation for incremental evaluation, tracking getChild
  public void ASTDecl.jjtGenIncrementalTrackGetChildNoTransform(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(2) + "if (getChild_handler[i] == null) {");
      if (ASTNode.incrementalPropLimit) {
      stream.println(ind(4) +   "getChild_handler[i] = new ASTNode$DepGraphNode(this, \"getChild\", new Integer(i), !child.mayHaveRewrite());");
      } else {
      stream.println(ind(4) +   "getChild_handler[i] = new ASTNode$DepGraphNode(this, \"getChild\", new Integer(i));");
      }
      stream.println(ind(2) + "}");
      stream.println(ind(2) + "state().addHandlerDepTo(getChild_handler[i]);");
    }
    if (ASTNode.incrementalLevelAttr) {
      stream.println(ind(2) + "state().addHandlerDepTo(getChild_handler);");  
    }
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(2) + "if (child != null)");
      stream.println(ind(3) + "  state().addHandlerDepTo(child.handler);");
    }
    if (ASTNode.incrementalLevelRegion) {
      if (isRegionRoot()) {
        stream.println(ind(2) + "if (state().IN_COMPUTATION > 0 && child != null) {");
        stream.println(ind(3) + "  child.handler().addDependant(handler);");
        stream.println(ind(2) + "}");
      }
    }
  }

  // ES_2011-09-20: Code generation for incremental evaluation, tracking getParent
  public void ASTDecl.jjtGenIncrementalTrackGetParent(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
      stream.println(ind(2) + "state().addHandlerDepTo(getParent_handler);");
    }
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(2) + "if (parent != null)");
      stream.println(ind(3) +   "state().addHandlerDepTo(((ASTNode)parent).handler);");
    }
    if (ASTNode.incrementalLevelRegion) {
      if (isRegionRoot()) {
        stream.println(ind(2) + "if (state().IN_COMPUTATION > 0 && parent != null)");
        stream.println(ind(3) +   "parent.handler().addDependant(handler);");
      }
    }
  }

  // ES_2011-09-20: Code generation for incremental evaluation, tracking numChildren
  public void ASTDecl.jjtGenIncrementalTrackNumChild(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
      stream.println(ind(2) + "state().addHandlerDepTo(numChildren_handler);");
    }
  }

  // ES_2011-09-20: Code generation for incremental evaluation, modifying tree, set parent
  public void ASTDecl.jjtGenIncrementalSetParent(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr || ASTNode.incrementalLevelNode) {
//    stream.println(ind(2) + "if (!state().IN_CONSTRUCTION && !state().IN_REWRITE_EVAL && !state().IN_ATTR_STORE_EVAL) {");
    stream.println(ind(2) + "if (!state().IN_CONSTRUCTION && !state().IN_ATTR_STORE_EVAL) {");
    }
    if (ASTNode.incrementalLevelRegion) {
    stream.println(ind(2) + "if (!state().IN_CONSTRUCTION && !(state().IN_COMPUTATION > 0)) {");
    }
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
      stream.println(ind(3) + "getParent_handler.notifyDependencies();");
    }
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(2) + "if (parent != null) {");
      stream.println(ind(3) +   "parent.handler.flushRegion();");
      stream.println(ind(2) + "}");
    }
    if (ASTNode.incrementalLevelRegion) {
      stream.println(ind(2) + "if (parent != null) {");
      stream.println(ind(3) +   "parent.handler().flushRegion();");
      stream.println(ind(2) + "}");
    }
    stream.println(ind(2) + "}");
    stream.println(ind(2) + "if (parent != null) {");
    stream.println(ind(3) +   "int index = -1;");
    stream.println(ind(3) +   "for (int i = 0; parent.children != null && i < parent.children.length; i++) {");
    stream.println(ind(4) +     "if (parent.children[i] == this) {");
    stream.println(ind(5) +       "index = i;");
    stream.println(ind(5) +       "break;");
    stream.println(ind(4) +     "}");
    stream.println(ind(3) +   "}");
    stream.println(ind(3) +   "if (index >= 0)");
    stream.println(ind(4) +     "parent.removeChild(index);");
    stream.println(ind(2) + "}");
    stream.println(ind(2) + "if (node != null) {");
    stream.println(ind(3) +   "inc_changeState(node.inc_state);");
    stream.println(ind(2) + "} else inc_changeState(inc_GARBAGE);");
  }

  // ES_2011-09-20: Code generation for incremental evaluation
  String TokenComponent.jaddGenIncrementalTokenHandler() {
    if (!isNTA()) {
    if (ASTNode.incrementalLevelParam)
      if (ASTNode.incrementalPropLimit) {
        return "    protected ASTNode$DepGraphNode #HOST#.get#ID#_handler = " +
                   "new ASTNode$DepGraphNode(this, \"get#ID#\", null, true);\n";
      } else {
        return "    protected ASTNode$DepGraphNode #HOST#.get#ID#_handler = " +
                   "new ASTNode$DepGraphNode(this, \"get#ID#\", null);\n";
      }
    if (ASTNode.incrementalLevelAttr)
      return "    protected ASTNode$DepGraphNode #HOST#.get#ID#_handler = " +
                 "new ASTNode$DepGraphNode(this, \"get#ID#\");\n";
    }
    return ""; // ASTNode.incrementalLevelNode
  }

  // ES_2011-09-20: Code generation for incremental evaluation
  String TokenComponent.jaddGenIncrementalTokenChange(String varName) {
    StringBuffer buf = new StringBuffer();
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr || ASTNode.incrementalLevelNode) {
//      buf.append("    if (!state().IN_CONSTRUCTION && !state().IN_REWRITE_EVAL && !state().IN_ATTR_STORE_EVAL) {\n");
      buf.append("    if (!state().IN_CONSTRUCTION && !state().IN_ATTR_STORE_EVAL) {\n");
    }
    if (ASTNode.incrementalLevelRegion) {
      buf.append("    if (!state().IN_CONSTRUCTION && !(state().IN_COMPUTATION > 0)) {\n");
    }
    if (isNTA()) {
      buf.append("     if (get#ID#_computed) {\n");
      buf.append("       get#ID#_computed = false;\n");
      if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
      buf.append("       get#ID#_handler.notifyDependencies();\n");
      }
      if (ASTNode.incrementalLevelNode) {
      buf.append("       handler.flushRegion();\n");
      }
      if (ASTNode.incrementalLevelRegion) {
      buf.append("       handler().flushRegion();\n");
      }
      buf.append("     }\n");
    } else {
      if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
        if (ASTNode.incrementalTrack) {
          buf.append("       get#ID#_handler.trackChange();\n");    
        }
        buf.append("       get#ID#_handler.notifyDependencies();\n");
      }
      if (ASTNode.incrementalLevelNode) {
        buf.append("       handler.flushRegion();\n");
        String type = getTokenId().getTYPE();
        boolean isStringToken = type.equals("String") || type.equals("java.lang.String");
        boolean isPrimitiveToken = isPrimitive();
        if (!isStringToken && !isPrimitiveToken) {
          buf.append("       if (token#TYPEINSIGNATURE#_#ID# instanceof ASTNode) {\n");
          buf.append("         token#TYPEINSIGNATURE#_#ID#.handler.flushRegion();\n");
          buf.append("       }\n");
        }
      }
      if (ASTNode.incrementalLevelRegion) {
        buf.append("       handler().flushRegion();\n");
        String type = getTokenId().getTYPE();
        boolean isStringToken = type.equals("String") || type.equals("java.lang.String");
        boolean isPrimitiveToken = isPrimitive();
        if (!isStringToken && !isPrimitiveToken) {
          buf.append("       if (token#TYPEINSIGNATURE#_#ID# instanceof ASTNode && token#TYPEINSIGNATURE#_#ID#.isRegionRoot()) {\n");
          buf.append("         token#TYPEINSIGNATURE#_#ID#.handler().flushRegion();\n");
          buf.append("       }\n");
        }
      }
      buf.append("       ASTNode initial = inc_locateInitialCopy();\n");
      buf.append("       if (initial != null) {\n");
      buf.append("         state().enterConstruction();\n");
      buf.append("         ((#HOST#)initial).set#ID#(" + varName + ");\n");
      buf.append("         state().exitConstruction();\n");
      buf.append("         return;\n");
      buf.append("       }\n");
    }
    buf.append("    }\n");
    return buf.toString();
  }

  // ES_2011-09-20: Code generation for incremental evaluation
  String TokenComponent.jaddGenIncrementalTokenTrack() {
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr)
      return "        state().addHandlerDepTo(get#ID#_handler);\n";
    if (ASTNode.incrementalLevelNode) {
      String type = getTokenId().getTYPE();
      boolean isStringToken = type.equals("String") || type.equals("java.lang.String");
      boolean isPrimitiveToken = isPrimitive();
      if (!isStringToken && !isPrimitiveToken) {
        StringBuffer buf = new StringBuffer();
        buf.append("        if (token#TYPEINSIGNATURE#_#ID# instanceof ASTNode) {\n");
        buf.append("          state().addHandlerDepTo(((ASTNode)token#TYPEINSIGNATURE#_#ID#).handler);\n");
        buf.append("        }\n");
        return buf.toString();
      }
    }
    if (ASTNode.incrementalLevelRegion) {
      String type = getTokenId().getTYPE();
      boolean isStringToken = type.equals("String") || type.equals("java.lang.String");
      boolean isPrimitiveToken = isPrimitive();
      if (!isStringToken && !isPrimitiveToken) {
        StringBuffer buf = new StringBuffer();
        buf.append("        if (token#TYPEINSIGNATURE#_#ID# instanceof ASTNode && token#TYPEINSIGNATURE#_#ID#.isRegionRoot()) {\n");
        buf.append("          ((ASTNode)token#TYPEINSIGNATURE#_#ID#).handler().addDependant(handler());\n");
        buf.append("        }\n");
        return buf.toString();
      }
    }
    return "";
  }

  // ES_2011-10-10: Code generation for full flush, creating initial copy store
  public void ASTDecl.jjtGenFullFlush1(PrintWriter stream) {
    stream.println(ind(2) + "if(that.init_children == null) {");
    stream.println(ind(3) +   "that.init_children = new ASTNode[that.children.length];");
    stream.println(ind(3) +   "that.rewritten_children = new boolean[that.children.length];");
    stream.println(ind(2) + "}");
    stream.println(ind(2) + "if(!node.inc_hasEnclosingRewrittenNode()) {");
    stream.println(ind(3) +   "that.init_children[i] = node.fullCopy();");
    stream.println(ind(3) +   "that.rewritten_children[i] = true;");
    stream.println(ind(2) + "}");
  }

  // ES_2011-10-10: Code generation for full flush, storing initial copy setting rewrite to true
  public void ASTDecl.jjtGenFullFlush2(PrintWriter stream) {
    stream.println(ind(4) + "if (rewriteState == ASTNode$State.REWRITE_CHANGE) {");
    stream.println(ind(5) +   "that.rewritten_children[i] = true;");
    stream.println(ind(4) + "}");
  }
  
  // ES_2011-10-10: Code generation for full flush, set child 1
  public void ASTDecl.jjtGenFullFlushSetChild1(PrintWriter stream) {
    stream.println(ind(2) + "if (init_children != null) {");
    stream.println(ind(3) +   "ASTNode d[] = new ASTNode[i << 1];");
    stream.println(ind(3) +   "System.arraycopy(init_children, 0, d, 0, init_children.length);");
    stream.println(ind(3) +   "init_children = d;");
    stream.println(ind(2) + "}");
    stream.println(ind(2) + "if (rewritten_children != null) {");
    stream.println(ind(3) +   "boolean[] b = new boolean[i << 1];");
    stream.println(ind(3) +   "System.arraycopy(rewritten_children, 0, b, 0, rewritten_children.length);");
    stream.println(ind(3) +   "rewritten_children = b;");
    stream.println(ind(2) + "}");
  }

  // ES_2011-10-10: Code generation for full flush, set child 2
  public void ASTDecl.jjtGenFullFlushSetChild2(PrintWriter stream) {
    stream.println(ind(2) + "if (rewritten_children != null) {");
    stream.println(ind(3) +   "rewritten_children[i] = false;"); 
    stream.println(ind(2) + "}");   
  }

  // ES_2011-10-10: Code generation for full flush, insert child 1
  public void ASTDecl.jjtGenFullFlushInsertChild1(PrintWriter stream) {
    stream.println(ind(2) + "if (init_children != null) {");
    stream.println(ind(3) +   "ASTNode d[] = new ASTNode[init_children.length + 1];");
    stream.println(ind(3) +   "System.arraycopy(init_children, 0, d, 0, init_children.length);");
    stream.println(ind(3) +   "if (i < init_children.length) {");
    stream.println(ind(4) +     "System.arraycopy(init_children, i, d, i+1, init_children.length - i);");
    stream.println(ind(3) +   "}");
    stream.println(ind(3) +   "init_children = d;");
    stream.println(ind(2) + "}");
    stream.println(ind(2) + "if (rewritten_children != null) {");
    stream.println(ind(3) +   "boolean b[] = new boolean[rewritten_children.length + 1];");
    stream.println(ind(3) +   "System.arraycopy(rewritten_children, 0, b, 0, rewritten_children.length);");
    stream.println(ind(3) +   "if (i < rewritten_children.length) {");
    stream.println(ind(4) +     "System.arraycopy(rewritten_children, i, b, i+1, rewritten_children.length - i);");
    stream.println(ind(3) +   "}");
    stream.println(ind(3) +   "rewritten_children = b;");
    stream.println(ind(2) + "}");
  }

  // ES_2011-10-10: Code generation for full flush, remove child 1
  public void ASTDecl.jjtGenFullFlushRemoveChild1(PrintWriter stream) {
    stream.println(ind(3) + "if (init_children != null) {");
    stream.println(ind(4) +   "System.arraycopy(init_children, i+1, init_children, i, init_children.length-i-1);");
    stream.println(ind(3) + "}");      
    stream.println(ind(3) + "if (rewritten_children != null) {");
    stream.println(ind(4) +   "System.arraycopy(rewritten_children, i+1, rewritten_children, i, rewritten_children.length-i-1);");
    stream.println(ind(3) + "}");
  }

  // ES_2012-01-31: Code generation for incremental evaluation, modifying tree, add child 1
  public void ASTDecl.jjtGenIncrementalASTChangeAddChild1(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(3) + "int i = getNumChildNoTransform() - 1;");
      stream.println(ind(3) + "if (getChild_handler[i] == null)");
      if (ASTNode.incrementalPropLimit) {
      stream.println(ind(4) +   "getChild_handler[i] = new ASTNode$DepGraphNode(this, \"getChild\", new Integer(i), !node.mayHaveRewrite());");
      } else {
      stream.println(ind(4) +   "getChild_handler[i] = new ASTNode$DepGraphNode(this, \"getChild\", new Integer(i));");
      }
      stream.println(ind(3) + "state().addHandlerDepTo(getChild_handler[i]);");    
      stream.println(ind(3) + "if (state().IN_ATTR_STORE_EVAL && !node.mayHaveRewrite()) node.is$Final(is$Final());");
    }
    if (ASTNode.incrementalLevelAttr) {
      stream.println(ind(3) + "state().addHandlerDepTo(getChild_handler);");
      stream.println(ind(3) + "if (state().IN_ATTR_STORE_EVAL && !node.mayHaveRewrite()) node.is$Final(is$Final());");
    }
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(3) + "if (node != null) {");
      stream.println(ind(4) +   "state().addHandlerDepTo(node.handler);");
      stream.println(ind(4) +   "if (state().IN_ATTR_STORE_EVAL && !node.mayHaveRewrite()) node.is$Final(is$Final());");
      stream.println(ind(3) + "}");
    }
    if (ASTNode.incrementalLevelRegion) {
      stream.println(ind(3) + "if (node != null && node.isRegionRoot()) {");
      stream.println(ind(4) +   "state().addHandlerDepTo(node.handler());");
      stream.println(ind(4) +   "if (state().IN_ATTR_STORE_EVAL && !node.mayHaveRewrite()) node.is$Final(is$Final());");
      stream.println(ind(3) + "}");
    }
  }

  // ES_2011-10-06: Code generation for incremental evaluation, modifying tree, set child 1
  public void ASTDecl.jjtGenIncrementalASTChangeSetChild1(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr || ASTNode.incrementalLevelNode) {
//    stream.println(ind(2) + "if (!state().IN_CONSTRUCTION && !state().IN_REWRITE_EVAL && !state().IN_ATTR_STORE_EVAL) {");
    stream.println(ind(2) + "if (!state().IN_CONSTRUCTION && !state().IN_ATTR_STORE_EVAL) {");
    }
    if (ASTNode.incrementalLevelRegion) {
    stream.println(ind(2) + "if (!state().IN_CONSTRUCTION && !(state().IN_COMPUTATION > 0)) {");
    }
    // notify current child
    stream.println(ind(3) +   "if (children != null && i < children.length && children[i] != null) {");
    stream.println(ind(4) +     "children[i].inc_notifyForRemove();");
    //if (ASTNode.incrementalDebug) stream.println(ind(4) +     "children[i].inc_clearDepsInTree();");
    stream.println(ind(3) +   "}");

    // notify dependencies
    if (ASTNode.incrementalLevelParam) {  
      // notify empty
      stream.println(ind(3) +   "if (children == null) {");
      stream.println(ind(4) +     "numChildren_handler.notifyDependencies();");
      // notify add
      stream.println(ind(3) +   "} else if (i >= numChildren) {");
      stream.println(ind(4) +     "numChildren_handler.notifyDependencies();");
      stream.println(ind(4) +     "if (i > 0 && getChild_handler[i-1] != null) {");
      stream.println(ind(5) +       "getChild_handler[i-1].notifyDependencies();");
      stream.println(ind(4) +     "}");
      stream.println(ind(3) +   "}");
    }
    // notify set
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(3) +   "else {");
      stream.println(ind(4) +     "if (getChild_handler[i] != null) {");
      stream.println(ind(5) +       "getChild_handler[i].notifyDependencies();");
      stream.println(ind(4) +     "} else getChild_handler[i] = new ASTNode$DepGraphNode(this, \"getChild\", new Integer(i));");
      stream.println(ind(3) +   "}");
    }
    if (ASTNode.incrementalLevelAttr) {
      //stream.println(ind(3) +   "getChild_handler.notifyDependencies();");
      stream.println(ind(3) +   "getChild_handler.flushRegion();");
    }
    if (ASTNode.incrementalLevelNode) {
      //stream.println(ind(3) +   "handler.notifyDependencies();");
      stream.println(ind(3) +   "if (children != null && i < children.length && children[i] != null) children[i].handler.notifyDependencies();");
      stream.println(ind(3) +   "if (i == numChildren) handler.notifyDependencies();");
    }
    if (ASTNode.incrementalLevelRegion) {
      stream.println(ind(3) +   "ASTNode$DepGraphNode h = (children != null && i < children.length && children[i] != null) ? children[i].handler() : handler();");
      stream.println(ind(3) +   "if (h != null) h.notifyDependencies();");
      stream.println(ind(3) +   "if (i == numChildren) handler.notifyDependencies();");
    }
    // change in initial copy?
    stream.println(ind(3) +   "ASTNode initial  = inc_locateInitialCopy();");
    stream.println(ind(3) +   "if (initial != null) {");
    stream.println(ind(4) +     "state().enterConstruction();");
    stream.println(ind(4) +     "if (i >= initial.numChildren)");
    stream.println(ind(5) +       "initial.addChild(node);");
    stream.println(ind(4) +     "else initial.setChild(node, i);");
    stream.println(ind(4) +     "state().exitConstruction();");
    stream.println(ind(4) +     "return;");
    stream.println(ind(3) +   "}");
    stream.println(ind(2) + "}");
  }

  // ES_2011-10-06: Code generation for incremental evaluation, modifying tree, set child 1
  public void ASTDecl.jjtGenIncrementalASTChangeSetChild2(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam) 
      stream.println(ind(3) + "getChild_handler = new ASTNode$DepGraphNode[i + 1];");
  }

  // ES_2011-10-06: Code generation for incremental evaluation, modifying tree, set child 2
  public void ASTDecl.jjtGenIncrementalASTChangeSetChild3(PrintWriter stream) {
    // rewrite code
    if (!ASTNode.fullFlush) {
      stream.println(ind(3) + "if (init_children != null) {");
      stream.println(ind(4) +   "ASTNode d[] = new ASTNode[i << 1];");
      stream.println(ind(4) +   "System.arraycopy(init_children, 0, d, 0, init_children.length);");
      stream.println(ind(4) +   "init_children = d;");
      stream.println(ind(3) + "}");
      stream.println(ind(3) + "if (rewritten_children != null) {");
      stream.println(ind(4) +   "boolean[] b = new boolean[i << 1];");
      stream.println(ind(4) +   "System.arraycopy(rewritten_children, 0, b, 0, rewritten_children.length);");
      stream.println(ind(4) +   "rewritten_children = b;");
      stream.println(ind(3) + "}");
    }
    //
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(3) + "if (getChild_handler != null) {");
      stream.println(ind(4) +   "ASTNode$DepGraphNode h[] = new ASTNode$DepGraphNode[i << 1];");
      stream.println(ind(4) +   "System.arraycopy(getChild_handler, 0, h, 0, getChild_handler.length);");
      stream.println(ind(4) +   "getChild_handler = h;");
      stream.println(ind(3) + "}");
    }
  }

  // ES_2011-09-20: Code generation for incremental evaluation, modifying tree, set child 3
  public void ASTDecl.jjtGenIncrementalASTChangeSetChild4(PrintWriter stream) {
    if (!ASTNode.fullFlush) {
      stream.println(ind(2) + "if (rewritten_children != null) {");
      stream.println(ind(3) +   "rewritten_children[i] = false;"); 
      stream.println(ind(2) + "}");   
    }
  }

  // ES_2011-09-20: Code generation for incremental evaluation, modifying tree, set child 3
  public void ASTDecl.jjtGenIncrementalASTChangeSetChild5(PrintWriter stream) {
    stream.println(ind(2) + "if (children[i] != null) {");
    stream.println(ind(3) +   "children[i].inc_throwAway();");
    stream.println(ind(3) +   "children[i].parent = null;");
    stream.println(ind(2) + "}");
  }

  // ES_2011-09-20: Code generation for incremental evaluation, modifying tree, insert child 1
  public void ASTDecl.jjtGenIncrementalASTChangeInsertChild1(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(3) + "getChild_handler = new ASTNode$DepGraphNode[i + 1];");
      stream.println(ind(3) + "getChild_handler[i] = new ASTNode$DepGraphNode(this, \"getChild\", new Integer(i));");
    }
  }

  // ES_2011-09-20: Code generation for incremental evaluation, modifying tree, insert child 2
  public void ASTDecl.jjtGenIncrementalASTChangeInsertChild2(PrintWriter stream) {
    // rewrite code
    if (!ASTNode.fullFlush) {
      stream.println(ind(2) + "if (init_children != null) {");
      stream.println(ind(3) +   "ASTNode d[] = new ASTNode[init_children.length + 1];");
      stream.println(ind(3) +   "System.arraycopy(init_children, 0, d, 0, init_children.length);");
      stream.println(ind(3) +   "if (i < init_children.length) {");
      stream.println(ind(4) +     "System.arraycopy(init_children, i, d, i+1, init_children.length - i);");
      stream.println(ind(3) +   "}");
      stream.println(ind(3) +   "init_children = d;");
      stream.println(ind(2) + "}");
      stream.println(ind(2) + "if (rewritten_children != null) {");
      stream.println(ind(3) +   "boolean b[] = new boolean[rewritten_children.length + 1];");
      stream.println(ind(3) +   "System.arraycopy(rewritten_children, 0, b, 0, rewritten_children.length);");
      stream.println(ind(3) +   "if (i < rewritten_children.length) {");
      stream.println(ind(4) +     "System.arraycopy(rewritten_children, i, b, i+1, rewritten_children.length - i);");
      stream.println(ind(3) +   "}");
      stream.println(ind(3) +   "rewritten_children = b;");
      stream.println(ind(2) + "}");
    }
    //
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(2) + "if (getChild_handler != null) {");
      stream.println(ind(3) +   "ASTNode$DepGraphNode h[] = new ASTNode$DepGraphNode[getChild_handler.length + 1];");
      stream.println(ind(3) +   "System.arraycopy(getChild_handler, 0, h, 0, getChild_handler.length);");
//      stream.println(ind(3) +   "if (i < getChild_handler.length) {");
//      stream.println(ind(4) +     "System.arraycopy(getChild_handler, i, h, i+1, getChild_handler.length - 1);");
//      stream.println(ind(3) +   "}");
      stream.println(ind(3) +   "getChild_handler = h;");
//      stream.println(ind(3) +   "for (int k = i; k < getChild_handler.length; k++) {");
//      stream.println(ind(4) +     "if (getChild_handler[k] != null) {");
//      stream.println(ind(5) +       "getChild_handler[k].setParams(new Integer(k));");
//      stream.println(ind(4) +     "}");Region
//      stream.println(ind(3) +   "}");
      stream.println(ind(2) + "}");
    }
  }

  // ES_2011-10-06: Code generation for incremental evaluation, modifying tree, insert child 4
  public void ASTDecl.jjtGenIncrementalASTChangeInsertChild3(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr || ASTNode.incrementalLevelNode) {
//    stream.println(ind(2) + "if (!state().IN_CONSTRUCTION && !state().IN_REWRITE_EVAL && !state().IN_ATTR_STORE_EVAL) {");
    stream.println(ind(2) + "if (!state().IN_CONSTRUCTION && !state().IN_ATTR_STORE_EVAL) {");
    }
    if (ASTNode.incrementalLevelRegion) {
    stream.println(ind(2) + "if (!state().IN_CONSTRUCTION && !(state().IN_COMPUTATION > 0)) {");
    }
    // notify
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
      stream.println(ind(3) + "if (children == null || i > numChildren) {");
      stream.println(ind(4) +   "numChildren_handler.notifyDependencies();");
      stream.println(ind(3) + "} else {");
      stream.println(ind(4) +   "numChildren_handler.notifyDependencies();");
      if (ASTNode.incrementalLevelParam) { 
        stream.println(ind(4) +   "for (int k = i; k < children.length; k++) {");
        stream.println(ind(5) +     "if (getChild_handler[k] != null) {");
        stream.println(ind(6) +       "getChild_handler[k].notifyDependencies();");
        stream.println(ind(5) +     "}");
       stream.println(ind(4) +   "}");
      }
      if (ASTNode.incrementalLevelAttr) {
        //stream.println(ind(4) +   "getChild_handler.notifyDependencies();");
        stream.println(ind(4) +   "getChild_handler.flushRegion();");
      }
      stream.println(ind(3) + "}");
    }
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(3) + "for (int k = i; k < children.length; k++) {");
      stream.println(ind(4) +   "ASTNode child = children[i];");
      stream.println(ind(4) +   "if (child != null) {");
      stream.println(ind(5) +     "child.handler.flushRegion();");
      stream.println(ind(4) +   "}");
      stream.println(ind(3) + "}");
    }
    if (ASTNode.incrementalLevelRegion) {
      stream.println(ind(3) + "for (int k = i; k < children.length; k++) {");
      stream.println(ind(4) +   "ASTNode child = children[i];");
      stream.println(ind(4) +   "if (child != null) {");
      stream.println(ind(5) +     "child.handler().flushRegion();");
      stream.println(ind(4) +   "}");
      stream.println(ind(3) + "}");
    }
    // locate initial copy
    stream.println(ind(3) +   "ASTNode initial = inc_locateInitialCopy();");
    stream.println(ind(3) +   "if (initial != null) {");
    stream.println(ind(4) +     "state().enterConstruction();");
    stream.println(ind(4) +     "initial.insertChild(node, i);");
    stream.println(ind(4) +     "state().exitConstruction();");
    stream.println(ind(4) +     "return;");
    stream.println(ind(3) +   "}");
    stream.println(ind(2) + "}");
  }

  // ES_2011-09-20: Code generation for incremental evaluation, modifying tree, remove child 1
  public void ASTDecl.jjtGenIncrementalASTChangeRemoveChild1(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr || ASTNode.incrementalLevelNode) {
//    stream.println(ind(2) + "if (!state().IN_CONSTRUCTION && !state().IN_REWRITE_EVAL && !state().IN_ATTR_STORE_EVAL) {");
    stream.println(ind(2) + "if (!state().IN_CONSTRUCTION && !state().IN_ATTR_STORE_EVAL) {");
    }
    if (ASTNode.incrementalLevelRegion) {
    stream.println(ind(2) + "if (!state().IN_CONSTRUCTION && !(state().IN_COMPUTATION > 0)) {");
    }
    // notify
    stream.println(ind(4) +   "if (children[i] != null)");
    stream.println(ind(5) +     "children[i].inc_notifyForRemove();");
    if (ASTNode.incrementalLevelParam) {
    stream.println(ind(4) +   "numChildren_handler.notifyDependencies();");
    stream.println(ind(4) +   "for (int k = i; k < children.length; k++) {");
    stream.println(ind(5) +     "if (getChild_handler[k] != null) {");
    stream.println(ind(6) +       "getChild_handler[k].notifyDependencies();");
    stream.println(ind(5) +     "}");
    stream.println(ind(4) +   "}");
    }
    if (ASTNode.incrementalLevelAttr) {
      //stream.println(ind(4) +   "getChild_handler.notifyDependencies();");
      stream.println(ind(4) +   "getChild_handler.flushRegion();");
    }
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(4) +   "handler.flushRegion();");
      stream.println(ind(3) + "for (int k = i; k < children.length; k++) {");
      stream.println(ind(4) +   "ASTNode child = children[i];");
      stream.println(ind(4) +   "if (child != null) {");
      stream.println(ind(5) +     "child.handler.flushRegion();");
      stream.println(ind(4) +   "}");
      stream.println(ind(3) + "}");
    }
    if (ASTNode.incrementalLevelRegion) {
      stream.println(ind(4) + "handler().flushRegion();");
      stream.println(ind(3) + "for (int k = i; k < children.length; k++) {");
      stream.println(ind(4) +   "ASTNode child = children[i];");
      stream.println(ind(4) +   "if (child != null) {");
      stream.println(ind(5) +     "child.handler().flushRegion();");
      stream.println(ind(4) +   "}");
      stream.println(ind(3) + "}");
    }
    // locate initial copy
    stream.println(ind(4) +   "ASTNode initial = inc_locateInitialCopy();");
    stream.println(ind(4) +   "if (initial != null) {");
    stream.println(ind(5) +     "state().enterConstruction();");
    stream.println(ind(5) +     "initial.removeChild(i);");
    stream.println(ind(5) +     "state().exitConstruction();");
    stream.println(ind(5) +     "return;");
    stream.println(ind(4) +   "}");
    stream.println(ind(3) + "}");
  }

  // ES_2011-09-20: Code generation for incremental evaluation, modifying tree, remove child 1
  public void ASTDecl.jjtGenIncrementalASTChangeRemoveChild2(PrintWriter stream) {
    // rewrite code
    if (!ASTNode.fullFlush) {
      stream.println(ind(3) + "if (init_children != null) {");
      stream.println(ind(4) +   "if (i < init_children.length && init_children[i] != null) {");
      stream.println(ind(5) +     "init_children[i].inc_throwAway();");
      stream.println(ind(4) +   "}");
      stream.println(ind(4) +   "System.arraycopy(init_children, i+1, init_children, i, init_children.length-i-1);");
      stream.println(ind(4) +   "init_children[init_children.length-1] = null;");
      stream.println(ind(3) + "}");      
      stream.println(ind(3) + "if (rewritten_children != null) {");
      stream.println(ind(4) +   "System.arraycopy(rewritten_children, i+1, rewritten_children, i, rewritten_children.length-i-1);");
      stream.println(ind(4) +   "rewritten_children[rewritten_children.length-1] = false;");
      stream.println(ind(3) + "}");
    }
    //
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(3) + "if (getChild_handler != null && this instanceof List) {");
      stream.println(ind(4) +   "getChild_handler[numChildren] = null;");
//      stream.println(ind(4) +   "System.arraycopy(getChild_handler, i+1, " + 
//          "getChild_handler, i, getChild_handler.length-i-1);");
//      stream.println(ind(4) +   "for (int k = i; k < getChild_handler.length; k++) {");
//      stream.println(ind(5) +     "if (getChild_handler[k] != null) {");
//      stream.println(ind(6) +       "getChild_handler[k].setParams(new Integer(k));");
//      stream.println(ind(5) +     "}");
//      stream.println(ind(4) +   "}");
      stream.println(ind(3) + "}");
    }
  }

  // ES_2011-11-28: Code generation for incremental evaluation, modifying tree, remove child 3
  public void ASTDecl.jjtGenIncrementalASTChangeRemoveChild3(PrintWriter stream) {
    // prevent recursive call during state handling where setParent calls removeChild
    stream.println(ind(4) + "child.inc_throwAway();");      
  }

}
