aspect CollectionAttributes {

  public static String ASTNode.createContributorSet = "new ASTNode$State.IdentityHashSet(4)";

  // code generation
  //eq CollDecl.visitCheckEnabled() = true;

  public String ASTDecl.flushCollectionCacheString() {
    StringBuffer res = new StringBuffer();
    for(int i = 0; i < getNumCollDecl(); i++) {
      CollDecl attr = getCollDecl(i);
      String s = attr.resetVisit() + attr.resetCache();
      if(!attr.separateEvaluation() && !attr.onePhase())
        s += ind(2) + "#NAME#_contributors = " + (lazyMaps ? "null" : ASTNode.createContributorSet) + ";\n";
      s = s.replaceAll("#NAME#", attr.attributeSignature());
      res.append(s);

    }
    res.append(collectionReset);
    return res.toString();
  }

  public String ASTDecl.genCollDecls() {
    StringBuffer buf = new StringBuffer();
    for(int i = 0; i < getNumCollDecl(); i++) {
      CollDecl attr = getCollDecl(i);
      String s = "";
      if(attr.circularCollection()) {
        s = genCircular(attr, attr.hostFileComment(ind)) + attr.combineMethod();
      } else {
        s += attr.hostFileComment(ind);
        s += genEquation(attr);
        s += attr.computeMethod();
        s = getCacheDeclarations(attr) + s;
      }
      s = s.replaceAll("#TYPE#", attr.getType());
      s = s.replaceAll("#TYPEINSIGNATURE#", name());
      s = s.replaceAll("#COLLECTINGSIGNATURE#", attr.collectingSignature());
      s = s.replaceAll("#CLASS#\\.", "");
      s = s.replaceAll("#NAME#", attr.attributeSignature());
      s = s.replaceAll("#METHODNAME#", attr.attributeName());
      s = s.replaceAll("#PARMDECL#", attr.parametersDecl());
      s = s.replaceAll("#PARM#", attr.parameters());
      buf.append(s);
    }
    return buf.toString();
  }

  public String InterfaceDecl.genInterfaceCollections() {
    StringBuffer buf = new StringBuffer();
    for(int i = 0; i < getNumCollDecl(); i++) {
      CollDecl attr = getCollDecl(i);
      if(!attr.separateEvaluation() && (attr.isCircular() || !attr.onePhase())) {
        buf.append(ind + "/**\n");
        buf.append(ind + " * @apilevel internal\n");
        buf.append(ind + " */\n");
        buf.append(ind + "public " + typeDefaultSet + " " + attr.attributeSignature() + "_contributors();\n");
      }
    }
    return buf.toString();
  }

  syn TypeDecl AttrDecl.root() = hostClass().env().root();
  eq CollDecl.root() = root != null ? hostClass().env().lookup(root) : super.root();

  syn String AttrDecl.collDebugString() {
    if(!debugMode)
      return "";
    else
      return "if(node == null) throw new RuntimeException(\"Trying to evaluate collection attribute in subtree not attached to main tree\");";
  }

  // only used by circular collection attributes
  public String ASTDecl.genCircular(AttrDecl attr, String comment) {
    boolean needsCacheDeclaration = true;
    boolean separateEvaluation = attr.separateEvaluation();
    String rootType = attr.root().name();
    if(attr.getNumParameter() == 0)
      return attr.visitedDeclarations() +
         ind + "/**\n" +
         ind + " * @apilevel internal\n" +
         ind + " */\n" +
         ind + "protected boolean #CLASS#.#NAME#_computed = false;\n" +
         ind + "/**\n" +
         ind + " * @apilevel internal\n" +
         ind + " */\n" +
         ind + "protected boolean #CLASS#.#NAME#_initialized = false;\n" +
         ind + "/**\n" +
         ind + " * @apilevel internal\n" +
         ind + " */\n" +
         ind + "protected #TYPE# #CLASS#.#NAME#_value;\n" +
         (separateEvaluation ? ind + "protected #TYPE# #CLASS#.new_#NAME#_value;\n" : "") +
         comment + suppressWarnings() +
         ind + "public #TYPE# #CLASS#.#METHODNAME#(#PARMDECL#) {\n" +
         (ASTNode.block ? ASTNode.blockBegin : "") +
         attr.parameterStructure() +
         attr.cacheCheck() +
         ind(2) + "ASTNode node = this;\n" +
         ind(2) + "while(node.getParent() != null && !(node instanceof " + rootType + "))\n" +
         ind(3) + "node = node.getParent();\n" +
         ind(2) + attr.collDebugString() +
         ind(2) + rootType + " root = (" + rootType + ")node;\n" +
         (separateEvaluation ? "" :
         (ind(2) + "if(root.collecting_contributors_#COLLECTINGSIGNATURE#)\n" +
         ind(3) + "throw new RuntimeException(\"Circularity during phase 1\");\n")) +
         attr.addComponentCheck() +
         (separateEvaluation ? "" :
         ind(2) + "root.collect_contributors_#COLLECTINGSIGNATURE#();\n") +
         ind(2) + "if (!#NAME#_initialized) {\n" +
         ind(3) + "#NAME#_initialized = true;\n" +
         ind(3) + "#NAME#_value = " + Unparser.unparse(attr.getBottomValue()) + ";\n" +
         ind(2) + "}\n" +
         ind(2) + "if (!state().IN_CIRCLE) {\n" +
         ind(3) + "state().IN_CIRCLE = true;\n" +
         attr.addAddToComponent() +
         attr.cacheInitRewrite(ind(3)) +
         ind(3) + "state().CIRCLE_INDEX = 1;\n" +
         ind(3) + "do {\n" +
         ind(4) + "#NAME#_visited = state().CIRCLE_INDEX;\n" +
         ind(4) + "state().CHANGE = false;\n" +
         (separateEvaluation ?
         ind(4) + "new_#NAME#_value = " + Unparser.unparse(attr.getBottomValue()) + ";\n" :
         ind(4) + "#TYPE# new_#NAME#_value = " + Unparser.unparse(attr.getBottomValue()) + ";\n") +
         (separateEvaluation ? "root.#TYPEINSIGNATURE#_#NAME#_nextIteration(this);\n" :
         ind(4) + "combine_#NAME#_contributions(new_#NAME#_value);\n") +
         ind(4) + "if (" + attr.differs("new_#NAME#_value", "#NAME#_value") + ")\n" +
         ind(5) + "state().CHANGE = true;\n" +
         ind(4) + "#NAME#_value = new_#NAME#_value; \n" +
         ind(4) + "state().CIRCLE_INDEX++;\n" +
         attr.cycleLimitCheck() +
         ind(3) + "} while (state().CHANGE);\n" +
         ind(3) + attr.cacheStoreRewrite() + "{\n" +
         ind(3) + "#NAME#_computed = true;\n" +
         attr.cacheCycleInit() +
         ind(2) + "}\n" +
         ind(2) + "else {\n" +
         attr.resetCycleInit() +
         ind(3) + "#NAME#_computed = false;\n" +
         ind(3) + "#NAME#_initialized = false;\n" +
         ind(2) + "}\n" +
         ind(2) + "state().IN_CIRCLE = false; \n" +
         ind(2) + attr.returnStmt() +
         ind(2) + "}\n" +
         ind(2) + "if(#NAME#_visited != state().CIRCLE_INDEX) {\n" +
         ind(3) + "#NAME#_visited = state().CIRCLE_INDEX;\n" +
         attr.cacheCycleCheck() +
         attr.resetCycleCheck() +
         attr.addAddToComponent() +
         (separateEvaluation ?
         ind(3) + "new_#NAME#_value = " + Unparser.unparse(attr.getBottomValue()) + ";\n" :
         ind(3) + "#TYPE# new_#NAME#_value = " + Unparser.unparse(attr.getBottomValue()) + ";\n") +
         (separateEvaluation ? "root.#TYPEINSIGNATURE#_#NAME#_nextIteration(this);\n" :
         ind(3) + "combine_#NAME#_contributions(new_#NAME#_value);\n") +
         ind(3) + "if (" + attr.differs("new_#NAME#_value", "#NAME#_value") + ")\n" +
         ind(4) + "state().CHANGE = true;\n" +
         ind(3) + "#NAME#_value = new_#NAME#_value; \n" +
         ind(3) + attr.returnStmt() +
         ind(2) + "}\n" +
         ind(2) + attr.returnStmt() +
         (ASTNode.block ? ASTNode.blockEnd : "") +
         ind + "}\n\n";
    else
      return attr.visitedDeclarations() +
         ind + "/**\n" +
         ind + " * @apilevel internal\n" +
         ind + " */\n" +
         ind + "protected " + typeDefaultSet + " #CLASS#.#NAME#_computed = " + createDefaultSet + ";\n" +
         ind + "/**\n" +
         ind + " * @apilevel internal\n" +
         ind + " */\n" +
         ind + "protected " + typeDefaultSet + " #CLASS#.#NAME#_initialized = " + createDefaultSet + ";\n" +
         ind + "/**\n" +
         ind + " * @apilevel internal\n" +
         ind + " */\n" +
         ind + "protected " + typeDefaultMap + " #CLASS#.#NAME#_values = " + createDefaultMap + ";\n" +
         comment + suppressWarnings() +
         ind + "public #TYPE# #CLASS#.#METHODNAME#(#PARMDECL#) {\n" +
         (ASTNode.block ? ASTNode.blockBegin : "") +
         attr.parameterStructure() +
         attr.initLazyMaps() +
         attr.cacheCheck() +
         attr.addComponentCheck() +
         ind(2) + "if (!#NAME#_initialized.contains(_parameters)) {\n" +
         ind(3) + "#NAME#_initialized.add(_parameters);\n" +
         ind(3) + "#NAME#_values.put(_parameters, " + toReferenceType(
               Unparser.unparse(attr.getBottomValue()), attr.getType()) + ");\n" +
         ind(2) + "}\n" +
         ind(2) + "if (!state().IN_CIRCLE) {\n" +
         ind(3) + "state().IN_CIRCLE = true;\n" +
         attr.cacheInitRewrite(ind(2)) +
         attr.addAddToComponent() +
         ind(3) + "state().CIRCLE_INDEX = 1;\n" +
         ind(3) + "#TYPE# new_#NAME#_value;\n" +
         ind(3) + "do {\n" +
         ind(4) + "#NAME#_visited.put(_parameters, new Integer(state().CIRCLE_INDEX));\n" +
         ind(4) + "state().CHANGE = false;\n" +
         ind(4) + "new_#NAME#_value = " +
         Unparser.unparse(attr.getBottomValue()) + ";\n" +
         ind(4) + "combine_#NAME#_contributions(new_#NAME#_value);\n" +
         ind(4) + "if (" + attr.differs("new_#NAME#_value", fromReferenceType("#NAME#_values.get(_parameters)", attr.getType())) + ")\n" +
         ind(5) + "state().CHANGE = true;\n" +
         ind(4) + "#NAME#_values.put(_parameters, " + toReferenceType("new_#NAME#_value", attr.getType()) + ");\n" +
         ind(4) + "state().CIRCLE_INDEX++;\n" +
         attr.cycleLimitCheck() +
         ind(3) + "} while (state().CHANGE);\n" +
         ind(3) +  attr.cacheStoreRewrite() + "{\n" +
         ind(3) + "#NAME#_computed.add(_parameters);\n" +
         attr.cacheCycleInit() +
         ind(3) + "}\n" +
         ind(3) + "else {\n" +
         attr.resetCycleInit() +
         ind(3) + "#NAME#_computed.remove(_parameters);\n" +
         ind(3) + "#NAME#_initialized.remove(_parameters);\n" +
         ind(3) + "}\n" +
         ind(3) + "state().IN_CIRCLE = false; \n" +
         ind(3) + "return new_#NAME#_value;\n" +
         ind(2) + "}\n" +
         ind(2) + "if(!new Interger(state().CIRCLE_INDEX).equals(#NAME#_visited.get(_parameters))) {\n" +
         ind(3) + "#NAME#_visited.put(_paramters, new Integer(state().CIRCLE_INDEX));\n" +
         attr.cacheCycleCheck() +
         attr.resetCycleCheck() +
         ind(3) + "#TYPE# new_#NAME#_value = " + Unparser.unparse(attr.getBottomValue()) + ";\n" +
         ind(3) + "combine_#NAME#_contributions(new_#NAME#_value);\n" +
         ind(3) + "if (" + attr.differs("new_#NAME#_value", fromReferenceType("#NAME#_values.get(_parameters)", attr.getType())) + ")\n" +
         ind(4) + "state().CHANGE = true;\n" +
         ind(3) + "#NAME#_values.put(_parameters, " + toReferenceType("new_#NAME#_value", attr.getType()) + ");\n" +
         ind(3) + "return new_#NAME#_value;\n" +
         ind(2) + "}\n" +
         ind(2) + "return " + fromReferenceType("#NAME#_values.get(_parameters)" , attr.getType()) + ";\n" +
         (ASTNode.block ? ASTNode.blockEnd : "") +
         ind + "}\n\n";
  }

  public String CollDecl.cacheCycleCheck() {
    if(!separateEvaluation())
      return super.cacheCycleCheck();
    if (!cacheCycle) return "";
    if(getNumParameter() == 0)
      return
         ind(3) + "if (state().LAST_CYCLE) {\n" +
         setVisited() +
         circularComputeCall() + ";\n" +
         clearVisited(ind(4)) +
         ind(4) + "#NAME#_computed = true;\n" +
         ind(4) + "return #NAME#_value;\n" +
         ind(3) + "}\n";
     else
       return
         ind(3) + "if (state().LAST_CYCLE) {\n" +
         setVisited() +
         circularComputeCall() + ";\n" +
         clearVisited(ind(4)) +
         ind(4) + "#NAME#_computed.add(_parameters);\n" +
         ind(4) + "return " + fromReferenceType("#NAME#_values.get(_parameters)" , getType()) + ";\n" +
         ind(3) + "}\n";
  }

  // only used by circular collection attributes
  public String CollDecl.circularComputeCall() {
    if(separateEvaluation())
      return "new_#NAME#_value = " + Unparser.unparse(getBottomValue()) + ";\n" +
             "root.#TYPEINSIGNATURE#_#NAME#_nextIteration(this)";
    return "#NAME#_value = combine_#NAME#_contributions(" + Unparser.unparse(getBottomValue()) + ")";
  }

  // only used by non-circular collection attributes
  public String CollDecl.computeMethod() {
    String rootType = root().name();
    if(separateEvaluation()) // TODO: replace naive() with separateEvaluation()
      return
      ind + "/**\n" +
      ind + " * @apilevel internal\n" +
      ind + " */\n" +
      ind + "private #TYPE# #CLASS#.#METHODNAME#_compute(#PARMDECL#) {\n" +
      ind(2) + "ASTNode node = this;\n" +
      ind(2) + "while(node.getParent() != null && !(node instanceof " + rootType + "))\n" +
      ind(3) + "node = node.getParent();\n" +
      collDebugString() +
      ind(2) + "" + rootType + " root = (" + rootType + ")node;\n" +
      ind(2) + "#NAME#_value = " + Unparser.unparse(getBottomValue()) + ";\n" +
      ind(2) + "root.#TYPEINSIGNATURE#_#NAME#_nextIteration(this);\n" +
      ind(2) + "return #NAME#_value;\n" +
      ind + "}\n\n";
    else if(onePhase())
      return
      ind + "/**\n" +
      ind + " * @apilevel internal\n" +
      ind + " */\n" +
      ind + "private #TYPE# #CLASS#.#METHODNAME#_compute(#PARMDECL#) {\n" +
      ind(2) + "ASTNode node = this;\n" +
      ind(2) + "while(node.getParent() != null && !(node instanceof " + rootType + "))\n" +
      ind(3) + "node = node.getParent();\n" +
      collDebugString() +
      ind(2) + "" + rootType + " root = (" + rootType + ")node;\n" +
      ind(2) + "root.collect_contributors_#COLLECTINGSIGNATURE#();\n" +
      ind(2) + "if(#NAME#_value == null) #NAME#_value = " +
      Unparser.unparse(getBottomValue()) + ";\n" +
      ind(2) + "return #NAME#_value;\n" +
      ind + "}\n\n";
    else
      return
      ind + typeDefaultSet + " #CLASS#.#NAME#_contributors" + (lazyMaps ? "" : (" = " + ASTNode.createContributorSet)) + ";\n" +
      ind + "public " + typeDefaultSet + " #CLASS#.#NAME#_contributors() {\n" +
      (lazyMaps ? (ind(2) + "if(#NAME#_contributors == null) #NAME#_contributors  = " + ASTNode.createContributorSet + ";\n") : "") +
      ind(2) + "return #NAME#_contributors;\n" +
      ind + "}\n" +
      ind + "/**\n" +
      ind + " * @apilevel internal\n" +
      ind + " */\n" +
      ind + "private #TYPE# #CLASS#.#METHODNAME#_compute(#PARMDECL#) {\n" +
      ind(2) + "ASTNode node = this;\n" +
      ind(2) + "while(node.getParent() != null && !(node instanceof " + rootType + "))\n" +
      ind(3) + "node = node.getParent();\n" +
      collDebugString() +
      ind(2) + "" + rootType + " root = (" + rootType + ")node;\n" +
      ind(2) + "root.collect_contributors_#COLLECTINGSIGNATURE#();\n" +
      ind(2) + "#NAME#_value = " + Unparser.unparse(getBottomValue()) + ";\n" +
      (lazyMaps ? ind(2) + "if(#NAME#_contributors != null)\n" : "") +
      ind(2) + "for(java.util.Iterator iter = #NAME#_contributors.iterator(); iter.hasNext(); ) {\n" +
      ind(3) + "ASTNode contributor = (ASTNode)iter.next();\n" +
      ind(3) + "contributor.contributeTo_" + getTarget() + "_#NAME#(#NAME#_value);\n" +
      ind(2) + "}\n" +
      // TODO: disabled temporarily since collections may not be cached
      //(lazyMaps ? ind(2) + "#NAME#_contributors = null;\n" : "") +
      ind(2) + "return #NAME#_value;\n" +
      ind + "}\n\n";
  }
  // only used by circular collection attributes
  public String CollDecl.combineMethod() {
    if(separateEvaluation())
      return "";

    String rootType = root().name();
    String s =
      ind + typeDefaultSet + " #CLASS#.#NAME#_contributors" + (lazyMaps ? "" : (" = " + ASTNode.createContributorSet)) + ";\n" +
      ind + "public " + typeDefaultSet + " #CLASS#.#NAME#_contributors() {\n" +
      (lazyMaps ? (ind(2) + "if(#NAME#_contributors == null) #NAME#_contributors  = " + ASTNode.createContributorSet + ";\n") : "") +
      ind(2) + "return #NAME#_contributors;\n" +
      ind + "}\n" +
      ind + "private #TYPE# #CLASS#.combine_#NAME#_contributions(#TYPE# h) {\n" +
      (lazyMaps ? ind(2) + "if(#NAME#_contributors != null)\n" : "") +
      ind(2) + "for(java.util.Iterator iter = #NAME#_contributors.iterator(); iter.hasNext(); ) {\n" +
      ind(3) + "ASTNode contributor = (ASTNode)iter.next();\n" +
      ind(3) + "contributor.contributeTo_" + getTarget() + "_#NAME#(h);\n" +
      ind(2) + "}\n" +
      // TODO: disabled temporarily since collections may not be cached
      //(lazyMaps ? ind(2) + "#NAME#_contributors = null;\n" : "") +
      ind(2) + "return h;\n" +
      ind + "}\n\n";
      return s;
  }

  syn boolean ASTDecl.isASTNode() = name().equals("ASTNode");
  syn boolean TypeDecl.hasCollEq(CollDecl decl) = false;
  eq ASTDecl.hasCollEq(CollDecl decl) {
    for(int i = 0; i < getNumCollEq(); i++)
      if(getCollEq(i).decl() == decl)
        return true;
    return false;
  }

  syn lazy String CollEq.contributionSignature() = ((CollDecl)decl()).getTarget() + "_" + attributeSignature();

  syn boolean AttrDecl.separateEvaluation() = hasAnnotation("@SeparateEvaluation") || naive();
  syn boolean AttrEq.separateEvaluation() = decl().separateEvaluation();
  syn boolean AttrDecl.lazyCondition() = hasAnnotation("@LazyCondition");
  syn boolean AttrEq.lazyCondition() = decl().lazyCondition();

  syn boolean AttrDecl.onePhase() = hasAnnotation("@OnePhase") /*|| naive()*/;
  syn boolean AttrEq.onePhase() = decl().onePhase();

  syn boolean AttrDecl.naive() = hasAnnotation("@Naive");
  syn boolean AttrEq.naive() = decl().naive();

  public String ASTDecl.genCollContributions() {
    // find all coll eq in this node and group them according to either the coll decl or group name
    StringBuffer result = new StringBuffer();
    result.append(collectContributors());
    result.append(contributeTo());
    // and similar code for separate evaluation
    result.append(nextIteration());
    return result.toString();
  }

  private String ASTDecl.collectContributors() {
    HashMap map = new LinkedHashMap();
    for(int i = 0; i < getNumCollEq(); i++) {
      CollEq attr = getCollEq(i);
      if(!attr.separateEvaluation()) {
        String signature = attr.collectingSignature();
        if(!map.containsKey(signature))
          map.put(signature, new ArrayList());
        ArrayList list = (ArrayList)map.get(signature);
        list.add(attr);
      }
    }

    StringBuffer result = new StringBuffer();
    for(Iterator iter = map.keySet().iterator(); iter.hasNext(); ) {
      String key = (String)iter.next();
      ArrayList list = (ArrayList)map.get(key);
      StringBuffer buf = new StringBuffer();
      buf.append(ind + "protected void #CLASS#.collect_contributors_" + key + "() {\n"); // once per group

      if(isRootNode()) {
        buf.append(ind(2) + "if(collect_contributors_" + key + ") return;\n");
      }
      for(Iterator i2 = list.iterator(); i2.hasNext(); ) {
        CollEq attr = (CollEq)i2.next();
        CollDecl decl = (CollDecl)attr.decl();
        String NAME = attr.attributeSignature();
        buf.append(ind + attr.hostFileComment(ind, decl));
        for(int j = 0; j < attr.getNumContribution(); j++) {
          Contribution c = attr.getContribution(j);
          if(decl.onePhase() || decl.separateEvaluation()) { // TODO: add || decl.separateEvaluation()
            if(c.getCondition() != null && c.getCondition().trim().length()>0)
              buf.append(ind(2) + "if(" + c.getCondition().trim() + ") {\n");
            if(attr.getRefSet()) {
                buf.append(ind(3) + "for(java.util.Iterator iter = (" + attr.getReference() + ").iterator(); iter.hasNext(); ) {\n");
                buf.append(ind(4) + attr.getTargetName() + " ref = (" + attr.getTargetName() + ")iter.next();\n");
                buf.append(ind(4) + "if(ref != null) {\n");
                buf.append(ind(5) + "if(ref." + NAME + "_value == null) ref." + NAME + "_value = " + Unparser.unparse(decl.getBottomValue()) + ";\n");
                buf.append(ind(5) + "ref." + NAME + "_value." + decl.getCombOp() + "(" + c.getValue().trim() + ");\n");
                buf.append(ind(4) + "}\n");
                buf.append(ind(3) + "}\n");
            }
            else {
                buf.append(ind(3) + "{\n");
                buf.append(ind(4) + attr.getTargetName() + " ref = " + attr.getReference() + ";\n");
                buf.append(ind(4) + "if(ref != null) {\n");
                buf.append(ind(5) + "if(ref." + NAME + "_value == null) ref." + NAME + "_value = " + Unparser.unparse(decl.getBottomValue()) + ";\n");
                buf.append(ind(5) + "ref." + NAME + "_value." + decl.getCombOp() + "(" + c.getValue().trim() + ");\n");
                buf.append(ind(4) + "}\n");
                buf.append(ind(3) + "}\n");
            }
            if(c.getCondition() != null && c.getCondition().trim().length()>0)
              buf.append(ind(2) + "}\n");
          }
          else {
            if(c.getCondition() != null && c.getCondition().trim().length()>0 && !decl.lazyCondition())
              buf.append(ind(2) + "if(" + c.getCondition().trim() + ") {\n");

            if(attr.getRefSet()) {
              buf.append(ind(2) + "for(java.util.Iterator iter = (" + attr.getReference() + ").iterator(); iter.hasNext(); ) {\n");
              buf.append(ind(3) + attr.getTargetName() + " ref = (" + attr.getTargetName() + ")iter.next();\n");
              buf.append(ind(3) + "if(ref != null)\n");
              buf.append(ind(3) + "ref." + NAME + "_contributors().add(this);\n"); // one name per collection attribute
              buf.append(ind(2) + "}\n");
            }
            else {
              buf.append(ind(2) + "{\n");
              buf.append(ind(3) + "" + attr.getTargetName() + " ref = (" + attr.getTargetName() + ")(" + attr.getReference().trim() + ");\n");
              buf.append(ind(3) + "if(ref != null)\n");
              buf.append(ind(4) + "ref." + NAME + "_contributors().add(this);\n"); // one name per collection attribute
              buf.append(ind(3) + "}");
            }

            if(c.getCondition() != null  && c.getCondition().trim().length()>0 && !decl.lazyCondition())
              buf.append(ind(2) + "}\n");
          }
        }
      }
      if(isASTNode()) {
        buf.append(ind(2) + "for(int i = 0; i < getNumChild(); i++)\n");
        buf.append(ind(3) + "getChild(i).collect_contributors_" + key + "();\n"); // once per group
      }
      else {
        buf.append(ind(2) + "super.collect_contributors_" + key + "();\n");
        if(isRootNode()) {
          buf.append(ind(2) + "collect_contributors_" + key + " = true;\n");
        }
      }
      buf.append(ind + "}\n");
      String s = buf.toString();
      s = s.replaceAll("#CLASS#\\.", "");
      result.append(s);
    }
    return result.toString();
  }

  private String ASTDecl.contributeTo() {
    StringBuffer result = new StringBuffer();
    HashMap map = new LinkedHashMap();
    for(int i = 0; i < getNumCollEq(); i++) {
      CollEq attr = getCollEq(i);
      if(!attr.separateEvaluation() && !attr.onePhase()) {
        if(!map.containsKey(attr.decl()))
          map.put(attr.decl(), new ArrayList());
        ArrayList list = (ArrayList)map.get(attr.decl());
        list.add(attr);
      }
    }
    for(Iterator iter = map.keySet().iterator(); iter.hasNext(); ) {
      CollDecl decl = (CollDecl)iter.next();
      ArrayList list = (ArrayList)map.get(decl);
      StringBuffer buf = new StringBuffer();
      buf.append(ind + "protected void #CLASS#.contributeTo_#TYPEINSIGNATURE#_#NAME#(" + decl.getType() + " collection) {\n");
      buf.append(ind(2) + "super.contributeTo_#TYPEINSIGNATURE#_#NAME#(collection);\n");
      for(Iterator i2 = list.iterator(); i2.hasNext(); ) {
        CollEq attr = (CollEq)i2.next();
      for(int j = 0; j < attr.getNumContribution(); j++) {
        Contribution c = attr.getContribution(j);
        if(c.getCondition() != null && c.getCondition().trim().length()>0 /* && attr.getNumContribution() > 1*/) {
          buf.append(ind(2) + "if(" + c.getCondition().trim() + ")\n");
          buf.append(ind(3) + "collection." + decl.getCombOp() + "(" + c.getValue().trim() + ");\n");
        }
        else {
          buf.append(ind(2) + "collection." + decl.getCombOp() + "(" + c.getValue().trim() + ");\n");
        }
      }
      }
      buf.append(ind + "}\n\n");
      String s = buf.toString();
      s = s.replaceAll("#TYPEINSIGNATURE#", decl.getTarget());
      s = s.replaceAll("#COLLECTINGSIGNATURE#", decl.collectingSignature());
      s = s.replaceAll("#CLASS#\\.", "");
      s = s.replaceAll("#NAME#", decl.attributeSignature());
      result.append(s);
    }
    return result.toString();
  }

  private String ASTDecl.nextIteration() {
    HashMap map = new LinkedHashMap();
    for(int i = 0; i < getNumCollEq(); i++) {
      CollEq attr = getCollEq(i);
      if(attr.separateEvaluation()) {
        if(!map.containsKey(attr.contributionSignature()))
          map.put(attr.contributionSignature(), new ArrayList());
        ArrayList list = (ArrayList)map.get(attr.contributionSignature());
        list.add(attr);
      }
    }

    StringBuffer result = new StringBuffer();
    for(Iterator iter = map.keySet().iterator(); iter.hasNext(); ) {
      String key = (String)iter.next();
      ArrayList list = (ArrayList)map.get(key);
      StringBuffer buf = new StringBuffer();
      buf.append(ind + "protected void #CLASS#.#TYPEINSIGNATURE#_#NAME#_nextIteration(#TYPEINSIGNATURE# n) {\n");
      CollDecl decl = null;
      CollEq attr = null;
      for(Iterator i2 = list.iterator(); i2.hasNext(); ) {
        attr = (CollEq)i2.next();
        decl = (CollDecl)attr.decl();
        String NAME = attr.attributeSignature();
        buf.append(ind + attr.hostFileComment(ind, decl));
        for(int j = 0; j < attr.getNumContribution(); j++) {
          Contribution c = attr.getContribution(j);
          if(c.getCondition() != null && c.getCondition().trim().length()>0) {
            if(attr.lazyCondition()) {
              if(attr.getRefSet()) {
                buf.append(ind(3) + "for(java.util.Iterator iter = (" + attr.getReference() + ").iterator(); iter.hasNext(); ) {\n");
                buf.append(ind(4) + attr.getTargetName() + " ref = (" + attr.getTargetName() + ")iter.next();\n");
                buf.append(ind(4) + "if(ref == n && (" + c.getCondition().trim() + ")) n.new_" + NAME + "_value." + decl.getCombOp() + "(" + c.getValue().trim() + ");\n");
                buf.append(ind(3) + "}\n");
              }
              else {
                buf.append(ind(3) + "if(" + attr.getReference() + " == n && (" + c.getCondition().trim() + ")) n.new_" + NAME + "_value." + decl.getCombOp() + "(" + c.getValue().trim() + ");\n");
              }
            }
            else {
              buf.append(ind(2) + "if(" + c.getCondition().trim() + ") {\n");
              if(attr.getRefSet()) {
                buf.append(ind(3) + "for(java.util.Iterator iter = (" + attr.getReference() + ").iterator(); iter.hasNext(); ) {\n");
                buf.append(ind(4) + attr.getTargetName() + " ref = (" + attr.getTargetName() + ")iter.next();\n");
                buf.append(ind(4) + "if(ref == n) n.new_" + NAME + "_value." + decl.getCombOp() + "(" + c.getValue().trim() + ");\n");
                buf.append(ind(3) + "}\n");
              }
              else {
                buf.append(ind(3) + "if(" + attr.getReference() + " == n) n.new_" + NAME + "_value." + decl.getCombOp() + "(" + c.getValue().trim() + ");\n");
              }
              buf.append(ind(2) + "}\n");
            }
          }
          else {
            if(attr.getRefSet()) {
              buf.append(ind(2) + "for(java.util.Iterator iter = (" + attr.getReference() + ").iterator(); iter.hasNext(); ) {\n");
              buf.append(ind(3) + attr.getTargetName() + " ref = (" + attr.getTargetName() + ")iter.next();\n");
              buf.append(ind(3) + "if(ref == n) n.new_" + NAME + "_value." + decl.getCombOp() + "(" + c.getValue().trim() + ");\n");
              buf.append(ind(2) + "}\n");
            }
            else
              buf.append(ind(2) + "if(" + attr.getReference() + " == n) n.new_" + NAME + "_value." + decl.getCombOp() + "(" + c.getValue().trim() + ");\n");
          }
        }
      }
      if(isASTNode()) {
        buf.append(ind(2) + "for(int i = 0; i < getNumChild(); i++)\n");
        buf.append(ind(3) + "getChild(i).#TYPEINSIGNATURE#_#NAME#_next_Iteration(n);\n"); // once per group
      }
      else
        buf.append(ind(3) + "r.#TYPEINSIGNATURE#_#NAME#_nextIteration(n);\n");
      buf.append(ind + "}\n");
      String s = buf.toString();
      if(decl != null && !decl.isCircular()) { // TODO:replace decl.naive() with !decl.isCircular()
        s = s.replaceAll("n.new_", "n.");
      }
      s = s.replaceAll("#TYPE#", decl.getType());
      s = s.replaceAll("#TYPEINSIGNATURE#", decl.getTarget());
      s = s.replaceAll("#COLLECTINGSIGNATURE#", decl.collectingSignature());
      s = s.replaceAll("#CLASS#\\.", "");
      s = s.replaceAll("#NAME#", attr.attributeSignature());
      s = s.replaceAll("#METHODNAME#", attr.attributeName());
      s = s.replaceAll("#PARMDECL#", attr.parametersDecl());
      s = s.replaceAll("#PARM#", attr.parameters());
      result.append(s);
    }
    return result.toString();
  }


  syn String CollEq.collectingSignature() = decl().collectingSignature();
  syn lazy String AttrDecl.collectingSignature() = attributeSignature();
  eq CollDecl.collectingSignature() {
    String value = getAnnotationValue("@CollectionGroup");
    if(value != null)
      return "CollectionGroup_" + value;
    return attributeSignature();
  }

  syn String CollEq.attributeSignature() = decl().attributeSignature();
  syn lazy String CollDecl.attributeSignature() {
    StringBuffer s = new StringBuffer();
    s.append(getTarget());
    s.append("_");
    s.append(name());
    for(int i = 0; i < getNumParameter(); i++) {
      s.append("_" + getParameter(i).getType());
    }
    return s.toString();
  }

  syn ASTDecl Grammar.root() = (ASTDecl)roots().iterator().next();
  eq ASTDecl.getCollDecl().hostClass() = this;
  eq ASTDecl.getCollEq().hostClass() = this;

  public void Grammar.weaveCollectionAttributes() {
    for(int i = 0; i < getNumTypeDecl(); i++)
      getTypeDecl(i).weaveCollectionAttributes();
  }
  public void TypeDecl.weaveCollectionAttributes() { }

  private HashSet TypeDecl.processedCollectingSignatures = null;
  protected boolean TypeDecl.processedCollectingSignature(String signature) {
    if(processedCollectingSignatures == null)
      processedCollectingSignatures = new LinkedHashSet();
    if(processedCollectingSignatures.contains(signature))
      return true;
    processedCollectingSignatures.add(signature);
    return false;
  }
  protected String TypeDecl.collectionReset = "";

  public void ASTDecl.weaveCollectionAttributes() {
    for(int i = 0; i < getNumCollDecl(); i++) {
      CollDecl attr = getCollDecl(i);
      boolean separateEvaluation = attr.separateEvaluation();
      TypeDecl astDecl = env().lookup("ASTNode");
      TypeDecl rootDecl = attr.root();
      if(astDecl != null && rootDecl != null) {
        boolean process = !astDecl.processedCollectingSignature(attr.collectingSignature());
        String s = "";
        if(!astDecl.hasCollEq(attr) && process) {
          if(separateEvaluation)
            s =
            ind + "protected void #CLASS#.#TYPEINSIGNATURE#_#NAME#_nextIteration(#TYPEINSIGNATURE# n) {\n" +
            ind(2) + "for(int i = 0; i < getNumChild(); i++)\n" +
            ind(3) + "getChild(i).#TYPEINSIGNATURE#_#NAME#_nextIteration(n);\n" +
            ind + "}\n\n";
          if(process && !separateEvaluation/*&& attr.isCircular() && !separateEvaluation*/) // TODO: replace !attr.naive() with !(!attr.isCircular() && separateEvaluation)
            s = s +
            ind + "protected void #CLASS#.collect_contributors_#COLLECTINGSIGNATURE#() {\n" +
            ind(2) + "for(int i = 0; i < getNumChild(); i++)\n" +
            ind(3) + "getChild(i).collect_contributors_#COLLECTINGSIGNATURE#();\n" +
            ind + "}\n\n";

          if(!separateEvaluation && (attr.isCircular() || !attr.onePhase())) // TODO: add && !attr.separateEvaluation()
          s = s +
            ind + "protected void #CLASS#.contributeTo_#TYPEINSIGNATURE#_#NAME#(" + attr.getType() + " collection) {\n" +
            ind + "}\n";
          s = s.replaceAll("#TYPE#", attr.getType());
          s = s.replaceAll("#TYPEINSIGNATURE#", attr.getTarget());
          s = s.replaceAll("#COLLECTINGSIGNATURE#", attr.collectingSignature());
          s = s.replaceAll("#CLASS#\\.", "");
          s = s.replaceAll("#NAME#", attr.attributeSignature());
          s = s.replaceAll("#METHODNAME#", attr.attributeName());
          s = s.replaceAll("#PARMDECL#", attr.parametersDecl());
          s = s.replaceAll("#PARM#", attr.parameters());

          astDecl.classBodyDecls.add(buildClassBodyObject(s, attr.getFileName(), attr.getStartLine()));
        }
        if(process) {
          s = "";
          String flush = "";
          if(attr.circularCollection() && !separateEvaluation) { // TODO: remove && !attr.naive()
            s =
              ind + "private boolean #CLASS#.collect_contributors_#COLLECTINGSIGNATURE# = false;\n" +
              ind + "public boolean #CLASS#.collecting_contributors_#COLLECTINGSIGNATURE# = false;\n" +
              ind + "protected void #CLASS#.collect_contributors_#COLLECTINGSIGNATURE#() {\n" +
              ind(2) + "if(collect_contributors_#COLLECTINGSIGNATURE#) return;\n" +
              ind(2) + "collecting_contributors_#COLLECTINGSIGNATURE# = true;\n" +
              ind(2) + "super.collect_contributors_#COLLECTINGSIGNATURE#();\n" +
              ind(2) + "collecting_contributors_#COLLECTINGSIGNATURE# = false;\n" +
              ind(2) + "collect_contributors_#COLLECTINGSIGNATURE# = true;\n" +
              ind + "}\n\n";
            flush =
              ind(2) + "collect_contributors_#COLLECTINGSIGNATURE# = false;\n" +
              ind(2) + "collecting_contributors_#COLLECTINGSIGNATURE# = false;\n";
          } else if(!attr.circularCollection() && !attr.separateEvaluation()) { // TODO: replace !attr.naive() with !attr.separateEvaluation()
            if(!rootDecl.hasCollEq(attr)) {
              s =
              ind + "private boolean #CLASS#.collect_contributors_#COLLECTINGSIGNATURE# = false;\n" +
              ind + "protected void #CLASS#.collect_contributors_#COLLECTINGSIGNATURE#() {\n" +
              ind(2) + "if(collect_contributors_#COLLECTINGSIGNATURE#) return;\n" +
              ind(2) + "super.collect_contributors_#COLLECTINGSIGNATURE#();\n" +
              ind(2) + "collect_contributors_#COLLECTINGSIGNATURE# = true;\n" +
              ind + "}\n\n";
            }
            else {
              s =
              ind + "private boolean #CLASS#.collect_contributors_#COLLECTINGSIGNATURE# = false;\n";
            }
            flush =
              ind(2) + "collect_contributors_#COLLECTINGSIGNATURE# = false;\n";
          }
          s = s.replaceAll("#TYPE#", attr.getType());
          s = s.replaceAll("#TYPEINSIGNATURE#", attr.getTarget());
          s = s.replaceAll("#COLLECTINGSIGNATURE#", attr.collectingSignature());
          s = s.replaceAll("#CLASS#\\.", "");
          s = s.replaceAll("#NAME#", attr.attributeSignature());
          s = s.replaceAll("#METHODNAME#", attr.attributeName());
          s = s.replaceAll("#PARMDECL#", attr.parametersDecl());
          s = s.replaceAll("#PARM#", attr.parameters());
          rootDecl.classBodyDecls.add(buildClassBodyObject(s, attr.getFileName(), attr.getStartLine()));
          flush = flush.replaceAll("#COLLECTINGSIGNATURE#", attr.collectingSignature());
          rootDecl.collectionReset += flush;
        }
      }
    }
  }

  private ClassBodyObject ASTDecl.buildClassBodyObject(String data, String fileName, int line) {
    jrag.AST.SimpleNode n = new jrag.AST.ASTBlock(0);
    n.firstToken = n.lastToken = jrag.AST.Token.newToken(0);
    n.firstToken.image = data;
    return new ClassBodyObject(n, fileName, line, "<NoAspect>");
  }



  // name binding
  eq CollEq.decl() {
    TypeDecl typeDecl = hostClass().env().lookup(getTargetName());
    if(typeDecl != null /*&& typeDecl instanceof ASTDecl*/) {
      TypeDecl astDecl = (TypeDecl)typeDecl;
      for(int i = 0; i < astDecl.getNumCollDecl(); i++)
        if(astDecl.getCollDecl(i).getName().equals(getTargetAttributeName()))
          return astDecl.getCollDecl(i);
    }
    return null;
  }

  coll HashSet CollDecl.uses() [new LinkedHashSet()] with add;
  CollEq contributes this when decl() != null to CollDecl.uses() for decl();

  // build AST from parser
  // EMMA_2009-11-27: Adding enclosing aspect as parameter
  public void Grammar.addCollDecl(String name, String type, String className, String fileName, int startLine, int endLine, ASTExpression startValue, String combOp, boolean isCircular, ArrayList annotations, jrag.AST.SimpleNode node, String root, String aspectName) {
    TypeDecl c = lookup(className);
    if(c != null/* && c instanceof ASTDecl*/) {
      CollDecl decl = new CollDecl();
      decl.setName(name);
      decl.setType(type);
      decl.setLazy(true);
      decl.setFileName(fileName);
      decl.setStartLine(startLine);
      decl.setEndLine(endLine);
      decl.setParameterList(new List());
      decl.setStartValue(startValue);
      decl.setCombOp(combOp);
      decl.setAnnotations(annotations);
      decl.setCircularCollection(isCircular || annotations.contains("@Circular"));
      decl.setComment(Unparser.unparseComment(node));
      decl.setTarget(className);
      decl.root = root;
      decl.setAspectName(aspectName);
      ((TypeDecl)c).addCollDecl(decl);
    }
    else
      error("Can not add collection attribute " + type + " " + name + " to unknown class " + className + " in " + fileName + " at line " + startLine);
  }

  public String CollDecl.root = null;

  public boolean AttrDecl.hasAnnotation(String s) { return false; }
  public boolean CollDecl.hasAnnotation(String s) {
    if(annotations == null) return false;
    for(Iterator iter = annotations.iterator(); iter.hasNext(); ) {
      String a = (String)iter.next();
      if(a.equals(s) || a.startsWith(s + "("))
        return true;
    }
    return false;
  }
  public String CollDecl.getAnnotationValue(String s) {
    for(Iterator iter = annotations.iterator(); iter.hasNext(); ) {
      String key = (String)iter.next();
      key = key.replace('(', ',');
      key = key.replace(')', ',');
      if(key.startsWith(s + ",")) {
        String[] strs = key.split(",");
        if(strs.length > 1) {
          return strs[1].substring(1,strs[1].length()-1); // remove quotes
        }
      }
    }
    return null;
  }
  private ArrayList CollDecl.annotations;
  public void CollDecl.setAnnotations(ArrayList list) {
    annotations = list;
  }


  public void Grammar.addCollEq(String targetName, String targetAttributeName, String attributeType, String reference, ast.AST.List contributionList, String fileName, int startLine, int endLine, boolean refSet, jrag.AST.SimpleNode node, String aspectName) {
    TypeDecl c = lookup(attributeType);
    if(c != null && c instanceof ASTDecl) {
      CollEq collEq = new CollEq(
          new List(),
          targetName,
          fileName,
          startLine,
          endLine,
          Unparser.unparseComment(node),
          aspectName,
          contributionList,
          targetName,
          targetAttributeName,
          refSet,
          reference);
      ((ASTDecl)c).addCollEq(collEq);
    }
    else
      error("Can not add collection contribution to unknown class " + attributeType + " in " + fileName + " at line " + startLine);
  }

  private ASTExpression CollDecl.startValue;
  public void CollDecl.setStartValue(ASTExpression e) { startValue = e; }
  public ASTExpression CollDecl.getBottomValue() { return startValue; }
  private String CollDecl.combOp;
  public void CollDecl.setCombOp(String s) { combOp = s; }
  public String CollDecl.getCombOp() { return combOp; }
  private boolean CollDecl.circularCollection;
  public void CollDecl.setCircularCollection(boolean b) { circularCollection = b; }
  public boolean CollDecl.circularCollection() { return circularCollection; }
  public boolean CollDecl.isCircular() { return circularCollection(); }


  eq CollDecl.error() {
    StringBuffer result = new StringBuffer();
    for(Iterator iter = annotations.iterator(); iter.hasNext(); ) {
      String annotation = (String)iter.next();
      if(!knownAnnotation(annotation)) {
        result.append(getFileName() + ":" + getStartLine() + " ");
        result.append("Unknown annotation: " + annotation + "\n");
      }
    }
    if(hasAnnotation("@CollectionGroup")) {
      String value = getAnnotationValue("@CollectionGroup");
      if(value == null)
        result.append(getFileName() + ":" + getStartLine() + " Missing CollectionGroup argument\n");
      else if(value.equals(""))
        result.append(getFileName() + ":" + getStartLine() + " CollectionGroup argument can not be empty\n");
      else if(!isValidIdentifierPart(value))
        result.append(getFileName() + ":" + getStartLine() + " CollectionGroup argument must be a valid identifier part\n");
    }
    if(root == null && hostClass().env().roots().size() != 1) {
      result.append(getFileName() + ":" + getStartLine() + " Multiple tree roots to search for contributions. Please explicitly select one of");
      for(Iterator iter = hostClass().env().roots().iterator(); iter.hasNext(); ) {
        ASTDecl decl = (ASTDecl)iter.next();
        result.append(" " + decl.name());
      }
      result.append("\n");
    }
    if(uses().isEmpty())
      result.append(getFileName() + ":" + getStartLine() + " No contributions for this collection attribute\n");
    return result.toString();
  }

  private static boolean CollDecl.isValidIdentifierPart(String s) {
    for(int i = 0; i < s.length(); i++)
      if(!Character.isJavaIdentifierPart(s.charAt(i)))
        return false;
    return true;
  }

  syn boolean CollDecl.knownAnnotation(String s) {
    if(s.equals("@OnePhase"))
      return true;
    if(s.equals("@SeparateEvaluation"))
      return true;
    if(s.equals("@LazyCondition"))
      return true;
    if(s.equals("@Circular"))
      return true;
    if(s.equals("@CollectionGroup") || s.startsWith("@CollectionGroup("))
      return true;
    if(s.equals("@Naive"))
      return true;
    return false;
  }

  eq CollEq.error() {
    StringBuffer result = new StringBuffer();
  if(decl() == null) {
      result.append(getFileName() + ":" + getStartLine() + " ");
      result.append("Undeclared collection attribute " + "\n");
  }
    return result.toString();
  }

}
