/* Copyright (c) 2005-2013, The JastAdd Team
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Lund University nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

aspect ASTCloneNode {

  public void ASTDecl.jjtGenCloneNode(PrintWriter stream, String parserName, boolean jjtree, boolean rewriteEnabled) {
    if(ASTNode.java5) {
      // covariant return type when using Java 5
      String name = name();
      if(name().equals("Opt") || name().equals("List") || name().equals("ASTNode"))
        name = name + "<T>";
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ASTNode.suppressWarnings() + ind + "public " + name + " clone() throws CloneNotSupportedException {");
    }
    else {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ASTNode.suppressWarnings() + ind + "public Object clone() throws CloneNotSupportedException {");
    }
    if(ASTNode.block) stream.print(ASTNode.blockBegin);

    stream.print(ind(2) + name() + " node = (" + name() + ")super.clone();\n");

    for(int k = 0; k < getNumSynEq(); k++) {
      AttrEq equ = getSynEq(k);
      AttrDecl attr = equ.decl();
      String u = attr.resetVisit() + attr.resetCache();
      u = u.replaceAll("#NAME#", "node." + attr.attributeSignature());
      stream.print(u);
    }
    for(int k = 0; k < getNumInhDecl(); k++) {
      AttrDecl attr = getInhDecl(k);
      String u = attr.resetVisit() + attr.resetCache();
      u = u.replaceAll("#NAME#", "node." + attr.attributeSignature());
      stream.print(u);
    }

    if(ASTNode.rewriteEnabled) {
      stream.print(ind(2) + "node.in$Circle(false);\n");
      if(ASTNode.stagedRewrites)
        stream.print(ind(2) + "node.is$Final(0);\n");
      else
        stream.print(ind(2) + "node.is$Final(false);\n");
    }

    // I'd like to set the parent to null, but this would change the interface of fullCopy,
    // and existing applications might depend on the copy to still be parented by the original
    // AST. So I don't do it. Yet. 20100416/GH.
    //
    /* 20120301/JO: Updated fullCopy to set parent to null.
     * P.S. Is the shallow copy method really needed/used?
     */

    stream.print(ind(2) + "return node;\n");
    if(ASTNode.block) stream.print(ASTNode.blockEnd);
    stream.print(ind + "}\n");

    if(!hasAbstract()) {
      // We skip copying NTA children
      // Build list of NTA indices - these are skipped when copying the children
      LinkedList ntaAggregateIndices = new LinkedList();
      LinkedList ntaOptIndices = new LinkedList();
      LinkedList ntaListIndices = new LinkedList();
      int i = 0;
      for(Iterator iter = getComponents(); iter.hasNext(); i += 1) {
        Components c = (Components)iter.next();
        if (c.isNTA()) {
          if (c instanceof ListComponentsNTA)
            ntaListIndices.add(new Integer(i));
          else if (c instanceof OptionalComponentNTA)
            ntaOptIndices.add(new Integer(i));
          else if (c instanceof AggregateComponentsNTA)
            ntaAggregateIndices.add(new Integer(i));
        }
      }

      // The skipNTAs string will include a switch statement that excludes
      // the NTA children from the full copy, but for Opt and List NTAs
      // we still need to create a placeholder Opt/List node
      String skipNTAs = "";
      if (!ntaAggregateIndices.isEmpty() || !ntaOptIndices.isEmpty() ||
        !ntaListIndices.isEmpty()) {

        skipNTAs = ind(5) + "switch (i) {\n";
        Iterator iter;
        if (!ntaAggregateIndices.isEmpty()) {
          iter = ntaAggregateIndices.iterator();
          while (iter.hasNext()) {
            Object index = iter.next();
            skipNTAs += ind(5) + "case " + index.toString() + ":\n";
          }
          skipNTAs += ind(6) + "tree.children[i] = null;\n";
          skipNTAs += ind(6) + "continue;\n";
        }
        if (!ntaOptIndices.isEmpty()) {
          iter = ntaOptIndices.iterator();
          while (iter.hasNext()) {
            Object index = iter.next();
            skipNTAs += ind(5) + "case " + index.toString() + ":\n";
          }
          skipNTAs += ind(6) + "tree.children[i] = new Opt();\n";
          skipNTAs += ind(6) + "continue;\n";
        }
        if (!ntaListIndices.isEmpty()) {
          iter = ntaListIndices.iterator();
          while (iter.hasNext()) {
            Object index = iter.next();
            skipNTAs += ind(5) + "case " + index.toString() + ":\n";
          }
          skipNTAs += ind(6) + "tree.children[i] = new List();\n";
          skipNTAs += ind(6) + "continue;\n";
        }
        skipNTAs += ind(5) + "}\n";
      }

      String s =
        ind + "/**\n" +
        ind + " * Create a deep copy of the AST subtree at this node.\n" +
        ind + " * The copy is dangling, i.e. has no parent.\n" +
        ind + " * @return dangling copy of the subtree at this node\n" +
        ind + " * @apilevel low-level\n" +
        ind + " */\n" +
        "#ANNOTATIONS#" +
        ind + "public #RETURN# fullCopy() {\n" + 
        (ASTNode.block ? ASTNode.blockBegin : "") +
        ind(2) + "#ID# tree = (#ID#) copy();\n" +
        ind(2) + "if (children != null) {\n" +
        // ES_2011-10-04: Code generation for incremental evaluation, clone
        ind(3) +   "for (int i = 0; i < children.length; ++i) {\n" +
        skipNTAs +
        ind(4) +     "ASTNode child = (ASTNode) children[i];\n" +
        ind(4) +     "if(child != null) {\n" +
        ind(5) +       "child = child.fullCopy();\n" +
        // ES_2011-10-04: Code generation for incremental evaluation, clone
        (ASTNode.incremental ? jjtGenIncrementalCloneNode() : 
        ind(5) +       "tree.setChild(child, i);\n") +
        ind(4) +     "}\n" +
        ind(3) +   "}\n" +
        ind(2) + "}\n" +
        ind(2) + "return tree;\n" +
        ind + "}\n" +
        (ASTNode.block ? ASTNode.blockEnd : "");

      String returnName = name();
      if(name().equals("Opt") || name().equals("List") || name().equals("ASTNode"))
        returnName = returnName + "<T>";
      s = s.replaceAll("#RETURN#", ASTNode.java5 ? returnName : "ASTNode");
      s = s.replaceAll("#ANNOTATIONS#", ASTNode.suppressWarnings());
      s = s.replaceAll("#CLASS#", name());
      s = s.replaceAll("#ID#", name());

      TemplateContext tt = tt();
      tt.bind("ReturnType", ASTNode.java5 ? returnName : "ASTNode");
      tt.bind("Annotations", ASTNode.suppressWarnings());
      tt.bind("BlockBegin", (ASTNode.block ? ASTNode.blockBegin : ""));
      tt.bind("BlockEnd", (ASTNode.block ? ASTNode.blockEnd : ""));
      tt.bind("IncrementalCopyNode",
          (ASTNode.incremental ? genIncrementalCopyNode() : ""));
      stream.print(tt.expand("ast.copy"));

      stream.print(s);
    }
  }

}
